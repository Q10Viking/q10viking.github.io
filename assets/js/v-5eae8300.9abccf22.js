"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[81007],{92130:(s,n,a)=>{a.r(n),a.d(n,{data:()=>e});const e={key:"v-5eae8300",path:"/ddd/04%20DDD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/ddd/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"领域",slug:"领域",children:[]},{level:2,title:"限界上下文",slug:"限界上下文",children:[{level:3,title:"通用语言",slug:"通用语言",children:[]},{level:3,title:"限界上下文与微服务的关系",slug:"限界上下文与微服务的关系",children:[]}]},{level:2,title:"实体",slug:"实体",children:[]},{level:2,title:"值对象",slug:"值对象",children:[]},{level:2,title:"DDD领域模型驱动",slug:"ddd领域模型驱动",children:[]},{level:2,title:"聚合",slug:"聚合",children:[]},{level:2,title:"聚合根",slug:"聚合根",children:[]},{level:2,title:"领域事件",slug:"领域事件",children:[]}],filePathRelative:"ddd/04 DDD基本概念.md"}},5197:(s,n,a)=>{a.r(n),a.d(n,{default:()=>u});var e=a(20641);const p=(0,e.Fv)('<h2 id="领域" tabindex="-1"><a class="header-anchor" href="#领域" aria-hidden="true">#</a> 领域</h2><ul><li><strong>领域</strong>：就是用来确定范围的，范围即边界</li><li><strong>子领域</strong>：领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，每个子域对应一个 更小的问题域或更小的业务范围</li></ul><p>在领域不断划分的过程中，领域会细分为不同的子域，子域可以根据自身重要性和功能属性 划分为三类子域，它们分别是：<strong>核心域</strong>、<strong>通用域</strong>和<strong>支撑域</strong></p><ul><li><strong>核心域</strong>: 决定产品和公司核心竞争力的子域,它是业务成功的主要因素和公司的核心竞争 力</li><li><strong>通用域</strong>: 没有太多个性化的诉求，同时被多个子域使用的通用功能子域，如：用到的通用系统，比如认证、权限</li><li><strong>支撑域</strong>：该子域是必需的，但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域， 它就是支撑域</li></ul><hr><h2 id="限界上下文" tabindex="-1"><a class="header-anchor" href="#限界上下文" aria-hidden="true">#</a> 限界上下文</h2><p>电商领域的商品，在不同的阶段有不同的术语，在销售阶段是商品，而在运输 阶段则变成了货物。同样的一个东西，由于业务领域的不同，赋予了这些术语不同的涵义和 职责边界，这个边界就可能会成为未来微服务设计的边界，领域边界就是通过限界上下文来定义的。</p><h3 id="通用语言" tabindex="-1"><a class="header-anchor" href="#通用语言" aria-hidden="true">#</a> 通用语言</h3><p>通用语言包含术语和用例场景，并且能够直接反映在代码中。通用语言中的名词可以给领域 对象命名，如商品、订单等，对应实体对象；而动词则表示一个动作或事件，如商品已下 单、订单已付款等，对应领域事件或者命令</p><p>通用语言贯穿 DDD 的整个设计过程。作为项目团队沟通和协商形成的统一语言，基于它， 你就能够开发出可读性更好的代码，将业务需求准确转化为代码设计</p><h3 id="限界上下文与微服务的关系" tabindex="-1"><a class="header-anchor" href="#限界上下文与微服务的关系" aria-hidden="true">#</a> 限界上下文与微服务的关系</h3><p>理论上限界上下文就是微服务的边界。我们将限界上下文内的领域模型映射到微服务，就完 成了从问题域到软件的解决方案</p><p>限界上下文是微服务设计和拆分的主要依据。在领域模型中，如果不考虑技术异 构、团队沟通等其它外部因素，一个限界上下文理论上就可以设计为一个微服务。</p><h2 id="实体" tabindex="-1"><a class="header-anchor" href="#实体" aria-hidden="true">#</a> 实体</h2><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>实体的业务形态</p></div><p>在 DDD 不同的设计过程中，实体的形态是不同的。在战略设计时，实体是领域模型的一个 重要对象。领域模型中的实体是多个属性、操作或行为的载体。在事件风暴中，我们可以根 据命令、操作或者事件，找出产生这些行为的业务实体对象，进而按照一定的业务规则将依 存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合</p><blockquote><p>实体和值对象是组成领域模型的基础单元。</p></blockquote><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>实体的代码形态</p></div><p>在代码模型中，实体的表现形式是实体类，这个类包含了实体的属性和方法，通过这些方法 实现实体自身的业务逻辑。在 DDD 里，这些实体类通常采用充血模型，与这个实体相关的 所有业务逻辑都在实体类的方法中实现，<strong>跨多个实体的领域逻辑则在领域服务中实现</strong>。</p><hr><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>实体的运行形态</p></div><p>实体以 DO（领域对象）的形式存在，每个实体对象都有唯一的 ID。我们可以对一个实体 对象进行多次修改，修改后的数据和原来的数据可能会大不相同。但是，由于它们拥有相同 的 ID，它们依然是同一个实体。比如商品是商品上下文的一个实体，通过唯一的商品 ID 来 标识，不管这个商品的数据如何变化，商品的 ID 一直保持不变，它始终是同一个商品。</p><hr><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>实体的数据库形态</p></div><p>与传统数据模型设计优先不同，DDD 是先构建领域模型，针对实际业务场景构建实体对象 和行为，再将实体对象映射到数据持久化对象。 在领域模型映射到数据模型时，一个实体可能对应 0 个、1 个或者多个数据库持久化对 象。大多数情况下实体与持久化对象是一对一</p><h2 id="值对象" tabindex="-1"><a class="header-anchor" href="#值对象" aria-hidden="true">#</a> 值对象</h2><p>值对象本质上就是一个集。那这个集合里面有什么呢？若干个用于描述目的、具有整体概念和不可修改的属性。那这个集合存在的意义又是什么？在领域建模的过程中，值对象可以保证属性归类的清晰和概念的完整性，避免属性零碎</p><p><img src="/images/ddd/image-20230526175413694.png" alt="image-20230526175413694"></p><p>人员实体原本包括：姓名、年龄、性别以及人员所在的省、市、县和街道等属性。这样显示 地址相关的属性就很零碎了对不对？现在，我们可以将“省、市、县和街道等属性”拿出来 构成一个“地址属性集合”，这个集合就是值对象了。</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>值对象的业务形态</p></div><p>值对象是 DDD 领域模型中的一个基础对象，它跟实体一样都来源于事件风暴所构建的领域 模型，都包含了若干个属性，它与实体一起构成聚合。 我们不妨对照实体，来看值对象的业务形态，这样更好理解。本质上，实体是看得到、摸得 着的实实在在的业务对象，实体具有业务属性、业务行为和业务逻辑。而值对象只是若干个 属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。 值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描 述实体的特征。</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>值对象的代码形态</p></div><p>值对象在代码中有这样两种形态。如果值对象是单一属性，则直接定义为实体类的属性；如 果值对象是属性集合，则把它设计为 Class 类，Class 将具有整体概念的多个属性归集到属 性集合，这样的值对象没有 ID，会被实体整体引用。</p><p>person 这个实体有若干个单一属性的值对象，比如 Id、name 等属性；同时它也包含多个属性的值对象，比如地址 address。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> person<span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token constant">ID</span><span class="token punctuation">;</span>  <span class="token comment">// 值对象，人员唯一主键</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span> <span class="token comment">// 单一属性值对象</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token comment">// 单一属性值对象</span>\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> gender<span class="token punctuation">;</span> <span class="token comment">//单一属性值对象</span>\n    <span class="token keyword">public</span> <span class="token class-name">Address</span> address<span class="token punctuation">;</span> <span class="token comment">// 属性值对象，被实体引用</span>\n    <span class="token comment">// 其他业务逻辑方法</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Address</span><span class="token punctuation">{</span>  <span class="token comment">// 值对象，无主键ID</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> province<span class="token punctuation">;</span> <span class="token comment">// 值对象</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> city<span class="token punctuation">;</span> <span class="token comment">// 值对象</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span>  country<span class="token punctuation">;</span> <span class="token comment">// 值对象</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span>  street<span class="token punctuation">;</span> <span class="token comment">// 值对象</span>\n    <span class="token comment">// 其他一些方法如setter/getter方法</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>值对象的运行形态</p></div><p>实体实例化后的 DO 对象的业务属性和业务行为非常丰富，但值对象实例化的对象则相对 简单和乏味。除了值对象数据初始化和整体替换的行为外，其它业务行为就很少了。</p><p>值对象嵌入到实体的话，有这样两种不同的数据格式，也可以说是两种方式，分别是属性嵌 入的方式和序列化大对象的方式。 引用单一属性的值对象或只有一条记录的多属性值对象的实体，可以采用属性嵌入的方式嵌 入。引用一条或多条记录的多属性值对象的实体，可以采用序列化大对象的方式嵌入。</p><p>比 如，人员实体可以有多个通讯地址，多个地址序列化后可以嵌入人员的地址属性。值对象创 建后就不允许修改了，只能用另外一个值对象来整体替换</p><blockquote><p>案例 1：以属性嵌入的方式形成的人员实体对象，地址值对象直接以属性值嵌入人员实体 中。</p></blockquote><p><img src="/images/ddd/image-20230526182152159.png" alt="image-20230526182152159"></p><blockquote><p>案例 2：以序列化大对象的方式形成的人员实体对象，地址值对象被序列化成大对象 Json 串后，嵌入人员实体中。</p></blockquote><p><img src="/images/ddd/image-20230526182219387.png" alt="image-20230526182219387"></p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>值对象的数据库形态</p></div><p>举个例子，还是基于上述人员和地址那个场景，实体和数据模型设计通常有两种解决方案： 第一是把地址值对象的所有属性都放到人员实体表中，创建人员实体，创建人员数据表；第 二是创建人员和地址两个实体，同时创建人员和地址两张表。</p><p>第一个方案会破坏地址的业务涵义和概念完整性，第二个方案增加了不必要的实体和表，需 要处理多个实体和表的关系，从而增加了数据库设计的复杂性。</p><p>那到底应该怎样设计，才能让业务含义清楚，同时又不让数据库变得复杂呢？ 我们可以综合这两个方案的优势，扬长避短。在领域建模时，我们可以把地址作为值对象， 人员作为实体，这样就可以保留地址的业务涵义和概念完整性。而在数据建模时，我们可以 将地址的属性值嵌入人员实体数据库表中，只创建人员数据库表。这样既可以兼顾业务含义 和表达，又不增加数据库的复杂度。</p><p>值对象就是通过这种方式，简化了数据库设计，总结一下就是：在领域建模时，我们可以将 部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时， 我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计。</p><h2 id="ddd领域模型驱动" tabindex="-1"><a class="header-anchor" href="#ddd领域模型驱动" aria-hidden="true">#</a> DDD领域模型驱动</h2><p><strong>DDD 提倡从领域模型设计出发，而不是先设计数据模型</strong>。前面讲过了，传统的数据模型设 计通常是一个表对应一个实体，一个主表关联多个从表，当实体表太多的时候就很容易陷入 无穷无尽的复杂的数据库设计，领域模型就很容易被数据模型绑架。可以说，值对象的诞 生，在一定程度上，和实体是互补的。</p><p><img src="/images/ddd/image-20230526175413694.png" alt="image-20230526175413694"></p><p>在领域模型中人员是实体，地址是值对象，地址值对象被人员实体引用。在数据模型设计 时，地址值对象可以作为一个属性集整体嵌入人员实体中，组合形成上图这样的数据模型； 也可以以序列化大对象的形式加入到人员的地址属性中，前面表格有展示。 从这个例子中，我们可以看出，同样的对象在不同的场景下，可能会设计出不同的结果。有 些场景中，地址会被某一实体引用，它只承担描述实体的作用，并且它的值只能整体替换， 这时候你就可以将地址设计为值对象，比如收货地址。而在某些业务场景中，地址会被经常 修改，地址是作为一个独立对象存在的，这时候它应该设计为实体，比如行政区划中的地址 信息维护。</p><h2 id="聚合" tabindex="-1"><a class="header-anchor" href="#聚合" aria-hidden="true">#</a> 聚合</h2><p>社会是由一个个的个体组成的，象征着我们每一个人。随着社会的发展，慢慢出 现了社团、机构、部门等组织，我们开始从个人变成了组织的一员，大家可以协同一致的工 作，朝着一个最大的目标前进，发挥出更大的力量。</p><blockquote><p>领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它 用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。</p></blockquote><p>聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据 修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化</p><p>聚合在 DDD 分层架构里属于领域层，领域层包含了多个聚合，共同实现核心业务逻辑。聚 合内实体以充血模型实现个体业务能力，以及业务逻辑的高内聚。跨多个实体的业务逻辑通 过领域服务来实现，跨多个聚合的业务逻辑通过应用服务来实现。比如有的业务场景需要同 一个聚合的 A 和 B 两个实体来共同完成，我们就可以将这段业务逻辑用领域服务来实现； 而有的业务逻辑需要聚合 C 和聚合 D 中的两个服务共同完成，这时你就可以用应用服务来 组合这两个服务。</p><p><img src="/images/ddd/image-20230526193024635.png" alt="image-20230526193024635"></p><h2 id="聚合根" tabindex="-1"><a class="header-anchor" href="#聚合根" aria-hidden="true">#</a> 聚合根</h2><p>聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实 体之间数据不一致性的问题。</p><p>传统数据模型中的每一个实体都是对等的，如果任由实体进行无控制地调用和数据修改，很 可能会导致实体之间数据逻辑的不一致。而如果采用锁的方式则会增加软件的复杂度，也会 降低系统的性能</p><blockquote><p>如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实 体，还是聚合的管理者</p></blockquote><p>首先它作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑。 其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成 共同的业务逻辑。 最后在聚合之间，它还是聚合对外的接口人，以聚合根 ID 关联的方式接受外部任务和请 求，在上下文内实现聚合之间的业务协同。也就是说，聚合之间通过聚合根 ID 关联引用， 如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能 直接访问聚合内实体。</p>',63),t={href:"https://www.baeldung.com/spring-persisting-ddd-aggregates",target:"_blank",rel:"noopener noreferrer"},l=(0,e.Lk)("h2",{id:"领域事件",tabindex:"-1"},[(0,e.Lk)("a",{class:"header-anchor",href:"#领域事件","aria-hidden":"true"},"#"),(0,e.eW)(" 领域事件")],-1),c=(0,e.Lk)("p",null,"一个领域事件将导 致进一步的业务操作，在实现业务解耦的同时，还有助于形成完整的业务闭环。",-1),i=(0,e.Lk)("blockquote",null,[(0,e.Lk)("p",null,"聚合的一个设计原则：在边界之外使用最终一致性")],-1),r=(0,e.Lk)("p",null,"领域事件驱动设计可以切断领域模型之间的强依赖关系，事件发布完成后，发布方不必关心 后续订阅方事件处理是否成功，这样可以实现领域模型的解耦，维护领域模型的独立性和数 据的一致性。在领域模型映射到微服务系统架构时，领域事件可以解耦微服务，微服务之间 的数据不必要求强一致性，而是基于事件的最终一致性。",-1),o=(0,e.Lk)("hr",null,null,-1),d={},u=(0,a(66262).A)(d,[["render",function(s,n){const a=(0,e.g2)("OutboundLink");return(0,e.uX)(),(0,e.CE)(e.FK,null,[p,(0,e.Lk)("p",null,[(0,e.Lk)("a",t,[(0,e.eW)("Persisting DDD Aggregates | Baeldung"),(0,e.bF)(a)])]),l,c,i,r,o],64)}]])},66262:(s,n)=>{n.A=(s,n)=>{const a=s.__vccOpts||s;for(const[s,e]of n)a[s]=e;return a}}}]);
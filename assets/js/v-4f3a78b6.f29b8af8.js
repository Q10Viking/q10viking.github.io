"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[71071],{14349:(e,a,i)=>{i.r(a),i.d(a,{data:()=>p});const p={key:"v-4f3a78b6",path:"/gRPC/04%20HTTP2.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/gRPC/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:3,title:"",slug:"",children:[]},{level:2,title:"HTTP/1.x缺陷",slug:"http-1-x缺陷",children:[{level:3,title:"head-of-line blocking（线头阻塞）",slug:"head-of-line-blocking-线头阻塞",children:[]},{level:3,title:"协议开销大",slug:"协议开销大",children:[]},{level:3,title:"安全因素",slug:"安全因素",children:[]}]},{level:2,title:"HTTP/2新特性",slug:"http-2新特性",children:[{level:3,title:"二进制传输",slug:"二进制传输",children:[]},{level:3,title:"多路复用",slug:"多路复用",children:[]},{level:3,title:"header压缩",slug:"header压缩",children:[]},{level:3,title:"Server Push",slug:"server-push",children:[]}]}],filePathRelative:"gRPC/04 HTTP2.md"}},92643:(e,a,i)=>{i.r(a),i.d(a,{default:()=>t});const p=(0,i(20641).Fv)('<blockquote><p>为什么会选用 http2 作为 gRPC 的传输协议？</p></blockquote><p>除了速度之外，最大的原因就是最大程度的服务兼容性。因为 gRPC 基于 http2 协议，加之市面上主流的代理工具也都支持 http2 协议，所以自然就支持 gRPC 了。</p><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h3><h2 id="http-1-x缺陷" tabindex="-1"><a class="header-anchor" href="#http-1-x缺陷" aria-hidden="true">#</a> HTTP/1.x缺陷</h2><p><strong>连接无法复用</strong></p><p>连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对大量小文件请求影响较大（没有达到最大窗口请求就被终止）。</p><ul><li>HTTP/1.0 传输数据时，每次都需要重新建立连接，增加延迟。</li><li>HTTP/1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。</li></ul><h3 id="head-of-line-blocking-线头阻塞" tabindex="-1"><a class="header-anchor" href="#head-of-line-blocking-线头阻塞" aria-hidden="true">#</a> <strong>head-of-line blocking（线头阻塞）</strong></h3><p>会导致带宽无法被充分利用，以及后续健康请求被阻塞。假设有5个请求同时发出，如下图</p><p><img src="/images/grpc/1635756558091-ab994773-0f68-41c8-a02c-8e2a4a12be99.jpeg" alt="img"></p><p>对于http1.0的实现，在第一个请求没有收到回复之前，后续从应用层发出的请求只能排队，请求2，3，4，5只能等请求1的response回来之后才能逐个发出。</p><p>在http1.1中，引入了pipeline来解决head of line blocking，如下图</p><p><img src="/images/grpc/1635756577506-904d1b9d-f5d2-4165-b96b-80c687e547bb.jpeg" alt="img"></p><p>请求2，3，4，5不用等请求1的response返回之后才发出，而是几乎在同一时间把request发向了服务器。</p><p>下图可以看到pipeline机制对延迟的改变效果：</p><p><img src="/images/grpc/1635756599069-2c325e3c-3411-4caa-b7b5-cdb6ba91521f.jpeg" alt="img"></p><p>pipeline提高了性能，但head of line blocking并没有完全得到解决，server的response还是要求依次返回，遵循FIFO(first in first out)原则。也就是说如果请求1的response没有回来，2，3，4，5的response也不会被送回来。</p><p><img src="/images/grpc/1635756708903-a1ffb911-7770-4a6f-8e88-4f447dfb74aa.png" alt="image.png"></p><p>如上图所示，红色圈出来的请求就因域名链接数已超过限制，而被挂起等待了一段时间。</p><h3 id="协议开销大" tabindex="-1"><a class="header-anchor" href="#协议开销大" aria-hidden="true">#</a> <strong>协议开销大</strong></h3><p>HTTP1.x 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。</p><h3 id="安全因素" tabindex="-1"><a class="header-anchor" href="#安全因素" aria-hidden="true">#</a> <strong>安全因素</strong></h3><p>HTTP1.x 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性</p><h2 id="http-2新特性" tabindex="-1"><a class="header-anchor" href="#http-2新特性" aria-hidden="true">#</a> HTTP/2新特性</h2><h3 id="二进制传输" tabindex="-1"><a class="header-anchor" href="#二进制传输" aria-hidden="true">#</a> 二进制传输</h3><p>HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。</p><p>每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</p><p>HTTP/2 仍是对之前 HTTP 标准的扩展，而非替代。 HTTP 的应用语义不变，提供的功能不变，HTTP 方法、状态代码、URI 和标头字段等这些核心概念也不变。</p><p><img src="/images/grpc/1635759967918-aed0cd56-ab19-470f-9f7c-5dbaa9408b47.png" alt="image.png"></p><p>这里所谓的“层”，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制：HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。 HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。</p><p>新的二进制分帧机制改变了客户端与服务器之间交换数据的方式。 为了说明这个过程，我们需要了解 HTTP/2 的三个概念：</p><ul><li><strong>数据流 (stream)</strong>：已建立的连接内的双向字节流，可以承载一条或多条消息。</li><li><strong>消息 (message)</strong>：与逻辑请求或响应消息对应的完整的一系列帧。</li><li><strong>帧 (frame)</strong>：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li></ul><p>这些概念的关系总结如下：</p><ul><li>所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。</li><li>每条stream都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。</li><li>每个message都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。</li><li>frame是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><p><img src="/images/grpc/1635760046283-728bef7a-2cf4-48ef-a9e5-eed77418fe02.png" alt="image.png"></p><p>简言之，HTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用。</p><p>http2.0的frame格式与http1.x的消息对比</p><p><img src="/images/grpc/1635760109257-188b2c1e-f965-441b-91a0-10e24a0cd1a1.png" alt="image.png"></p><ul><li>length定义了整个frame的开始到结束，</li><li>type定义frame的类型（一共10种）；</li><li>flags用bit位定义一些重要的参数；</li><li>stream id用作流控制，一个request对应一个stream并分配一个id，这样一个连接上可以有多个stream，每个stream的frame可以随机的混杂在一起，接收方可以根据stream id将frame再归属到各自不同的request里面；</li><li>payload就是request的正文了；</li></ul><p>虽然看上去协议的格式和http1.x完全不同了，实际上http2.0并没有改变http1.x的语义，只是把原来http1.x的header和body部分用frame重新封装了一层而已。调试的时候浏览器甚至会把http2.0的frame自动还原成http1.x的格式。</p><p>对于http1.x来说，是通过设置tcp segment里的reset flag来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。http2.0引入<strong>RST_STREAM</strong>类型的frame，可以在不断开连接的前提下取消某个request的stream，表现更好。</p><h3 id="多路复用" tabindex="-1"><a class="header-anchor" href="#多路复用" aria-hidden="true">#</a> 多路复用</h3><p>直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。当流并发时，就会涉及到流的优先级和依赖。优先级高的流会被优先发送。</p><p>下图快照捕捉了同一个连接内并行的多个数据流。 客户端正在向服务器传输一个 <code>DATA</code> 帧（数据流 5），与此同时，服务器正向客户端交错发送数据流 1 和数据流 3 的一系列帧。因此，一个连接上同时有三个并行数据流</p><p><img src="/images/grpc/1635760422137-194ef239-4d81-467f-897e-00120ecef14e.png" alt="image.png"></p><p>将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP 2 最重要的一项增强：</p><ul><li>并行交错地发送多个请求，请求之间互不影响。</li><li>并行交错地发送多个响应，响应之间互不干扰。</li><li>使用一个连接并行发送多个请求和响应。</li><li>不必再为绕过 HTTP/1.x 限制而做很多工作（例如级联文件、image sprites和域名分片）</li><li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。</li></ul><p>HTTP/2 中的新二进制分帧层解决了 HTTP/1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。</p><p><img src="/images/grpc/1635760600959-d68dbfd6-3a7a-4d3a-8a29-4c0d9d5c2716.png" alt="image.png"></p><h3 id="header压缩" tabindex="-1"><a class="header-anchor" href="#header压缩" aria-hidden="true">#</a> header压缩</h3><p>在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p><p>为了减少这块的资源消耗并提升性能， HTTP/2 对这些首部采取了压缩策略：</p><ul><li>HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</li><li>首部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li><li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值</li></ul><p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销</p><p><img src="/images/grpc/1635760972988-3b67fe05-6e92-4601-8723-de5fdd3a78b3.png" alt="image.png"></p><h3 id="server-push" tabindex="-1"><a class="header-anchor" href="#server-push" aria-hidden="true">#</a> Server Push</h3><p>服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。</p><p><img src="/images/grpc/1635832033848-eb3fba82-9af3-44a6-8810-05efc8f7190b.png" alt="image.png"></p><p>HTTP/2 打破了严格的请求-响应语义，支持一对多和服务器发起的推送工作流。</p><p>所有服务器推送数据流都由 <code>**PUSH_PROMISE**</code> 帧发起，表明了服务器向客户端推送所述资源的意图，并且需要先于请求推送资源的响应数据传输。 这种传输顺序非常重要：客户端需要了解服务器打算推送哪些资源，以免为这些资源创建重复请求。 满足此要求的最简单策略是先于父响应（即，<code>DATA</code> 帧）发送所有 <code>PUSH_PROMISE</code> 帧，其中包含所承诺资源的 HTTP 标头。</p><p>假设服务端接收到客户端对 HTML 文件的请求，决定用 server push 推送一个css文件。那么，服务端会构造一个请求，包括请求方法和请求头，填充到一个 PUSH_PROMISE 帧里发送给客户端，来告知客户端它已经代劳发了这个请求。当客户端收到这个 PUSH_PROMISE 帧的时候，它就知道服务端将要推送一个CSS文件回来。如果此时客户端需要请求这个文件，即便服务端还没推完，它也不会往服务端发送对CSS文件的请求。在这个例子中，必须先发送 PUSH_PROMISE，再发送 HTML 的内容。这是因为 HTML 中存在对CSS的引用，一旦客户端发现了这个引用却还没收到 PUSH_PROMISE，它就会发起获取CSS文件请求。</p><p><img src="/images/grpc/1635832078140-ef80d229-e5d5-4360-a906-d9dd523a1f28.png" alt="img"></p><p>在客户端接收到 <code>PUSH_PROMISE</code> 帧后，它可以根据自身情况选择拒绝数据流（通过 <code>RST_STREAM</code> 帧）。 （例如，如果资源已经位于缓存中，便可能会发生这种情况。） 这是一个相对于 HTTP/1.x 的重要提升。 相比之下，使用资源内联（一种受欢迎的 HTTP/1.x“优化”）等同于“强制推送”：客户端无法选择拒绝、取消或单独处理内联的资源。</p><p>使用 HTTP/2，客户端仍然完全掌控服务器推送的使用方式。 客户端可以限制并行推送的数据流数量；调整初始的流控制窗口以控制在数据流首次打开时推送的数据量；或完全停用服务器推送。 这些优先级在 HTTP/2 连接开始时通过 <code>SETTINGS</code> 帧传输，可能随时更新。</p><p>推送的每个资源都是一个数据流，与内嵌资源不同，客户端可以对推送的资源逐一复用、设定优先级和处理。 浏览器强制执行的唯一安全限制是，推送的资源必须符合原点相同这一政策：服务器对所提供内容必须具有权威性。</p>',65),r={},t=(0,i(66262).A)(r,[["render",function(e,a){return p}]])},66262:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,p]of a)i[e]=p;return i}}}]);
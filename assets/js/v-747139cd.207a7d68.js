"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[80228],{58291:(t,r,n)=>{n.r(r),n.d(r,{data:()=>o});const o={key:"v-747139cd",path:"/concurrency/67%20ReentrantLock%E7%9A%84%E5%85%AC%E5%B9%B3%E6%80%A7%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E6%80%A7%E5%AE%9E%E7%8E%B0.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/concurrency/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[],filePathRelative:"concurrency/67 ReentrantLock的公平性与非公平性实现.md"}},32818:(t,r,n)=>{n.r(r),n.d(r,{default:()=>c});const o=(0,n(20641).Fv)("<p>ReentrantLock是Java中提供的一种可重入锁，它支持两种锁的模式：<strong>公平锁和非公平锁</strong>。这两种锁模式的底层实现略有不同：</p><ol><li><strong>公平锁（Fair Lock）</strong>： <strong>公平锁的特点是按照请求锁的顺序来分配锁，即先到先得</strong>。在ReentrantLock中，通过构造函数可以选择创建一个公平锁。公平锁的底层实现使用了一个FIFO队列（First-In-First-Out），即等待队列。当一个线程请求锁时，如果锁已经被其他线程持有，请求线程会被放入等待队列的末尾，按照请求的顺序等待锁的释放。当锁被释放时，等待队列中的第一个线程会被唤醒并获得锁。</li><li><strong>非公平锁（Non-Fair Lock）</strong>： <strong>非公平锁不考虑请求锁的顺序</strong>，它允许新的请求线程插队并尝试立即获取锁，而不管其他线程是否在等待。在ReentrantLock中，默认情况下创建的是非公平锁。非公平锁的底层实现中，有一个等待队列，但它不会严格按照请求的顺序来分配锁，而是根据线程竞争锁的情况来判断是否立即分配给新的请求线程。</li></ol><p>底层实现中，无论是公平锁还是非公平锁，都使用了类似的同步器（Sync）来管理锁的状态和线程的竞争。不同之处在于如何处理等待队列中的线程，以及是否按照请求的顺序来分配锁。</p><p>需要注意的是，<strong>公平锁虽然遵循公平性原则，但在高并发情况下可能会引入较大的性能开销</strong>，因为每次都要维护一个有序的等待队列。而<strong>非公平锁则更加灵活，但可能导致某些线程一直获取不到锁</strong>。</p>",4),e={},c=(0,n(66262).A)(e,[["render",function(t,r){return o}]])},66262:(t,r)=>{r.A=(t,r)=>{const n=t.__vccOpts||t;for(const[t,o]of r)n[t]=o;return n}}}]);
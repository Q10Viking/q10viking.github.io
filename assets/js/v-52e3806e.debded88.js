"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[78018],{72008:(a,e,l)=>{l.r(e),l.d(e,{data:()=>i});const i={key:"v-52e3806e",path:"/seata/01%20%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/seata/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"数据库事务",slug:"数据库事务",children:[{level:3,title:"本地事务",slug:"本地事务",children:[]}]},{level:2,title:"分布式事务理论",slug:"分布式事务理论",children:[{level:3,title:"CAP理论",slug:"cap理论",children:[]},{level:3,title:"AP与CP的取舍",slug:"ap与cp的取舍",children:[]},{level:3,title:"BASE理论",slug:"base理论",children:[]}]},{level:2,title:"分布式事务处理(DTP)模型",slug:"分布式事务处理-dtp-模型",children:[]},{level:2,title:"分布式事务产生的背景",slug:"分布式事务产生的背景",children:[{level:3,title:"跨库事务",slug:"跨库事务",children:[]},{level:3,title:"分库分表",slug:"分库分表",children:[]},{level:3,title:"业务服务化拆分",slug:"业务服务化拆分",children:[]}]},{level:2,title:"解决方案",slug:"解决方案",children:[{level:3,title:"2PC",slug:"_2pc",children:[]},{level:3,title:"3PC",slug:"_3pc",children:[]},{level:3,title:"XA",slug:"xa",children:[]},{level:3,title:"TCC",slug:"tcc",children:[]},{level:3,title:"可靠消息最终一致性❤️",slug:"可靠消息最终一致性❤️",children:[]},{level:3,title:"saga",slug:"saga",children:[]},{level:3,title:"最大努力通知",slug:"最大努力通知",children:[]}]}],filePathRelative:"seata/01 事务基础.md"}},35483:(a,e,l)=>{l.r(e),l.d(e,{default:()=>s});const i=(0,l(20641).Fv)('<h2 id="数据库事务" tabindex="-1"><a class="header-anchor" href="#数据库事务" aria-hidden="true">#</a> 数据库事务</h2><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>ACID特性：事务（Transaction）是数据库系统中一系列操作的一个逻辑单元，所有操作要么全部成功要么全部失败。事务具有4个特性</p></div><ul><li>原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。（操作层面）</li><li>一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着<strong>所有相关的数据规则都必须应用于事务的修改</strong>,以保持数据的完整性。（数据层面）</li><li>隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的**“独立”环境执行**。这意味着<strong>事务处理过程中的中间状态对外部是不可见的</strong>,反之亦然。</li><li>持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。</li></ul><p><img src="/images/seata/image-20230419220001439.png" alt="image-20230419220001439"></p><h3 id="本地事务" tabindex="-1"><a class="header-anchor" href="#本地事务" aria-hidden="true">#</a> 本地事务</h3><p><img src="/images/seata/54181.png" alt="https://note.youdao.com/yws/public/resource/c480b9d259db401acff9fdd30a770d64/xmlnote/7FBB4069AA954991AEF3716CDB0556A1/54181"></p><blockquote><p>在JDBC编程中，我们通过java.sql.Connection对象来开启、关闭或者提交事务。</p></blockquote><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">//获取数据库连接</span>\nconn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关闭自动提交事务</span>\n<span class="token keyword">try</span><span class="token punctuation">{</span>\n   <span class="token comment">//...执行增删改查sql</span>\n   conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//提交事务</span>\n<span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//事务回滚</span>\n<span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>\n   conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭链接</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="分布式事务理论" tabindex="-1"><a class="header-anchor" href="#分布式事务理论" aria-hidden="true">#</a> 分布式事务理论</h2><h3 id="cap理论" tabindex="-1"><a class="header-anchor" href="#cap理论" aria-hidden="true">#</a> CAP理论</h3><blockquote><p>CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p></blockquote><ul><li>Consistency（一致性）: 在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li><li>Availability（可用性）: 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li><li>Partition tolerance（分区容错性，是分布式的基础）: 系统中任意信息的丢失或失败不会影响系统的继续运作。 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul><p><img src="/images/seata/60002ee86376897ae0b9167a" alt="img"></p><p>分布式系统与单机系统不同，它涉及到多节点间的通讯和交互，节点间的分区故障是必然发生的，所以在分布式系统中分区容错性（P）是必须要考虑的。</p><p>要么选择一致性（C），保证数据正确 ，要么选择可用性（A），保证服务可用</p><p>当选择了一致性（C）的时候，一定会读到最新的数据，不会读到旧数据，但如果因为消息丢失、延迟过高发生了网络分区，那么这个时候，当集群节点接收到来自客户端的读请求时，为了不破坏一致性，可能会因为无法响应最新数据，而返回出错信息。</p><p>当选择了可用性（A）的时候，系统将始终处理客户端的查询，返回特定信息，如果发生了网络分区，一些节点将无法返回最新的特定信息，它们将返回自己当前的相对新的信息。</p><hr><h4 id="ca" tabindex="-1"><a class="header-anchor" href="#ca" aria-hidden="true">#</a> CA</h4><p>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</p><h4 id="cp" tabindex="-1"><a class="header-anchor" href="#cp" aria-hidden="true">#</a> CP</h4><p>如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。</p><p>设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p><h4 id="ap" tabindex="-1"><a class="header-anchor" href="#ap" aria-hidden="true">#</a> AP</h4><p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</p><p>典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p><h3 id="ap与cp的取舍" tabindex="-1"><a class="header-anchor" href="#ap与cp的取舍" aria-hidden="true">#</a> AP与CP的取舍</h3><p>CAP理论为我们做分布式服务架构指明了方向：</p><p>分布式系统中我们只能选择CP（满足一致性牺牲可用性）或AP（满足可用性牺牲一致性）。</p><p>当我们选择CP，即满足一致性而牺牲可用性时意味着在网络异常出现多个节点孤岛时为了保证各个节点的数据一致系统会停止服务</p><p>反之选择AP，即满足可用性牺牲一致性时网络异常时系统仍可工作，但会出现各节点数据不致的情况。</p><p>在我们做微服务架构时需要知道CAP并做出架构设计或选型。比如注册中心常用的Eureka和Zookeepr实现，Eureka是AP的，Zookeeper是CP的，Spring Cloud之所以推荐Eureka是因为它认为注册中心的场景允许出现短暂的数据不一致情况，可用性要高于强一致性，再比如数据库HBase与Cassandra，两者同为NoSQL数据，部分需求两者都可满足，但我们要考虑允不允许出现数据不一致，HBase是强一致性的，Cassandra则是弱一致性的，但换来了更好的可用性。</p><h3 id="base理论" tabindex="-1"><a class="header-anchor" href="#base理论" aria-hidden="true">#</a> BASE理论</h3><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p><p>BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。</p><blockquote><ul><li>Basically Available（基本可用）</li></ul></blockquote><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</p><ol><li>响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</li><li>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ol><blockquote><ul><li>Soft state（软状态）</li></ul></blockquote><p>相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。我们把符合传统的ACID叫做刚性事务。</p><p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p><blockquote><ul><li>Eventually consistent（最终一致性）</li></ul></blockquote><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p><ul><li>因果一致性（Causal consistency）：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。</li><li>读己之所写（Read your writes）：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。</li><li>会话一致性（Session consistency）： 会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</li><li>单调读一致性（Monotonic read consistency）：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</li><li>单调写一致性（Monotonic write consistency）：一个系统要能够保证来自同一个节点的写操作被顺序的执行。</li></ul><h2 id="分布式事务处理-dtp-模型" tabindex="-1"><a class="header-anchor" href="#分布式事务处理-dtp-模型" aria-hidden="true">#</a> 分布式事务处理(DTP)模型</h2><p>2PC的传统方案是在数据库层面实现的，如Oracle、MySQL都支持2PC协议，为了统一标准减少行业内不必要的对接成本，需要制定标准化的处理模型及接口标准，国际开放标准组织Open Group定义分布式事务处理模型DTP（Distributed Transaction Processing Reference Model）。</p><ul><li>AP：应用程序（Aplication Program），一般指事务的发起者（比如数据库客户端或者访问数据库的程序），定义事务对应的操作（比如更新操作 <code>UPDATE executed_table SET status = true WHERE id=100）</code>。</li><li>RM：资源管理器（Resource Manager），管理共享资源，并提供访问接口，供外部程序来访问共享资源，比如数据库，另外 RM 还应该具有事务提交或回滚的能力。</li><li>TM：事务管理器（Transaction Manager），TM 是分布式事务的协调者。TM 与每个 RM 进行通信，协调并完成事务的处理。</li></ul><p><img src="/images/seata/6000435af346fb55c5c7efa0" alt="img"></p><h2 id="分布式事务产生的背景" tabindex="-1"><a class="header-anchor" href="#分布式事务产生的背景" aria-hidden="true">#</a> 分布式事务产生的背景</h2><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>下述讨论的分布式事务场景中，无一例外的都直接或者间接的操作了多个数据库。如何保证事务的ACID特性，对于分布式事务实现方案而言，是非常大的挑战。同时，分布式事务实现方案还必须要考虑性能的问题，如果为了严格保证ACID特性，导致性能严重下降，那么对于一些要求快速响应的业务，是无法接受的。</p></div><h3 id="跨库事务" tabindex="-1"><a class="header-anchor" href="#跨库事务" aria-hidden="true">#</a> 跨库事务</h3><p>一个应用某个功能需要操作多个库，不同的库中存储不同的业务数据。</p><p><img src="/images/seata/61cd519e07912973efad2b0d.png" alt="img"></p><h3 id="分库分表" tabindex="-1"><a class="header-anchor" href="#分库分表" aria-hidden="true">#</a> 分库分表</h3><p>业务数据库起初是单库单表，但随着业务数据规模的快速发展，数据量越来越大，单库单表逐渐成为瓶颈。所以我们对数据库进行了水平拆分，将原单库单表拆分成数据库分片。</p><p>分库分表之后，原来在一个数据库上就能完成的写操作，可能就会跨多个数据库，这就产生了跨数据库事务问题。</p><p><img src="/images/seata/60004ac21e0853437c4dfd9d.png" alt="img"></p><p><img src="/images/seata/54185.png" alt="https://note.youdao.com/yws/public/resource/c480b9d259db401acff9fdd30a770d64/xmlnote/03146D3D0974483BA741AAEC7791A227/54185"></p><blockquote><p>对于分库分表的情况，一般开发人员都会使用一些数据库中间件来降低sql操作的复杂性。如，对于sql：insert into user(id,name) values (1,&quot;张三&quot;),(2,&quot;李四&quot;)。这条sql是操作单库的语法，单库情况下，可以保证事务的一致性。 但是由于现在进行了分库分表，开发人员希望将1号记录插入分库1，2号记录插入分库2。所以数据库中间件要将其改写为2条sql，分别插入两个不同的分库，此时要保证两个库要不都成功，要不都失败，因此基本上所有的数据库中间件都面临着分布式事务的问题</p></blockquote><h3 id="业务服务化拆分" tabindex="-1"><a class="header-anchor" href="#业务服务化拆分" aria-hidden="true">#</a> 业务服务化拆分</h3><p>在业务发展初期，“一块大饼”的单业务系统架构，能满足基本的业务需求。但是随着业务的快速发展，系统的访问量和业务复杂程度都在快速增长，单系统架构逐渐成为业务发展瓶颈，解决业务系统的高耦合、可伸缩问题的需求越来越强烈。 按照面向服务架构（SOA）的设计原则，将单业务系统拆分成多个业务系统，降低了各系统之间的耦合度，使不同的业务系统专注于自身业务，更有利于业务的发展和系统容量的伸缩。</p><p>业务系统按照服务拆分之后，一个完整的业务往往需要调用多个服务，如何保证多个服务间的数据一致性成为一个难题。</p><p><img src="/images/seata/60004aca7d9c080e58cd413b.png" alt="img"></p><blockquote><p>微服务架构</p></blockquote><p><img src="/images/seata/54184.png" alt="https://note.youdao.com/yws/public/resource/c480b9d259db401acff9fdd30a770d64/xmlnote/D12491C02D3F4731A59D70776C6AE391/54184"></p><p>Service A完成某个功能需要直接操作数据库，同时需要调用Service B和Service C，而Service B又同时操作了2个数据库，Service C也操作了一个库。需要保证这些跨服务调用对多个数据库的操作要么都成功，要么都失败，实际上这可能是最典型的分布式事务场景</p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h2><p><img src="/images/seata/57197" alt="img"></p><ul><li>2PC的方案： 基于Seata AT实现</li><li>mq可靠消息的方案：基于Rocketmq事务消息实现</li></ul><h3 id="_2pc" tabindex="-1"><a class="header-anchor" href="#_2pc" aria-hidden="true">#</a> 2PC</h3><p>二阶段提交又称2PC（two-phase commit protocol）,2pc是一个非常经典的强一致、中心化的原子提交协议。这里所说的中心化是指协议中有两类节点：一个是中心化协调者节点（coordinator）和<em>N个参与者节点（partcipant）</em>，事务的提交过程分成了两个阶段来进行处理。</p><p>每个参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报，决定各参与者是否要提交操作还是终止操作</p><blockquote><p>第一阶段：准备阶段（投票阶段）</p></blockquote><p>事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交。 （Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数据文件）</p><ul><li>协调者事务询问，并开始等待</li><li>参与者执行事务</li><li>参与者反馈事务询问的响应</li></ul><blockquote><p>第二阶段：提交阶段（执行阶段）</p></blockquote><p>如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息； 参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。 注意:必须在最后阶段释放锁资源。</p><hr><p>以mysql数据库为例，如果第一阶段中所有数据库都prepare成功，那么事务管理器向数据库服务器发出&quot;确认提交&quot;请求，数据库服务器把事务的&quot;可以提交&quot;状态改为&quot;提交完成&quot;状态，然后返回应答。如果在第一阶段内有任何一个数据库的操作发生了错误，或者事务管理器收不到某个数据库的回应，则认为事务失败，回撤所有数据库的事务。数据库服务器收不到第二阶段的确认提交请求，也会把&quot;可以提交&quot;的事务回撤。</p><p><img src="/images/seata/54220.png" alt="https://note.youdao.com/yws/public/resource/c480b9d259db401acff9fdd30a770d64/xmlnote/9C5F1A2B493D4884848B23D4E8D31FFF/54220"></p><p>两阶段提交方案下全局事务的ACID特性，是依赖于RM的。一个全局事务内部包含了多个独立的事务分支，这一组事务分支要么都成功，要么都失败。各个事务分支的ACID特性共同构成了全局事务的ACID特性。也就是将单个事务分支支持的ACID特性提升一个层次到分布式事务的范畴。</p><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h4><ul><li>原理简单，实现方便</li><li>尽量保证了数据的强一致。 适合对数据强致要求很高的关键领域。（其实也不能100%保证强一致）</li></ul><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h4><ul><li>可靠性问题: 如果协调者存在单点故障问题，或出现故障，提供者将一直处于锁定状态</li><li>数据一致性问题，无法保证一致性: 若协调者第二阶段发送提交请求时崩溃，可能部分参与者受到COMMIT请求提交了事务，而另一部分参与者未受到请求而放弃事务造成不一致现象。</li><li>性能问题，阻塞: 为了保证事务完成提交，各参与者在完成第一阶段事务执行后必须锁定相关资源直到正式提交，影响系统的吞吐量。二阶段提交最大缺点就在于它的执行过程中间，节点都处于阻塞状态</li><li>对性能影响较大，不适合高并发性能场景</li></ul><h3 id="_3pc" tabindex="-1"><a class="header-anchor" href="#_3pc" aria-hidden="true">#</a> 3PC</h3><p>3PC，全称 “three phase commit”，是 2PC 的改进版，将 2PC 的 “提交事务请求Prepare” 过程一分为二（CanCommit、PreCommit），共形成了由 CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。 三阶段提交是为解决两阶段提交协议的缺点而设计的。</p><blockquote><p>与两阶段区别</p></blockquote><ul><li>引入超时机制 - 同时在协调者和参与者中都引入超时机制</li><li>在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的</li></ul><blockquote><p>第一阶段：CanCommit</p></blockquote><ol><li>协调者事务询问，并开始等待</li><li>正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态；否则反馈No</li></ol><blockquote><p>第二阶段：PreCommit</p></blockquote><ul><li>成功 <ol><li>协调者向所有参与者节点发出 preCommit 的请求，并进入 prepared 状态</li><li>参与者会执行事务操作，对应 2PC 准备阶段中的 “执行事务”，也会 Undo 和 Redo 信息记录到事务日志中</li><li>如果参与者成功执行了事务，就反馈 ACK 响应，同时等待指令：提交（commit） 或终止（abort）</li></ol></li><li>失败 <ol><li>协调者向所有参与者节点发出 abort 请求 。</li><li>参与者如果收到 abort 请求或者超时了，都会中断事务</li></ol></li></ul><blockquote><p>第三阶段：Do Commit</p></blockquote><ul><li>成功 <ol><li>协调者接收到各参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求</li><li>参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</li><li>事务提交完之后，向协调者发送 ACK 响应</li><li>协调者接收到所有参与者的 ACK 响应之后，完成事务</li></ol></li><li>失败 <ol><li>协调者向所有参与者发送 abort 请求</li><li>参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源</li><li>参与者完成事务回滚之后，向协调者发送 ACK 消息</li><li>参与者完成事务回滚之后，向协调者发送 ACK 消息</li></ol></li></ul><h4 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1" aria-hidden="true">#</a> 优点</h4><ol><li>主要解决的单点故障问题，并减少了阻塞的时间</li></ol><h4 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a> 缺点</h4><p>如有参与者节点出现了崩溃等情况而导致协调者始终无法获取所有参与者的响应信息，这时协调者将只能依赖协调者自身的超时机制来生效</p><h3 id="xa" tabindex="-1"><a class="header-anchor" href="#xa" aria-hidden="true">#</a> XA</h3><p>XA是由X/Open CAE Specification组织提出的分布式事务的规范。 XA规范主要定义了全局事务管理器(TM)和局部资源管理器(RM)之间的接口。主流的关系型数据库产品都是实现了XA接口的。</p><p>XA接口是双向的系统接口，在事务管理器 （TM）以及一个或多个资源管理器（RM）之 间形成通信桥梁。</p><p>XA之所以需要引入事务管理器是因为，在分布式系统中，从理论上讲两台机器理论上无法达到一致的状态，需要引入一个单点进行协调。</p><p>由全局事务管理器管理和协调的事务，可以跨 越多个资源（如数据库或JMS队列）和进程。全局事务管理器一般使用 XA 二阶段提交协议与数据库进行交互。</p><p><img src="/images/seata/600046b5e0b34d2060eaea44.png" alt="img"></p><blockquote><p>现状</p></blockquote><ul><li>性能问题比较严重（阻塞性协议，增加响应时间、锁时间、死锁）</li><li>数据库支持完善度，比如：Mysql5.7之前都有缺陷</li></ul><hr><h3 id="tcc" tabindex="-1"><a class="header-anchor" href="#tcc" aria-hidden="true">#</a> TCC</h3><p>TCC事务机制相对于传统事务机制（X/Open XA），其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对（由业务系统提供的）业务逻辑的调度来实现分布式事务。</p><p>TCC是服务化的两阶段编程模型，其Try、Confirm、Cancel，3个方法均由业务编码实现 TCC要求每个分支事务实现三个操作：预处理Try,确认Confirm,撤销Cancel。</p><ul><li>Try操作做业务检查及资源预留,</li><li>Confirm做业务确认操作</li><li>Cancel实现一个与Try相反的操作即回滚操作。</li></ul><p>TM首先发起所有的分支事务Try操作，任何一个分支事务的Try操作执行失败，TM将会发起所有分支事务的Cancel操作，若Try操作全部成功，TM将会发起所有分支事务的Confirm操作,其中Confirm/Cancel操作若执行失败,TM会进行重试。</p><p><img src="/images/seata/600833850791294a0e9c0783.png" alt="img"></p><blockquote><p>初步操作 Try</p></blockquote><ul><li>尝试执行业务</li><li>完成所有业务检查（一致性）；</li><li>预留必须业务资源（准隔离性）</li></ul><blockquote><p>确认操作 Confirm</p></blockquote><ul><li>确认执行业务</li><li>真正执行业务，不作任何业务检查</li><li>只使用Try阶段预留的业务资源</li><li>Confirm操作满足幂等性</li></ul><blockquote><p>取消操作 Cancel</p></blockquote><ul><li>取消执行业务；</li><li>释放Try阶段预留的业务资源</li><li>Cancel操作满足幂等性</li></ul><h4 id="异常处理" tabindex="-1"><a class="header-anchor" href="#异常处理" aria-hidden="true">#</a> 异常处理</h4><blockquote><p>幂等处理</p></blockquote><ol><li>因为网络抖动等原因，分布式事务框架可能会重复调用同一个分布式事务中的一个分支事务的二阶段接口。所以分支事务的二阶段接口Confirm/Cancel需要能够保证幂等性。如果二阶段接口不能保证幂等性，则会产生严重的问题，造成资源的重复使用或者重复释放，进而导致业务故障。</li><li>对于幂等类型的问题，通常的手段是<strong>引入幂等字段</strong>进行防重放攻击。对于分布式事务框架中的幂等问题，同样可以祭出这一利器。</li><li>幂等记录的插入时机是参与者的Try方法，此时的分支事务状态会被初始化为INIT。然后当二阶段的Confirm/Cancel执行时会将其状态置为CONFIRMED/ROLLBACKED。</li><li>当TC重复调用二阶段接口时，参与者会先获取事务状态控制表的对应记录查看其事务状态。如果状态已经为CONFIRMED/ROLLBACKED，那么表示参与者已经处理完其分内之事，不需要再次执行，可以直接返回幂等成功的结果给TC，帮助其推进分布式事务。</li></ol><blockquote><p>通过悲观锁与乐观锁保证数据的唯一性，确保幂等性</p></blockquote><h5 id="悲观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁" aria-hidden="true">#</a> 悲观锁</h5><p>悲观并发控制实际上是“<strong>先取锁再访问</strong>”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据</p><p>要使用悲观锁，必须关闭 MySQL 数据库的自动提交属性，比如使用 for update， select…for update 会把数据给锁住，不过需要注意一些锁的级别，<strong>MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住</strong></p><blockquote><p>传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 Java 里面的同步 synchronized 关键字的实现。悲观锁主要分为共享锁（读锁）和排他锁（写锁）</p></blockquote><h5 id="乐观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁" aria-hidden="true">#</a> 乐观锁</h5><p>CAS 加版本号version，先查询再更新根据版本。使用条件限制实现乐观锁</p><hr><h4 id="空回滚" tabindex="-1"><a class="header-anchor" href="#空回滚" aria-hidden="true">#</a> 空回滚</h4><ol><li>当没有调用参与方Try方法的情况下，就调用了二阶段的Cancel方法，Cancel方法需要有办法识别出此时Try有没有执行。如果Try还没执行，表示这个Cancel操作是无效的，即本次Cancel属于空回滚；如果Try已经执行，那么执行的是正常的回滚逻辑。</li><li>要应对空回滚的问题，就需要让参与者在二阶段的Cancel方法中有办法识别到一阶段的Try是否已经执行。很显然，可以继续利用<strong>事务状态控制表</strong>来实现这个功能。</li><li>当Try方法被成功执行后，会插入一条记录，标识该分支事务处于INIT状态。所以后续当二阶段的Cancel方法被调用时，可以通过查询控制表的对应记录进行判断。如果记录存在且状态为INIT，就表示一阶段已成功执行，可以正常执行回滚操作，释放预留的资源；如果记录不存在则表示一阶段未执行，本次为空回滚，不释放任何资源。</li></ol><h4 id="优点-2" tabindex="-1"><a class="header-anchor" href="#优点-2" aria-hidden="true">#</a> 优点</h4><ol><li><p>规避了数据库层的2PC性能低下问题</p></li><li><p>TCC实际上把数据库层的二阶段提交上提到了应用层来实现，对于数据库来说是一阶段提交</p></li></ol><h4 id="缺点-2" tabindex="-1"><a class="header-anchor" href="#缺点-2" aria-hidden="true">#</a> 缺点</h4><p>TCC的Try、Confirm和Cancel操作功能需业务提供，对业务的侵入强， 开发成本高</p><h3 id="可靠消息最终一致性❤️" tabindex="-1"><a class="header-anchor" href="#可靠消息最终一致性❤️" aria-hidden="true">#</a> 可靠消息最终一致性❤️</h3><p>可靠消息最终一致性方案是指当事务发起执行完全本地事务后并发出一条消息，事务参与方（消息消费者）一定能够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方最终事务要达到一致。</p><p><img src="/images/seata/6008394563768934926eefd0.png" alt="img"></p><blockquote><p>RocketMQ实现可靠消息一致性</p></blockquote><p>RocketMQ事务消息设计则主要是为了解决Producer端的消息发送与本地事务 执行的原子性问题，RocketMQ的设计中broker与producer端的双向通信能力， 使得broker天生可以作为一个事务协调者存在；而RocketMQ本身提供的存储机制 为事务消息提供了持久化能力；RocketMQ的高可用机制以及可靠消息设计则为事 务消息在系统发生异常时依然能够保证达成事务的最终一致性。 在RocketMQ 4.3后实现了完整的事务消息，实际上其实是对本地消息表的一 个封装，将本地消息表移动到了MQ内部，解决Producer端的消息发送与本地事务 执行的原子性问题。</p><p><img src="/images/seata/image-20230419233010436.png" alt="image-20230419233010436"></p><p>为方便理解我们以注册送优惠券的例子来描述整个流程。 Producer即MQ发送方，本例中是用户服务，负责新增用户。MQ订阅方即消息消 费方，本例中是优惠券服务，负责新增优惠券</p><ol><li><p>Producer发送事务消息</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Producer（MQ发送方）发送事务消息至MQ Server，MQ Server将消息状态标记为Prepared（预览状态），注意此时这条消息消费者（MQ订阅方）是无法消费到的。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>MQ Server回应消息发送成功</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>MQ Server接收到Producer发送给的消息则回应发送成功表示MQ已接收到消息\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>Producer执行本地事务</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Producer端执行业务代码逻辑，通过本地数据库事务控制。\n本例中，Producer执行添加用户操作。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><p>消息投递</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>若Producer本地事务执行成功则自动向MQ Server发送commit消息，MQ Server接收到commit消息后将“增加优惠券消息”状态标记为可消费，此时MQ订阅方\n（优惠券服务）即正常消费消息；\n\n若Producer 本地事务执行失败则自动向MQ Server发送rollback消息，MQServer接收到rollback消息后将删除“增加优惠券消息”。\n\nMQ订阅方（优惠券服务）消费消息，消费成功则向MQ回应ack，否则将重复接收消息。这里ack默认自动回应，即程序执行正常则自动回应ack。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li><li><p>事务回查</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>如果执行Producer端本地事务过程中，执行端挂掉，或者超时，MQ Server将会不停的询问同组的其他Producer来获取事务执行状态，这个过程叫事务回查。MQServer会根据事务回查结果来决定是否投递消息。\n\n以上主干流程已由RocketMQ实现，对用户则来说，用户需要分别实现本地事务执行以及本地事务回查方法，因此只需关注本地事务的执行状态即可。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ol><h3 id="saga" tabindex="-1"><a class="header-anchor" href="#saga" aria-hidden="true">#</a> saga</h3><p>Saga模型把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块。当Saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务最终的一致性. Saga 强调的是ACD, 缺乏隔离性.</p><p><img src="/images/seata/60083598e401fd261bd0a57c.png" alt="img"></p><h4 id="协调方式" tabindex="-1"><a class="header-anchor" href="#协调方式" aria-hidden="true">#</a> 协调方式</h4><ul><li><p>协同方式</p><ul><li>把Saga的决策和执行顺序顺序逻辑分布在每一个参与方中, 通过交换事件完成整个事务.</li><li>优点：简单/松耦合</li><li>缺点：不好理解/多了之后乱/会产生循环依赖关系/紧耦合风险等</li></ul></li><li><p>编排方式</p><ul><li>通过一个Saga编码器发送不同的命令驱动不同的Saga参与方, 指示他们完成各自的本地事务.</li><li>优点：依赖关系简单化/耦合少,彼此无感知,由编排器处理</li><li>缺点：编排器本身会变得复杂, 可能改一点东西考虑很多影响</li></ul></li></ul><h4 id="事务分级" tabindex="-1"><a class="header-anchor" href="#事务分级" aria-hidden="true">#</a> 事务分级</h4><ul><li>可补偿性事务 <ul><li>客户通过补偿进行回滚的事务</li></ul></li><li>关键性事务 <ul><li>核心事务, 未必带补偿或者可以重复执行, 但是一旦成功其他的可以失败. 例如其他的可以通过消息来重复处理, 或者索性就失败通过人工流程之后处理.</li></ul></li><li>可重复性事务 <ul><li>关键性之后的事务, 例如发送短信或者消息, 失败了可以重复执行</li></ul></li></ul><h4 id="隔离策略" tabindex="-1"><a class="header-anchor" href="#隔离策略" aria-hidden="true">#</a> 隔离策略</h4><ul><li>语义锁 <ul><li>这个就是程序级别的隔离, 例如审核状态变成审核中, 提交变成提交中来隔离, 但是一开始就设计好工作量很大</li></ul></li><li>重读值 <ul><li>事务开始前就保留一份数据, 处理过程中验证是否应修改</li></ul></li></ul><h4 id="缺乏隔离的问题" tabindex="-1"><a class="header-anchor" href="#缺乏隔离的问题" aria-hidden="true">#</a> 缺乏隔离的问题</h4><ul><li>脏读问题 <ul><li>一个事务未完成,另外一个已经读取了</li></ul></li><li>脏写问题 <ul><li>接上面: 第一个事务回滚了,第二个事务之后可能使用脏数据写库</li></ul></li></ul><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h4><ul><li>业务流程长、业务流程多</li><li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li></ul><h4 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h4><ul><li><p>优点</p><ul><li>一阶段提交本地事务，无锁，高性能</li><li>事件驱动架构，参与者可异步执行，高吞吐</li><li>补偿服务易于实现</li></ul></li><li><p>缺点</p><ul><li>不保证隔离性</li></ul></li></ul><h3 id="最大努力通知" tabindex="-1"><a class="header-anchor" href="#最大努力通知" aria-hidden="true">#</a> 最大努力通知</h3><p>最大努力通知型( Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果。典型的使用场景：如银行通知、商户通知等。</p><p>最大努力通知型的实现方案，一般符合以下特点：</p><ol><li>不可靠消息：业务活动主动方，在完成业务处理之后，向业务活动的被动方发送消息，直到通知N次后不再通知，允许消息丢失(不可靠消息)。</li><li>定期校对：业务活动的被动方，根据定时策略，向业务活动主动方查询(主动方提供查询接口)，恢复丢失的业务消息。</li></ol><p><img src="/images/seata/606b156f7d9c0829db6eaa05.png" alt="img"></p>',165),n={},s=(0,l(66262).A)(n,[["render",function(a,e){return i}]])},66262:(a,e)=>{e.A=(a,e)=>{const l=a.__vccOpts||a;for(const[a,i]of e)l[a]=i;return l}}}]);
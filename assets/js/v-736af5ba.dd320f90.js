"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[97309],{26751:(e,n,s)=>{s.r(n),s.d(n,{data:()=>a});const a={key:"v-736af5ba",path:"/netty/03%20Socket%E4%B8%8ENIO.html",title:"",lang:"zh-CN",frontmatter:{"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"网络通信",slug:"网络通信",children:[]},{level:2,title:"Socket与BIO",slug:"socket与bio",children:[]},{level:2,title:"NIO的多路复用",slug:"nio的多路复用",children:[]},{level:2,title:"IO复用模型",slug:"io复用模型",children:[{level:3,title:"epoll",slug:"epoll",children:[]}]},{level:2,title:"select、poll、epoll 的比较",slug:"select、poll、epoll-的比较",children:[{level:3,title:"epoll",slug:"epoll-1",children:[]}]},{level:2,title:"进程间六种通信方式",slug:"进程间六种通信方式",children:[]}],filePathRelative:"netty/03 Socket与NIO.md"}},8541:(e,n,s)=>{s.r(n),s.d(n,{default:()=>l});const a=(0,s(20641).Fv)('<h2 id="网络通信" tabindex="-1"><a class="header-anchor" href="#网络通信" aria-hidden="true">#</a> 网络通信</h2><p>连接（客户端连接服务器，服务器等待和接收连接），读网络数据，写网络数据</p><h2 id="socket与bio" tabindex="-1"><a class="header-anchor" href="#socket与bio" aria-hidden="true">#</a> Socket与BIO</h2><blockquote><p><strong>Socket是底层操作系统的门面模式，编程的socket是应用层面的。</strong></p></blockquote><p>服务器与客户端建立连接，（源IP,目标IP,协议号，源端口，目标端口）</p><p>BIO尽管可以结合线程池，但是遇到磁盘IO还是不太能够支持高并发的场景。</p><h2 id="nio的多路复用" tabindex="-1"><a class="header-anchor" href="#nio的多路复用" aria-hidden="true">#</a> NIO的多路复用</h2><blockquote><p>NIO是同步非阻塞的</p></blockquote><p>BIO面向流，阻塞</p><p><strong>NIO面向缓冲，非阻塞</strong></p><blockquote><p>NIO最主要的优点是Reactor模型，得益于底层linux的I/O复用模型的支持，而linux的I/O复用有三种：select，poll，epoll 都是 IO 多路复用的机制</p><p>I/O 多路复用就是通过一种机制，<strong>一个进 程可以监视多个描述符</strong>，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序 进行相应的读写操作</p></blockquote><p>注册感兴趣的事件---&gt;扫面发生的事件----&gt;通知注册中对应的人</p><p>多路复用：就是一个单线程处理了所有的连接</p><p><strong>NIO三大核心组件</strong>：Selector,Channel,Buffer</p><h2 id="io复用模型" tabindex="-1"><a class="header-anchor" href="#io复用模型" aria-hidden="true">#</a> IO复用模型</h2><p><img src="/images/netty/image-20220525153611042.png" alt="image-20220502133810657"></p><h3 id="epoll" tabindex="-1"><a class="header-anchor" href="#epoll" aria-hidden="true">#</a> epoll</h3><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span>； <span class="token comment">// 可以理解为对应于 JDK NIO 编程里的 selector = Selector.open()</span>\n<span class="token comment">// 可以理解为对应于 JDK NIO 编程里的 socketChannel.register();</span>\n<span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span>；\n<span class="token comment">// 可以理解为对应于 JDK NIO 编程里的 selector.select();</span>\n<span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="select、poll、epoll-的比较" tabindex="-1"><a class="header-anchor" href="#select、poll、epoll-的比较" aria-hidden="true">#</a> select、poll、epoll 的比较</h2><blockquote><p>select，poll，epoll 都是 操作系统实现 IO 多路复用的机制。</p></blockquote><p>支持一个进程所能打开的最大连接数</p><h3 id="epoll-1" tabindex="-1"><a class="header-anchor" href="#epoll-1" aria-hidden="true">#</a> epoll</h3><p>有一个实现了一个中间层eventpoll,里面有socket的链表，与进程的队列</p><h2 id="进程间六种通信方式" tabindex="-1"><a class="header-anchor" href="#进程间六种通信方式" aria-hidden="true">#</a> 进程间六种通信方式</h2><p>信号(kill -9)，管道，共享内存，消息队列，domain socket</p>',25),t={},l=(0,s(66262).A)(t,[["render",function(e,n){return a}]])},66262:(e,n)=>{n.A=(e,n)=>{const s=e.__vccOpts||e;for(const[e,a]of n)s[e]=a;return s}}}]);
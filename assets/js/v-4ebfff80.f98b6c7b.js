"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[75753],{87124:(n,s,a)=>{a.r(s),a.d(s,{data:()=>t});const t={key:"v-4ebfff80",path:"/rabbitmq/17%20%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B%E9%97%AE%E9%A2%98.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/rabbitmq/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"为什么会产生消息积压",slug:"为什么会产生消息积压",children:[]},{level:2,title:"解决方案",slug:"解决方案",children:[{level:3,title:"消息优先级",slug:"消息优先级",children:[]}]}],filePathRelative:"rabbitmq/17 消息积压问题.md"}},48300:(n,s,a)=>{a.r(s),a.d(s,{default:()=>g});var t=a(20641);const p=(0,t.Fv)('<h2 id="为什么会产生消息积压" tabindex="-1"><a class="header-anchor" href="#为什么会产生消息积压" aria-hidden="true">#</a> 为什么会产生消息积压</h2><ol><li>消费者宕机积压</li><li>消费者消费能力不足积压</li><li>发送者发流量太大</li></ol><p><img src="/images/RabbitMQ/image-20240325172118411.png" alt="image-20240325172118411"></p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h2><ol><li><strong>消费者处理消息的速度太慢</strong></li></ol><ul><li><ul><li><strong>增加消费者数量</strong>：通过水平扩展，增加消费者的数量来提高处理能力。</li><li><strong>优化消费者性能</strong>：提高消费者处理消息的效率，例如优化代码、增加资源。</li><li><strong>消息预取限制(prefetch count)</strong>：调整消费者的预取数量以避免一次处理过多消息而导致处理缓慢。</li></ul></li></ul><p>上线更多的消费者,进行正常消费<strong>上线专门</strong>的<strong>队列消费服务,将消息先批量取出来,记录数据库,再慢慢处理</strong></p><ol start="2"><li><strong>队列的容量太小</strong></li></ol><ul><li><ul><li><strong>增加队列的容量</strong>：调整队列设置以允许更多消息存储。</li></ul></li></ul><ol start="3"><li><strong>网络故障</strong></li></ol><ul><li><ul><li><strong>监控和告警</strong>：通过监控网络状况并设置告警，确保在网络故障时快速发现并解决问题。</li><li><strong>持久化和高可用性</strong>：确保消息和队列的持久化以避免消息丢失，并使用镜像队列提高可用性。</li></ul></li></ul><ol start="4"><li><strong>消费者故障</strong></li></ol><ul><li><ul><li><strong>使用死信队列</strong>：将无法处理的消息转移到死信队列，防止堵塞主队列。</li><li><strong>容错机制</strong>：实现消费者的自动重启和错误处理逻辑</li></ul></li></ul><ol start="5"><li><strong>消息大小</strong></li></ol><ul><li><ul><li><strong>消息分片</strong>：将大型消息分割成小的消息片段，加快处理速度。</li></ul></li></ul><ol start="6"><li><strong>业务逻辑复杂或耗时</strong></li></ol><ul><li><ul><li><strong>优化业务逻辑</strong>：简化消费者中的业务逻辑，减少处理每个消息所需的时间。</li></ul></li></ul><ol start="7"><li><strong>消息产生速度快于消费速度</strong></li></ol><ul><li><ul><li><strong>使用消息限流</strong>：控制消息的生产速度，确保它不会超过消费者的处理能力。</li><li><strong>负载均衡</strong>：确保消息在消费者之间公平分配，避免个别消费者过载(消息预取限制)。</li></ul></li></ul><ol start="8"><li><strong>其他配置优化</strong></li></ol><ul><li><ul><li><strong>消息优先级</strong>：使用消息优先级确保高优先级消息优先处理。</li><li><strong>调整RabbitMQ配置</strong>：优化RabbitMQ服务的配置，如文件描述符限制、内存使用限制等。</li></ul></li></ul><h3 id="消息优先级" tabindex="-1"><a class="header-anchor" href="#消息优先级" aria-hidden="true">#</a> 消息优先级</h3>',22),e={href:"https://blog.csdn.net/qq_51447496/article/details/132892276",target:"_blank",rel:"noopener noreferrer"},l=(0,t.Fv)('<p>RabbitMQ中的消息优先级是通过设置消息的优先级属性来实现的。在RabbitMQ中，每条消息都可以附带一个优先级属性，该属性的值在0到255之间，其中0表示最低优先级，255表示最高优先级。</p><p>要实现消息优先级，需要注意以下几点：</p><ol><li>配置队列：首先，需要在声明队列时设置<code>x-max-priority</code>参数来指定队列支持的最大优先级。例如，使用以下代码声明一个支持10个优先级的队列：</li></ol><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\narguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;x-max-priority&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nchannel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">&quot;my_queue&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>',4),o=(0,t.Lk)("code",null,"queueDeclare",-1),c=(0,t.Lk)("code",null,"my_queue",-1),u=(0,t.Lk)("code",null,"arguments",-1),i={href:"https://so.csdn.net/so/search?q=%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},r=(0,t.Lk)("code",null,"x-max-priority",-1),k=(0,t.Fv)('<ol start="2"><li>设置消息优先级：在发送消息时，可以通过设置消息的<code>priority</code>属性来指定消息的优先级。例如，使用以下代码发送一条优先级为5的消息：</li></ol><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">priority</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nchannel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;my_queue&quot;</span><span class="token punctuation">,</span> properties<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在上述代码中，我们使用<code>AMQP.BasicProperties.Builder</code>类创建一个消息属性对象，并通过<code>priority</code>方法设置了消息的优先级为5。然后，将该属性对象传递给<code>basicPublish</code>方法发送消息.</p><ol start="3"><li><p>消费消息：在消费消息时，需要确保消费者按照优先级顺序接收消息。为了实现这一点，可以在消费者端设置basicQos方法的prefetchCount参数为1，表示每次只接收一条消息。然后，在消费消息时，可以使用basicConsume方法的autoAck参数设置为false，表示手动确认消息。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nchannel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">&quot;my_queue&quot;</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span><span class="token class-name">String</span> consumerTag<span class="token punctuation">,</span> <span class="token class-name">Envelope</span> envelope<span class="token punctuation">,</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>\n        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Received message: &quot;</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 处理消息</span>\n\n        channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在上述代码中，我们通过basicQos方法设置了每次只接收一条消息，然后在handleDelivery方法中处理消息，并通过basicAck方法手动确认消息。</p><p>通过以上步骤，我们就可以实现RabbitMQ中的消息优先级。设置队列的最大优先级，发送消息时设置消息的优先级，消费消息时按照优先级顺序接收并处理消息。</p><p>需要注意的是，RabbitMQ中的消息优先级是相对的，即优先级高的消息会被优先处理，但并不能保证绝对的顺序。如果需要保证绝对的顺序，可以考虑使用单个队列或者使用多个队列并根据优先级将消息发送到不同的队列中。</p></li></ol>',4),b={},g=(0,a(66262).A)(b,[["render",function(n,s){const a=(0,t.g2)("OutboundLink");return(0,t.uX)(),(0,t.CE)(t.FK,null,[p,(0,t.Lk)("p",null,[(0,t.Lk)("a",e,[(0,t.eW)("RabbitMQ优先级实现"),(0,t.bF)(a)])]),l,(0,t.Lk)("p",null,[(0,t.eW)("在上述代码中，我们使用"),o,(0,t.eW)("方法声明了一个名为"),c,(0,t.eW)("的队列，并通过"),u,(0,t.Lk)("a",i,[(0,t.eW)("参数设置"),(0,t.bF)(a)]),(0,t.eW)("了队列的属性。其中，"),r,(0,t.eW)("参数指定了队列支持的最大优先级为10。")]),k],64)}]])},66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,t]of s)a[n]=t;return a}}}]);
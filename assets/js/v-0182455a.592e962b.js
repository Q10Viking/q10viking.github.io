"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[40820],{80420:(a,n,e)=>{e.r(n),e.d(n,{data:()=>t});const t={key:"v-0182455a",path:"/maven/01%20maven.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/maven/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"Maven项目管理工具",slug:"maven项目管理工具",children:[]},{level:2,title:"mvn命令",slug:"mvn命令",children:[]},{level:2,title:"依赖范围scope",slug:"依赖范围scope",children:[]},{level:2,title:"optional可选依赖",slug:"optional可选依赖",children:[]},{level:2,title:"<relativePath/>",slug:"relativepath",children:[]},{level:2,title:"dependencyManagement版本依赖管理",slug:"dependencymanagement版本依赖管理",children:[]},{level:2,title:"pom.xml文件详解",slug:"pom-xml文件详解",children:[]}],filePathRelative:"maven/01 maven.md"}},70945:(a,n,e)=>{e.r(n),e.d(n,{default:()=>g});var t=e(20641);const s=(0,t.Fv)('<h2 id="maven项目管理工具" tabindex="-1"><a class="header-anchor" href="#maven项目管理工具" aria-hidden="true">#</a> Maven项目管理工具</h2><p><strong>maven</strong> 是一个<strong>项目管理工具</strong>，主要作用是在项目开发阶段对Java项目进行<strong>依赖管理</strong>和<strong>项目构建</strong></p><p><strong>依赖管理</strong>：就是对jar包的管理。通过导入maven坐标，就相当于将仓库中的jar包导入了当前项目中。</p><p><strong>项目构建</strong>：通过maven的一个命令就可以完成项目从清理、编译、测试、报告、打包，部署整个过程</p><img src="/images/maven/image-20201230110306512.png" alt="image-20201230110306512" style="zoom:67%;"><h2 id="mvn命令" tabindex="-1"><a class="header-anchor" href="#mvn命令" aria-hidden="true">#</a> mvn命令</h2><ul><li>mvn install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库</li><li>mvn deploy命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库</li><li><code>mvn package -Dmaven.test.skip=true</code>跳过测试</li><li><code>mvn spring-boot:run -Ph2</code>激活指定的profile</li></ul><h2 id="依赖范围scope" tabindex="-1"><a class="header-anchor" href="#依赖范围scope" aria-hidden="true">#</a> 依赖范围scope</h2><p><img src="/images/maven/image-20230517201733989.png" alt="image-20230517201733989"></p><ul><li>compile 默认scope</li></ul><h2 id="optional可选依赖" tabindex="-1"><a class="header-anchor" href="#optional可选依赖" aria-hidden="true">#</a> optional可选依赖</h2><blockquote><p>在Springboot中自动配置大量使用到了</p></blockquote>',12),l={href:"https://blog.csdn.net/lovejj1994/article/details/80283240",target:"_blank",rel:"noopener noreferrer"},p=(0,t.Fv)('<ul><li>A引入依赖B，B里面又引入依赖C，如果在B中设置依赖C为optional 为true,那么A不会看到C</li><li>如果A与B是父子关系，如B是父工程，A继承了这个工程，那么无论B中引入的依赖C，那么不管C是否设置为optional，A都能看到C</li></ul><h2 id="relativepath" tabindex="-1"><a class="header-anchor" href="#relativepath" aria-hidden="true">#</a> <code>&lt;relativePath/&gt;</code></h2><ul><li>查找顺序：relativePath元素中的地址–本地仓库–远程仓库</li><li>设定一个空值将始终从仓库中获取，不从本地路径获取</li></ul><div class="language-xml ext-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.7.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/&gt;</span></span> <span class="token comment">&lt;!-- lookup parent from repository --&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="dependencymanagement版本依赖管理" tabindex="-1"><a class="header-anchor" href="#dependencymanagement版本依赖管理" aria-hidden="true">#</a> dependencyManagement版本依赖管理</h2>',5),o={href:"https://developer.aliyun.com/article/1204369",target:"_blank",rel:"noopener noreferrer"},r=(0,t.Lk)("p",null,"为了规范一个复杂项目中所有子模块的依赖版本，防止出现两个子模块a，b引用同一个依赖，但是一个的版本是1.0，一个的版本是2.0的这种情况。",-1),i=(0,t.Lk)("p",null,[(0,t.eW)("比如子模块a和b，都引入了x，y，z三个依赖，这三个依赖的版本都要求是相同的的才能匹配上，此时子模块a引入的是1.0的版本，子模块b引入的是2.0的版本，那么最后可能会出现版本不相同导致匹配不上的问题。所以都在父工程的"),(0,t.Lk)("code",null,"<dependencyManagement>"),(0,t.eW)("进行依赖版本管理")],-1),c=(0,t.Lk)("h2",{id:"pom-xml文件详解",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#pom-xml文件详解","aria-hidden":"true"},"#"),(0,t.eW)(" pom.xml文件详解")],-1),u={href:"https://developer.aliyun.com/article/813478",target:"_blank",rel:"noopener noreferrer"},d={},g=(0,e(66262).A)(d,[["render",function(a,n){const e=(0,t.g2)("OutboundLink");return(0,t.uX)(),(0,t.CE)(t.FK,null,[s,(0,t.Lk)("p",null,[(0,t.Lk)("a",l,[(0,t.eW)("Maven实战-maven中的可选依赖"),(0,t.bF)(e)])]),p,(0,t.Lk)("p",null,[(0,t.Lk)("a",o,[(0,t.eW)("从根上理解Maven拉包原理，搞定Maven全功能 下-阿里云开发者社区 (aliyun.com)"),(0,t.bF)(e)])]),r,i,c,(0,t.Lk)("p",null,[(0,t.Lk)("a",u,[(0,t.eW)("Maven: settings.xml、pom.xml完整配置-阿里云开发者社区 (aliyun.com)"),(0,t.bF)(e)])])],64)}]])},66262:(a,n)=>{n.A=(a,n)=>{const e=a.__vccOpts||a;for(const[a,t]of n)e[a]=t;return e}}}]);
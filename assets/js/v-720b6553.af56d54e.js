"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[13562],{75794:(e,t,i)=>{i.r(t),i.d(t,{data:()=>l});const l={key:"v-720b6553",path:"/Redis/40%20%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/Redis/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"缓存雪崩",slug:"缓存雪崩",children:[]}],filePathRelative:"Redis/40 缓存雪崩.md"}},36372:(e,t,i)=>{i.r(t),i.d(t,{default:()=>p});const l=(0,i(20641).Fv)('<h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩" aria-hidden="true">#</a> <strong>缓存雪崩</strong></h2><p>缓存雪崩指的是缓存层支撑不住或宕掉后， 流量会像奔逃的野牛一样， 打向后端存储层。</p><p>由于缓存层承载着大量请求， 有效地保护了存储层， 但是如果❤️缓存层由于某些原因不能提供服务❤️(比如超大并发过来，缓存层支撑不住，或者由于缓存设计不好，类似大量请求访问bigkey，导致缓存能支撑的并发急剧下降)， 于是大量请求都会打到存储层， 存储层的调用量会暴增， 造成存储层也会级联宕机的情况。 （导致服务雪崩）</p><p>预防和解决缓存雪崩问题， 可以从以下三个方面进行着手。</p><ol><li><p>保证缓存层服务高可用性，比如使用Redis Sentinel或Redis Cluster。</p></li><li><p>多级缓存：使用多级缓存架构，如本地缓存 + 分布式缓存，提高系统的容错能力。</p></li><li><p>依赖隔离组件为❤️后端限流熔断并降级❤️。比如使用Sentinel或Hystrix限流降级组件。</p><blockquote><p>比如服务降级，我们可以针对不同的数据采取不同的处理方式。当业务应用访问的是非核心数据（例如电商商品属性，用户信息等）时，暂时停止从缓存中查询这些数据，而是直接返回预定义的默认降级信息、空值或是错误提示信息；当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。</p></blockquote></li><li><p>提前演练。 在项目上线前， 演练缓存层宕掉后， 应用以及后端的负载情况以及可能出现的问题， 在此基础上做一些预案设定。</p></li></ol>',5),r={},p=(0,i(66262).A)(r,[["render",function(e,t){return l}]])},66262:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,l]of t)i[e]=l;return i}}}]);
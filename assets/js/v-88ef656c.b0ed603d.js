"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[9975],{32002:(e,a,s)=>{s.r(a),s.d(a,{data:()=>n});const n={key:"v-88ef656c",path:"/MySQL/03%20%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/MySQL/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"索引数据结构",slug:"索引数据结构",children:[]},{level:2,title:"二叉树",slug:"二叉树",children:[{level:3,title:"缺点",slug:"缺点",children:[]}]},{level:2,title:"红黑树",slug:"红黑树",children:[{level:3,title:"缺点",slug:"缺点-1",children:[]}]},{level:2,title:"B-Tree",slug:"b-tree",children:[{level:3,title:"特点",slug:"特点",children:[]}]},{level:2,title:"B+Tree(B-Tree的变种)",slug:"b-tree-b-tree的变种",children:[{level:3,title:"Mysql为什么选择B+Tree而不是B-Tree❤️",slug:"mysql为什么选择b-tree而不是b-tree❤️",children:[]}]},{level:2,title:"Hash",slug:"hash",children:[{level:3,title:"优点",slug:"优点",children:[]},{level:3,title:"缺点",slug:"缺点-2",children:[]}]},{level:2,title:"MySQL中支持的索引",slug:"mysql中支持的索引",children:[]}],filePathRelative:"MySQL/03 索引数据结构.md"}},70777:(e,a,s)=>{s.r(a),s.d(a,{default:()=>r});const n=(0,s(20641).Fv)('<h2 id="索引数据结构" tabindex="-1"><a class="header-anchor" href="#索引数据结构" aria-hidden="true">#</a> 索引数据结构</h2><blockquote><p>索引的出现其实就是为了提高数据查询的效率</p></blockquote><p><strong>索引是帮助MySQL高效获取数据的排好序的数据结构</strong>，作用，减少在磁盘上的查询次数</p><p>索引比喻就像目录页</p><ul><li>二叉树</li><li>红黑树</li><li>Hash表</li><li>B-Tree</li></ul><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">-- 如果没有索引就会一行一行的去寻找</span>\n<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> t<span class="token punctuation">.</span>col2 <span class="token operator">=</span> <span class="token number">89</span><span class="token punctuation">;</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>数据表都是存储在磁盘上的，磁盘IO读取，一行行的查找，效率比较低。所以<strong>引入索引，来控制磁盘IO查找的次数</strong>。</p><h2 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h2><p>对于单边增长的数据，没有效果</p><p>为Col2建立索引，二叉树的key为Col2的值，value则为数据行所在的地址</p><p>这样再次查询Col2 = 89时，只需要查询两次，就可以找到该数据行</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> t<span class="token punctuation">.</span>col2 <span class="token operator">=</span> <span class="token number">89</span><span class="token punctuation">;</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><img src="/images/MySQL/image-20210519183353632.png" alt="image-20210519183353632"></p><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><p>如果数据都是<strong>单边递增或者单向递减</strong>，使用二叉树建立的索引，会导致数据的深度变得非常深</p><p><img src="/images/MySQL/image-20211026164251738.png" alt="image-20211026164251738"></p><p>这样如果查询Col1 = 6,那么在查询效率上并没得到提升。还是需要遍历6次</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> t<span class="token punctuation">.</span>col1 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树" aria-hidden="true">#</a> 红黑树</h2><p><strong>二叉平衡树</strong>，会<strong>改变单边增长的效果</strong>，</p><p><img src="/images/MySQL/image-20211026164550332.png" alt="image-20211026164550332"></p><p>这样再次查找Col1 = 6的数据，则只会查找3次就可以找到了</p><h3 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a> 缺点</h3><p>随着<strong>数据量的增长,（如，几十万，几百万的数量），树的高度会增加</strong>，查询速度也会变得缓慢。可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间</p><p>如果一条数据在整个数的叶子节点，而高度为20，那么就需要20次的磁盘IO查找，才能找到该数据。</p><p>关键：<strong>磁盘查找的次数与树的高度有关。</strong></p><h2 id="b-tree" tabindex="-1"><a class="header-anchor" href="#b-tree" aria-hidden="true">#</a> B-Tree</h2><p><strong>数据页节点的引入，在横向放置更多的数据，来控制了树的高度</strong></p><p>默认页节点的大小，可以通过该sql进行查询</p><div class="language-mysql ext-mysql line-numbers-mode"><pre class="language-mysql"><code># 页的大小sql\nmysql&gt; show global status like &#39;innodb_page_size&#39;;\n+------------------+-------+\n| Variable_name    | Value |\n+------------------+-------+\n| Innodb_page_size | 16384 |\n+------------------+-------+\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>可以看到一个页的大小为16kb。如为bigint类型的字段建立索引，bigint为8B,地址分配的空间为6B</p><p><img src="/images/MySQL/image-20211026171434814.png" alt="image-20211026171434814"></p><p>16KB/（8B+6B）约等于1170，也就是说可以存储1170个索引</p><p><img src="/images/MySQL/image-20211026172506634.png" alt="image-20211026172506634"></p><p>而叶子节点包含data数据大概1KB，加起来是1kB,大概可以存储16个索引，所以可以存储的索引数据为1170x1170x16 = 21,902,400 ,大概两千万的索引，即两千万的数据量，而查找一条数据，只需要3次磁盘IO就可以了，因为深度h=3得到了控制。</p><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h3><ol><li>叶节点具有相同的深度，叶节点的指针为空</li><li>所有索引元素不重复</li><li><strong>节点中的数据索引从左到右递增排列</strong></li></ol><blockquote><p>排好序的左节点小于右节点</p></blockquote><p><img src="/images/MySQL/image-20210519184218251.png" alt="image-20210519184218251"></p><p><strong>data为数据所在磁盘上的地址</strong></p><h2 id="b-tree-b-tree的变种" tabindex="-1"><a class="header-anchor" href="#b-tree-b-tree的变种" aria-hidden="true">#</a> B+Tree(B-Tree的变种)</h2><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>树的高度由每页存储索引的数量有关,由于B-Tree非叶子节点会存储数据，每页存储的索引数量就会变少，树的高度就会相对增加，而B+Tree解决了这个问题</p></div><ol><li>非叶子节点<strong>不存储data,只存储索引</strong>（冗余），<strong>可以放更多的索引</strong><ol><li>data为数据在磁盘的地址</li><li>非叶子节点为冗余索引，取一些中间的索引</li></ol></li><li><strong>叶子节点包含所有索引字段</strong></li><li>叶子节点<strong>用指针连接</strong>，提高<strong>区间访问</strong>的性能（在范围查询时，非常方便） <ol><li>如Col&gt;20,那么在找到20后，就可以根据指针，快速进行查找</li></ol></li></ol><p><img src="/images/MySQL/image-20210519182100028.png" alt="image-20210519182100028"></p><p>如查找col=30，那么先从根节点尽心查找，先将根节点加入内存（<strong>常驻内存</strong>），如通过二分查找算法，快速找到，数据页所在的磁盘地址，如在15和56之间，然后加载第二个数据页，在第一个数据页中继续查找，发现数据页的地址在20-49之间，然后再加载内存，20-30的数据页，找到30，根据data的指针，加载磁盘上的数据。</p><h3 id="mysql为什么选择b-tree而不是b-tree❤️" tabindex="-1"><a class="header-anchor" href="#mysql为什么选择b-tree而不是b-tree❤️" aria-hidden="true">#</a> Mysql为什么选择B+Tree而不是B-Tree❤️</h3><ol><li><p>同样存储两千万的数据量，由于B-Tree每个页都带有data,导致存储的索引数量变少（16KB/1KB=16个）。导致了树的深度变高。树的深度变高，导致磁盘查找的次数变多，16KB的n次方=两千万。n远远大于B+Tree的3层。</p></li><li><p>而且在范围查找时，由于叶子节点之间没有建立指针关联，导致B-Tree相比之下会比较慢</p></li></ol><h2 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> Hash</h2><p>Mysql中使用的索引除了B+Tree索引外，还有Hash索引，在navicat中看到</p><p><img src="/images/MySQL/image-20211026185526369.png" alt="image-20211026185526369"></p><p>使用hash索引来存储（为name建立hash索引）</p><p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p><p>不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p><p><img src="/images/MySQL/image-20210520095911155.png" alt="image-20210520095911155"></p><blockquote><p>举例：假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p></blockquote><p><img src="/images/MySQL/image-20230509161248838.png" alt="image-20230509161248838"></p><ul><li>User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2</li><li>如果你现在要找身份证号在 [ID_card_X, ID_card_Y] 这个区间的所有用户，就必须全部扫描一遍了</li></ul><blockquote><p>如果你现在要找身份证号在 [ID_card_X, ID_card_Y] 这个区间的所有用户，就必须全部扫描一遍了</p></blockquote><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><ol><li>对索引的key进行一次hash计算就可以定位出数据存储的位置</li><li><strong>很多时候Hash索引要比B+Tree效率高</strong></li></ol><h3 id="缺点-2" tabindex="-1"><a class="header-anchor" href="#缺点-2" aria-hidden="true">#</a> 缺点</h3><ol><li><strong>仅能满足“=”，“IN”,不支持范围查询</strong></li><li><strong>存在hash冲突</strong></li></ol><h2 id="mysql中支持的索引" tabindex="-1"><a class="header-anchor" href="#mysql中支持的索引" aria-hidden="true">#</a> MySQL中支持的索引</h2><p><img src="/images/MySQL/image-202110261855263691.png" alt="image-20211026185526369"></p><ol><li>B+Tree索引 （工作中大多数情况都是用）</li><li>Hash索引 <strong>存在缺点</strong></li></ol><p>如果用不到索引，或者索引失效，那么就会进行磁盘的遍历操作</p>',66),l={},r=(0,s(66262).A)(l,[["render",function(e,a){return n}]])},66262:(e,a)=>{a.A=(e,a)=>{const s=e.__vccOpts||e;for(const[e,n]of a)s[e]=n;return s}}}]);
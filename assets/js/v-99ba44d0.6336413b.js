"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[8621],{82214:(e,l,t)=>{t.r(l),t.d(l,{data:()=>r});const r={key:"v-99ba44d0",path:"/ddd/03%20%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/ddd/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"领域模型",slug:"领域模型",children:[]},{level:2,title:"贫血模型",slug:"贫血模型",children:[]},{level:2,title:"充血模型",slug:"充血模型",children:[]},{level:2,title:"参考",slug:"参考",children:[]}],filePathRelative:"ddd/03 贫血模型与充血模型.md"}},82112:(e,l,t)=>{t.r(l),t.d(l,{default:()=>b});var r=t(20641);const a=(0,r.Fv)('<h2 id="领域模型" tabindex="-1"><a class="header-anchor" href="#领域模型" aria-hidden="true">#</a> 领域模型</h2><ul><li><p>领域模型（domain model）</p><ul><li><p>贫血模型（anaemic domain model）,业界又称为反模式(anti-pattern),它与面向对象（OOP）的思想完全背道而驰。充分使用OOP思想来编程能够避免贫血模型</p></li><li><p>充血模型（rich domain model）</p></li></ul></li></ul><blockquote><p><strong>Simply put, rich objects conceal their underlying data and only expose a set of public methods to interact with it. In contrast, anemic objects and data structures reveal their data and rely on external components for operations.</strong></p></blockquote><hr><h2 id="贫血模型" tabindex="-1"><a class="header-anchor" href="#贫血模型" aria-hidden="true">#</a> 贫血模型</h2>',5),i={class:"custom-container tip"},n=(0,r.Lk)("p",{class:"custom-container-title"},"TIP",-1),o=(0,r.Lk)("p",null,"Q: DTO – a Data Transfer Object – is not an object?",-1),d=(0,r.Lk)("p",null,"A: Correct. DTOs are data structures",-1),c={href:"https://blog.cleancoder.com/uncle-bob/2019/06/16/ObjectsAndDataStructures.html",target:"_blank",rel:"noopener noreferrer"},s=(0,r.Lk)("p",null,"我的理解贫血模型更像是数据结构。",-1),u=(0,r.Fv)('<p>贫血模型最早广泛应用源于EJB2，最强盛时期则是由Spring创造，将：</p><ul><li>“行为”（逻辑、过程）；</li><li>“状态”（数据，对应到语言就是对象成员变量）。</li></ul><p>分离到不同的对象中：</p><ul><li>只有状态的对象就是所谓的“贫血对象”（常称为VO——Value Object）；</li><li>只有行为的对象就是，我们常见的N层结构中的Logic/Service/Manager层</li></ul><blockquote><p><strong>贫血领域模型是一个存在已久的反模式</strong></p></blockquote><p><img src="/images/ddd/1200" alt="img"></p><p>贫血领域模型的基本特征是：它第一眼看起来还真像这么回事儿。项目中有许多对象，它们的命名都是根据领域来的。对象之间有着丰富的连接方式，和真正的领域模型非常相似。但当你检视这些对象的行为时，会发现它们基本上没有任何行为，仅仅是一堆getter/setter。</p><p>其实，这些对象在设计之初就被定义为只能包含数据，不能加入领域逻辑；逻辑要全部写入一组叫Service的对象中；而Service则构建在领域模型之上，需要使用这些模型来传递数据。</p><blockquote><p>曾经Spring的作者Rod Johnson也承认，Spring不过是在沿袭EJB2时代的“事务脚本”，也就是面向过程编程</p></blockquote><h2 id="充血模型" tabindex="-1"><a class="header-anchor" href="#充血模型" aria-hidden="true">#</a> 充血模型</h2><p>面向对象设计的本质是：“一个对象是拥有状态和行为的”。</p><p>比如一个人：</p><ul><li>他眼睛什么样鼻子什么样这就是状态；</li><li>人可以去打游戏或是写程序，这就是行为。</li></ul><p>为什么要有一个“人Manager”这样的东西存在去帮人“打游戏”呢？举个简单的J2EE案例，设计一个与用户（User）相关功能。</p><p>传统的设计一般是：</p><ul><li>类：<code>User</code>+<code>UserService</code>；</li><li>保存用户调用：<code>userService.save(User user)</code>。</li></ul><p>充血的设计则可能会是：</p><ul><li>类：<code>User</code>；</li><li>保存用户调用：<code>user.save()</code>；</li><li>User有一个行为是：保存它自己。</li></ul><p>其实它们没有什么特别适用的方向，个人更倾向于总是使用充血模型，因为OOP总是比面向过程编程要有更丰富的语义、更合理的组织、更强的可维护性—当然也更难掌握。</p><p>因此实际工程场景中，是否使用，如何使用还依赖于设计者以及团队充血模型设计的理解和把握，因为现在绝大多数J2EE开发者都受贫血模型影响非常深。另外，实际工程场景中使用充血模型，还会碰到很多很多细节问题，其中最大的难关就是“如何设计充血模型”或者说“如何从复杂的业务中分离出恰到好处且包含语义的逻辑放到VO的行为中”。</p><p>如果一个对象包含其他对象，那就将职责继续委托下去，由具体的 POJO 执行业务逻辑，将策略模式更加细粒度，而不是写 ifelse。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',22),p={href:"https://www.baeldung.com/java-modules-ddd-bounded-contexts",target:"_blank",rel:"noopener noreferrer"},h={},b=(0,t(66262).A)(h,[["render",function(e,l){const t=(0,r.g2)("OutboundLink");return(0,r.uX)(),(0,r.CE)(r.FK,null,[a,(0,r.Lk)("div",i,[n,o,d,(0,r.Lk)("p",null,[(0,r.eW)("--- from "),(0,r.Lk)("a",c,[(0,r.eW)("Clean Coder Blog"),(0,r.bF)(t)])]),s]),u,(0,r.Lk)("p",null,[(0,r.Lk)("a",p,[(0,r.eW)("DDD Bounded Contexts and Java Modules | Baeldung"),(0,r.bF)(t)])])],64)}]])},66262:(e,l)=>{l.A=(e,l)=>{const t=e.__vccOpts||e;for(const[e,r]of l)t[e]=r;return t}}}]);
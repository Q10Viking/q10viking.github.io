"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[16458],{86460:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-07339156",path:"/JVM/10%20%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/JVM/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"如何判断对象可以被回收",slug:"如何判断对象可以被回收",children:[]},{level:2,title:"对象内存回收",slug:"对象内存回收",children:[]},{level:2,title:"引用计数法",slug:"引用计数法",children:[]},{level:2,title:"可达性分析算法",slug:"可达性分析算法",children:[]},{level:2,title:"常见引用类型",slug:"常见引用类型",children:[]},{level:2,title:"finalize()方法最终判定对象是否存活",slug:"finalize-方法最终判定对象是否存活",children:[]}],filePathRelative:"JVM/10 对象内存回收.md"}},19915:(n,s,a)=>{a.r(s),a.d(s,{default:()=>l});var p=a(20641);const t=(0,p.Fv)('<h2 id="如何判断对象可以被回收" tabindex="-1"><a class="header-anchor" href="#如何判断对象可以被回收" aria-hidden="true">#</a> 如何判断对象可以被回收</h2><p>在Java中，对象是否可以被回收通常由垃圾回收器决定。垃圾回收器使用一种称为&quot;<strong>可达性分析</strong>&quot;的算法来确定对象是否可被回收。可达性分析是指如果一个对象无法从任何<strong>GC Roots</strong>直接或间接访问到，它就被认为是不可达的，可以被垃圾回收。</p><p>GC Roots是一组特殊的引用，它们被认为是程序中可访问对象的<strong>起始点</strong>，即从这些引用开始，可以追踪到所有仍然被程序引用的对象。</p><p>GC Roots通常包括以下几种类型的引用：</p><ol><li><strong>局部变量引用</strong>：在方法中定义的局部变量，包括方法的参数和局部变量，通常被视为GC Roots。这些变量的引用指向了对象的实例。</li><li><strong>活动线程引用</strong>：正在运行的线程的引用通常被视为GC Roots。线程本地存储中的对象也是如此。</li><li><strong>静态变量引用</strong>：静态变量是类的一部分，它们的引用也被视为GC Roots。静态变量存在于类加载器的内存中。</li><li><strong>JNI 引用</strong>：通过Java Native Interface（JNI）创建的本地代码引用也可以被视为GC Roots。这些引用连接了Java堆内存和本地代码的内存。</li><li><strong>虚拟机引导类加载器</strong>：虚拟机内部使用的类加载器引用也是GC Roots。它们通常是一些核心类或库</li></ol><h2 id="对象内存回收" tabindex="-1"><a class="header-anchor" href="#对象内存回收" aria-hidden="true">#</a> 对象内存回收</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是<strong>要判断哪些对象已经死亡</strong>（即不能再被任何途径使用的对象）</p><h2 id="引用计数法" tabindex="-1"><a class="header-anchor" href="#引用计数法" aria-hidden="true">#</a> 引用计数法</h2><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p><p>除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGc</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Object</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">ReferenceCountingGc</span> objA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">ReferenceCountingGc</span> objB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      objA<span class="token punctuation">.</span>instance <span class="token operator">=</span> objB<span class="token punctuation">;</span>\n      objB<span class="token punctuation">.</span>instance <span class="token operator">=</span> objA<span class="token punctuation">;</span>\n      objA <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n      objB <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><hr><h2 id="可达性分析算法" tabindex="-1"><a class="header-anchor" href="#可达性分析算法" aria-hidden="true">#</a> <strong>可达性分析算法</strong></h2><p>将**“GC Roots”** 对象作为起点， 从这些节点开始向下搜索引用的对象，找到的对象都标记为<strong>非垃圾对象</strong>，其余未标记的对象都是垃圾对象</p><p><strong>GC Roots</strong>根节点：线程栈的本地变量、静态变量、本地方法栈的变量，常量等等</p><p><img src="/images/jvm/66962.png" alt="img"></p><h2 id="常见引用类型" tabindex="-1"><a class="header-anchor" href="#常见引用类型" aria-hidden="true">#</a> <strong>常见引用类型</strong></h2><p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用</p>',19),e={href:"https://q10viking.github.io/JVM/11%20%E5%BC%95%E7%94%A8.html#%E5%BC%BA%E5%BC%95%E7%94%A8",target:"_blank",rel:"noopener noreferrer"},o=(0,p.Fv)('<p><strong>强引用</strong>：普通的变量引用</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>软引用</strong>：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，<strong>但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉</strong>。<strong>软引用可用来实现内存敏感的高速缓存。</strong></p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p><p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p><p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出</p><p><strong>弱引用</strong>：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>GC会直接回收掉</strong>，很少用</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>**虚引用：**虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</p><h2 id="finalize-方法最终判定对象是否存活" tabindex="-1"><a class="header-anchor" href="#finalize-方法最终判定对象是否存活" aria-hidden="true">#</a> finalize()方法最终判定对象是否存活</h2><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p><p><strong>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</strong></p><p><strong>1. 第一次标记并进行一次筛选。</strong></p><p>筛选的条件是此对象是否有必要执行finalize()方法。</p><p>当对象没有覆盖finalize方法，对象将直接被回收。</p><p><strong>2. 第二次标记</strong></p><p>如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</p><p>注意：<strong>一个对象的finalize()方法只会被执行一次</strong>，也就是说通过调用finalize方法自我救命的机会就一次。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OOMTest</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>j<span class="token operator">--</span><span class="token punctuation">,</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">//User类需要重写finalize方法</span>\n<span class="token annotation punctuation">@Override</span>\n<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n    <span class="token class-name">OOMTest</span><span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;关闭资源，userid=&quot;</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">&quot;即将被回收&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div>',20),c={},l=(0,a(66262).A)(c,[["render",function(n,s){const a=(0,p.g2)("OutboundLink");return(0,p.uX)(),(0,p.CE)(p.FK,null,[t,(0,p.Lk)("p",null,[(0,p.Lk)("a",e,[(0,p.eW)("Q10Viking - 引用"),(0,p.bF)(a)])]),o],64)}]])},66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,p]of s)a[n]=p;return a}}}]);
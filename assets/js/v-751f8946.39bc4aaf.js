"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[58370],{10304:(i,e,n)=>{n.r(e),n.d(e,{data:()=>s});const s={key:"v-751f8946",path:"/spring/13%20Spring%E6%95%B4%E5%90%88Mybatis.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/spring/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"流程分析",slug:"流程分析",children:[]},{level:2,title:"Spring整合Mybatis后一级缓存失效问题",slug:"spring整合mybatis后一级缓存失效问题",children:[]}],filePathRelative:"spring/13 Spring整合Mybatis.md"}},73862:(i,e,n)=>{n.r(e),n.d(e,{default:()=>l});var s=n(20641);const r=(0,s.Fv)('<div class="custom-container tip"><p class="custom-container-title">TIP</p><p>由很多框架都需要和Spring进行整合，而整合的核心思想就是把其他框架所产生的对象放到Spring容 器中，让其成为Bean。 比如Mybatis，Mybatis框架可以单独使用，而单独使用Mybatis框架就需要用到Mybatis所提供的一 些类构造出对应的对象，然后使用该对象，就能使用到Mybatis框架给我们提供的功能，和Mybatis 整合Spring就是为了将这些对象放入Spring容器中成为Bean，只要成为了Bean，在我们的Spring项 目中就能很方便的使用这些对象了，也就能很方便的使用Mybatis框架所提供的功能了。</p></div><h2 id="流程分析" tabindex="-1"><a class="header-anchor" href="#流程分析" aria-hidden="true">#</a> 流程分析</h2><ol><li>通过@MapperScan导入了MapperScannerRegistrar类</li><li>MapperScannerRegistrar类实现了ImportBeanDefinitionRegistrar接口，所以Spring在启动时会调用MapperScannerRegistrar类中的registerBeanDefinitions方法</li><li><strong>在registerBeanDefinitions方法中注册一个MapperScannerConfigurer类型的BeanDefinition</strong></li><li>而MapperScannerConfigurer实现了BeanDefinitionRegistryPostProcessor接口，所以Spring在启动过程中时会调用它的postProcessBeanDefinitionRegistry()方法</li><li>在postProcessBeanDefinitionRegistry方法中会生成一个ClassPathMapperScanner对象，然后进行扫描</li><li>通过利用Spring的扫描后，会把接口扫描出来并且得到对应的BeanDefinition</li><li>接下来把扫描得到的BeanDefinition进行修改，把BeanClass修改为MapperFactoryBean，把AutowireMode修改为byType</li><li>扫描完成后，Spring就会基于BeanDefinition去创建Bean了，相当于每个Mapper对应一个FactoryBean</li><li>在MapperFactoryBean中的getObject方法中，调用了getSqlSession()去得到一个sqlSession对象，然后根据对应的Mapper接口生成一个Mapper接口代理对象，这个代理对象就成为Spring容器中的Bean</li><li>sqlSession对象是Mybatis中的，一个sqlSession对象需要SqlSessionFactory来产生</li><li>MapperFactoryBean的AutowireMode为byType，所以Spring会自动调用set方法，有两个set方法，一个setSqlSessionFactory，一个setSqlSessionTemplate，而这两个方法执行的前提是根据方法参数类型能找到对应的bean，所以Spring容器中要存在SqlSessionFactory类型的bean或者SqlSessionTemplate类型的bean。</li><li>如果你定义的是一个SqlSessionFactory类型的bean，那么最终也会被包装为一个SqlSessionTemplate对象，并且赋值给sqlSession属性</li><li>而在SqlSessionTemplate类中就存在一个getMapper方法，这个方法中就产生一个Mapper接口代理对象</li><li>到时候，当执行该代理对象的某个方法时，就会进入到Mybatis框架的底层执行流程，详细的请看下图</li></ol><h2 id="spring整合mybatis后一级缓存失效问题" tabindex="-1"><a class="header-anchor" href="#spring整合mybatis后一级缓存失效问题" aria-hidden="true">#</a> Spring整合Mybatis后一级缓存失效问题</h2><p>Mybatis中的一级缓存是基于SqlSession来实现的，所以在执行同一个sql时，如果使用的是同一个SqlSession对象，那么就能利用到一级缓存，提高sql的执行效率。 ​</p><p>但是在Spring整合Mybatis后，如果没有执行某个方法时，该方法上没有加@Transactional注解，也就是没有开启Spring事务，那么后面在执行具体sql时，没执行一个sql时都会新生成一个SqlSession对象来执行该sql，这就是我们说的一级缓存失效（也就是没有使用同一个SqlSession对象），而如果开启了Spring事务，那么该Spring事务中的多个sql，在执行时会使用同一个SqlSession对象，从而一级缓存生效，具体的底层执行流程在上图。 ​</p><p>个人理解：实际上Spring整合Mybatis后一级缓存失效并<strong>不是问题</strong>，是正常的实现，因为，一个方法如果没有开启Spring事务，那么在执行sql时候，那就是每个sql单独一个事务来执行，也就是单独一个SqlSession对象来执行该sql，如果开启了Spring事务，那就是多个sql属于同一个事务，那自然就应该用一个SqlSession来执行这多个sql。所以，在没有开启Spring事务的时候，SqlSession的一级缓存并不是<strong>失效</strong>了，而是存在的生命周期太短了（执行完一个sql后就被销毁了，下一个sql执行时又是一个新的SqlSession了）。</p>',7),a={href:"https://www.processon.com/view/link/6152cc385653bb6791db436c",target:"_blank",rel:"noopener noreferrer"},t={},l=(0,n(66262).A)(t,[["render",function(i,e){const n=(0,s.g2)("OutboundLink"),t=(0,s.g2)("common-progresson-snippet");return(0,s.uX)(),(0,s.CE)(s.FK,null,[r,(0,s.Lk)("p",null,[(0,s.Lk)("a",a,[(0,s.eW)("Link"),(0,s.bF)(n)])]),(0,s.bF)(t,{src:"https://www.processon.com/view/link/6152cc385653bb6791db436c"})],64)}]])},66262:(i,e)=>{e.A=(i,e)=>{const n=i.__vccOpts||i;for(const[i,s]of e)n[i]=s;return n}}}]);
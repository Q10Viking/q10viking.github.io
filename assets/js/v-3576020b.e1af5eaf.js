"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[65107],{95475:(a,n,s)=>{s.r(n),s.d(n,{data:()=>e});const e={key:"v-3576020b",path:"/rabbitmq/10%20%E6%B6%88%E8%B4%B9%E7%AB%AF%E5%AF%B9%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E7%9A%84%E7%90%86%E8%A7%A3.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/rabbitmq/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"消息状态的变换",slug:"消息状态的变换",children:[{level:3,title:"对于消费端ack的理解basicAck⭐:",slug:"对于消费端ack的理解basicack⭐",children:[]}]},{level:2,title:"消息处于unacked意味着什么？⭐",slug:"消息处于unacked意味着什么-⭐",children:[]},{level:2,title:"basicQos的理解⭐",slug:"basicqos的理解⭐",children:[]}],filePathRelative:"rabbitmq/10 消费端对处理消息的理解.md"}},38489:(a,n,s)=>{s.r(n),s.d(n,{default:()=>p});var e=s(20641);const c=(0,e.Fv)('<h2 id="消息状态的变换" tabindex="-1"><a class="header-anchor" href="#消息状态的变换" aria-hidden="true">#</a> 消息状态的变换</h2><h3 id="对于消费端ack的理解basicack⭐" tabindex="-1"><a class="header-anchor" href="#对于消费端ack的理解basicack⭐" aria-hidden="true">#</a> <strong>对于消费端ack的理解basicAck⭐:</strong></h3><ol><li><p>消费建立的channel如果不进行ack操作，那么消息就会处于unacked状态，其他消费者获取不到</p></li><li><p>如果该消费者断开连接，那么消息就会转化为Ready状态，此时其他消费者能获取到</p></li><li><p>ack的方式是通过DeliveryTag,它是一个long类型，由RabbitMQ传递过来的。消费端ack的时候使用，用来相应Rabbitmq,告诉它这条消息ack了，确实已经消费了。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//false只确认签收当前的消息，设置为true的时候则代表签收该消费者所有未签收的消息</span>\nchannel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ol>',3),t={href:"https://www.processon.com/view/link/617d77d60791295c8579a1d1",target:"_blank",rel:"noopener noreferrer"},i=(0,e.Fv)('<p><img src="/images/RabbitMQ/image-20211031004903297.png" alt="image-20211031004903297"></p><hr><h2 id="消息处于unacked意味着什么-⭐" tabindex="-1"><a class="header-anchor" href="#消息处于unacked意味着什么-⭐" aria-hidden="true">#</a> 消息处于unacked意味着什么？⭐</h2><p><strong>意味着消费端正在处理消息，整个处理过程的业务耗时比较长，等处理完业务才进行ack。</strong></p><h2 id="basicqos的理解⭐" tabindex="-1"><a class="header-anchor" href="#basicqos的理解⭐" aria-hidden="true">#</a> basicQos的理解⭐</h2><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// basicQos,MQ不再对消费者一次发送多个请求，而是消费者处理完一个消息后（确认后），在从队列中获取一个新的</span>\nchannel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//处理完一个取一个</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如系统中有3个消费者（A,B,C），来共同消费100消息；</p><p>A和B设置了channel.basicQos(1); 而C没有设置</p><p>那么就有可能A取到一条消息进行处理，B取到一条消息进行处理，C呢就可能把<strong>剩余全部的消息自己先揽过来，然后再进行处理</strong></p><p>A和B分别处理完自己接受的消息之后，再去拿消息，发现没有了，而C自己在处理其他的98的消息。</p><p>这样就会导致A和B很空闲，而C却很繁忙。<strong>因为多个消费端他们是存在竞争关系的</strong></p>',11),l={},p=(0,s(66262).A)(l,[["render",function(a,n){const s=(0,e.g2)("OutboundLink");return(0,e.uX)(),(0,e.CE)(e.FK,null,[c,(0,e.Lk)("p",null,[(0,e.Lk)("a",t,[(0,e.eW)("图片链接"),(0,e.bF)(s)])]),i],64)}]])},66262:(a,n)=>{n.A=(a,n)=>{const s=a.__vccOpts||a;for(const[a,e]of n)s[a]=e;return s}}}]);
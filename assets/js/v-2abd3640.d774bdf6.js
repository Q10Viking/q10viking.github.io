"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[2158],{98031:(a,e,n)=>{n.r(e),n.d(e,{data:()=>s});const s={key:"v-2abd3640",path:"/netty/04%20Buffer.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/netty/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"属性",slug:"属性",children:[{level:3,title:"capacity",slug:"capacity",children:[]},{level:3,title:"position",slug:"position",children:[]},{level:3,title:"limit",slug:"limit",children:[]}]},{level:2,title:"Buffer的分配",slug:"buffer的分配",children:[]},{level:2,title:"直接内存",slug:"直接内存",children:[{level:3,title:"直接内存（堆外内存）与堆内存比较",slug:"直接内存-堆外内存-与堆内存比较",children:[]}]},{level:2,title:"",slug:"",children:[]},{level:2,title:"Buffer读写",slug:"buffer读写",children:[{level:3,title:"写入Buffer",slug:"写入buffer",children:[]},{level:3,title:"flip方法",slug:"flip方法",children:[]},{level:3,title:"读取Buffer",slug:"读取buffer",children:[]},{level:3,title:"使用Buffer读写数据常见步骤",slug:"使用buffer读写数据常见步骤",children:[]},{level:3,title:"rewind()方法",slug:"rewind-方法",children:[]},{level:3,title:"mark()与reset()方法",slug:"mark-与reset-方法",children:[]},{level:3,title:"equals()与compareTo()方法",slug:"equals-与compareto-方法",children:[]}]}],filePathRelative:"netty/04 Buffer.md"}},8622:(a,e,n)=>{n.r(e),n.d(e,{default:()=>r});const s=(0,n(20641).Fv)('<h2 id="属性" tabindex="-1"><a class="header-anchor" href="#属性" aria-hidden="true">#</a> 属性</h2><h3 id="capacity" tabindex="-1"><a class="header-anchor" href="#capacity" aria-hidden="true">#</a> capacity</h3><p>作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p><h3 id="position" tabindex="-1"><a class="header-anchor" href="#position" aria-hidden="true">#</a> position</h3><p>当你写数据到Buffer中时，position表示当前能写的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p><p><strong>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置</strong>。❤️（RocketMO就是利用这个在加载commitLog文件的时候，来确定顺序写的位置）❤️</p><h3 id="limit" tabindex="-1"><a class="header-anchor" href="#limit" aria-hidden="true">#</a> limit</h3><p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。</p><p>当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</p><h2 id="buffer的分配" tabindex="-1"><a class="header-anchor" href="#buffer的分配" aria-hidden="true">#</a> Buffer的分配</h2><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有<strong>allocate</strong>方法(可以在堆上分配，也可以在直接内存上分配)。</p><ul><li><p>分配48字节capacity的ByteBuffer的例子:ByteBuffer buf = ByteBuffer.allocate(48);</p></li><li><p>分配一个可存储1024个字符的CharBuffer：CharBuffer buf = CharBuffer.allocate(1024);</p></li><li><p><strong>wrap方法</strong>：把一个byte数组或byte数组的一部分包装成ByteBuffer：</p></li></ul><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ByteBuffer</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token keyword">byte</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span>\n\n<span class="token class-name">ByteBuffer</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token keyword">byte</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="直接内存" tabindex="-1"><a class="header-anchor" href="#直接内存" aria-hidden="true">#</a> 直接内存</h2><p>HeapByteBuffer与DirectByteBuffer，在原理上，前者可以看出分配的buffer是在heap区域的，其实真正flush到远程的时候会先拷贝到直接内存，再做下一步操作；在NIO的框架下，很多框架会采用DirectByteBuffer来操作，这样分配的内存不再是在java heap上，经过性能测试，可以得到非常快速的网络交互，在大量的网络交互下，一般速度会比HeapByteBuffer要快速好几倍。</p><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。</p><p>NIO可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据</p><h3 id="直接内存-堆外内存-与堆内存比较" tabindex="-1"><a class="header-anchor" href="#直接内存-堆外内存-与堆内存比较" aria-hidden="true">#</a> <strong>直接内存（堆外内存）与堆内存比较</strong></h3><p>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显</p><p>直接内存IO读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h2><h2 id="buffer读写" tabindex="-1"><a class="header-anchor" href="#buffer读写" aria-hidden="true">#</a> Buffer读写</h2><h3 id="写入buffer" tabindex="-1"><a class="header-anchor" href="#写入buffer" aria-hidden="true">#</a> 写入Buffer</h3><ul><li><p><strong>读取Channel写到Buffer</strong></p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 从Channel写到Buffer的例子</span>\n<span class="token keyword">int</span> bytesRead <span class="token operator">=</span> inChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//read into buffer.</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><p><strong>通过Buffer的put()方法写到Buffer里。</strong></p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 从Channel写到Buffer的例子</span>\n<span class="token keyword">int</span> bytesRead <span class="token operator">=</span> inChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//read into buffer.</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul><h3 id="flip方法" tabindex="-1"><a class="header-anchor" href="#flip方法" aria-hidden="true">#</a> flip方法</h3><p>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</p><p>换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte、char等 —— 现在能读取多少个byte、char等</p><h3 id="读取buffer" tabindex="-1"><a class="header-anchor" href="#读取buffer" aria-hidden="true">#</a> 读取Buffer</h3><ul><li><p><strong>从Buffer读取数据写入到Channel</strong></p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 从Buffer读取数据到Channel的例子：</span>\n<span class="token keyword">int</span> bytesWritten <span class="token operator">=</span> inChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><p>使用get()方法从Buffer中读取数据的例子</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">byte</span> aByte <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul><h3 id="使用buffer读写数据常见步骤" tabindex="-1"><a class="header-anchor" href="#使用buffer读写数据常见步骤" aria-hidden="true">#</a> <strong>使用Buffer读写数据常见步骤</strong></h3><ol><li>写入数据到Buffer</li><li>调用flip()方法</li><li>从Buffer中读取数据</li><li>调用clear()方法或者compact()方法，准备下一次的写入</li></ol><p>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。</p><p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据</p><h3 id="rewind-方法" tabindex="-1"><a class="header-anchor" href="#rewind-方法" aria-hidden="true">#</a> <strong>rewind()方法</strong></h3><p>Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）</p><h3 id="mark-与reset-方法" tabindex="-1"><a class="header-anchor" href="#mark-与reset-方法" aria-hidden="true">#</a> <strong>mark()与reset()方法</strong></h3><p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>buffer<span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//call buffer.get() a couple of times, e.g. during parsing.</span>\n\nbuffer<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//set position back to mark.</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="equals-与compareto-方法" tabindex="-1"><a class="header-anchor" href="#equals-与compareto-方法" aria-hidden="true">#</a> <strong>equals()与compareTo()方法</strong></h3><p>可以使用equals()和compareTo()方法两个Buffer。</p><h4 id="equals" tabindex="-1"><a class="header-anchor" href="#equals" aria-hidden="true">#</a> <strong>equals()</strong></h4><p>当满足下列条件时，表示两个Buffer相等：</p><ol><li>有相同的类型（byte、char、int等）。</li><li>Buffer中剩余的byte、char等的个数相等。</li><li>Buffer中所有剩余的byte、char等都相同。</li></ol><p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</p>',44),t={},r=(0,n(66262).A)(t,[["render",function(a,e){return s}]])},66262:(a,e)=>{e.A=(a,e)=>{const n=a.__vccOpts||a;for(const[a,s]of e)n[a]=s;return n}}}]);
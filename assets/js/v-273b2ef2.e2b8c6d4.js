"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[47017],{56006:(e,r,t)=>{t.r(r),t.d(r,{data:()=>a});const a={key:"v-273b2ef2",path:"/concurrency/40%20ConcurrentHashMap%20JDK1.7.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/concurrency/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"数据结构",slug:"数据结构",children:[]},{level:2,title:"并发安全控制",slug:"并发安全控制",children:[]}],filePathRelative:"concurrency/40 ConcurrentHashMap JDK1.7.md"}},21959:(e,r,t)=>{t.r(r),t.d(r,{default:()=>c});const a=(0,t(20641).Fv)('<h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h2><p>ConcurrentHashMap的数据结构与HashMap基本类似，区别在于：</p><ol><li>内部在数据写入时加了同步机制(<strong>分段锁</strong>)保证线程安全，读操作是无锁操作；</li><li>扩容时老数据的转移是并发执行的，这样扩容的效率更高。</li></ol><h2 id="并发安全控制" tabindex="-1"><a class="header-anchor" href="#并发安全控制" aria-hidden="true">#</a> 并发安全控制</h2><p><img src="/images/concurrency/16139-1.png" alt="img"></p><blockquote><p>大的Hash表套小的Hash表</p></blockquote><p><strong>Segment数组extends ReentrantLock （分段锁）</strong></p><p><img src="/images/concurrency/image-202106301557015792" alt="image-20210630155701579"></p><p>当hash计算出现相同的时候，使用segement的锁，来确保线程安全</p><p><img src="/images/concurrency/image-20210630155308895.png" alt="image-20210630155308895"></p>',10),n={},c=(0,t(66262).A)(n,[["render",function(e,r){return a}]])},66262:(e,r)=>{r.A=(e,r)=>{const t=e.__vccOpts||e;for(const[e,a]of r)t[e]=a;return t}}}]);
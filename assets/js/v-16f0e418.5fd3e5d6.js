"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[80527],{79190:(a,s,n)=>{n.r(s),n.d(s,{data:()=>e});const e={key:"v-16f0e418",path:"/java/38%20hashCode%E4%B8%8Eequals.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/java/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"hashCode介绍",slug:"hashcode介绍",children:[{level:3,title:"为什么要有hashCode",slug:"为什么要有hashcode",children:[]}]},{level:2,title:"建议",slug:"建议",children:[]}],filePathRelative:"java/38 hashCode与equals.md"}},53235:(a,s,n)=>{n.r(s),n.d(s,{default:()=>t});const e=(0,n(20641).Fv)('<h2 id="hashcode介绍" tabindex="-1"><a class="header-anchor" href="#hashcode介绍" aria-hidden="true">#</a> hashCode介绍</h2><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有hashCode() 函数。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Object类是一个本地方法</span>\n<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// String类</span>\n<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> h <span class="token operator">=</span> hash<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">char</span> val<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>\n\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            h <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> h <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        hash <span class="token operator">=</span> h<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> h<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h3 id="为什么要有hashcode" tabindex="-1"><a class="header-anchor" href="#为什么要有hashcode" aria-hidden="true">#</a> 为什么要有hashCode</h3><p>以“HashSet如何检查重复”为例子来说明为什么要有hashCode：</p><p>对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有值，</p><p>如果没有、HashSet会假设对象没有重复出现。</p><p>但是如果发现有值，<strong>这时会调用equals（）方法来检查两个对象是否真的相同</strong>。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。</p><h2 id="建议" tabindex="-1"><a class="header-anchor" href="#建议" aria-hidden="true">#</a> 建议</h2><ul><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的（因为会出现hash冲突） 因此，equals方法被覆盖过，则hashCode方法也必须被覆盖，hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ul><p>**两个不相等的对象有可能具有相同的哈希码。**哈希码是由对象的哈希函数生成的一个整数值，用于支持快速查找和比较对象。</p><p>然而，由于哈希码的范围通常比对象的数量小得多，因此不同的对象可能会产生相同的哈希码。这种情况被称为哈希冲突。</p><p>哈希算法设计的目标是将不同的输入均匀分布在哈希码空间中，但无法避免完全消除冲突。因此，当发生哈希冲突时，哈希算法会使用特定的策略（例如链表或树结构）来处理这些冲突，以确保不同的对象可以存储在同一个哈希桶中。</p><p>哈希码仅用于初步判断对象是否可能相等，最终的相等性检查还需要通过 equals() 方法进行。因此，在重写 equals() 方法时，也应该相应地重写 hashCode() 方法，以尽量减少哈希冲突的发生</p>',15),p={},t=(0,n(66262).A)(p,[["render",function(a,s){return e}]])},66262:(a,s)=>{s.A=(a,s)=>{const n=a.__vccOpts||a;for(const[a,e]of s)n[a]=e;return n}}}]);
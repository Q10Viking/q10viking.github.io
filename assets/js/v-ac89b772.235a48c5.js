"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[53903],{125:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-ac89b772",path:"/MySQL/05%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/MySQL/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"存储引擎",slug:"存储引擎",children:[]},{level:2,title:"MyISAM",slug:"myisam",children:[{level:3,title:"查找数据的过程",slug:"查找数据的过程",children:[]}]},{level:2,title:"InnoDB",slug:"innodb",children:[{level:3,title:"使用InnodDB的建议❤️",slug:"使用innoddb的建议❤️",children:[]},{level:3,title:"主键索引与二级索引⭐",slug:"主键索引与二级索引⭐",children:[]}]},{level:2,title:"MyISAM与InnoDB的区别",slug:"myisam与innodb的区别",children:[]},{level:2,title:"聚簇索引VS 稀疏索引",slug:"聚簇索引vs-稀疏索引",children:[{level:3,title:"稀疏索引",slug:"稀疏索引",children:[]},{level:3,title:"聚簇索引",slug:"聚簇索引",children:[]}]},{level:2,title:"联合索引（复合索引）⭐",slug:"联合索引-复合索引-⭐",children:[{level:3,title:"最左前缀原理⭐",slug:"最左前缀原理⭐",children:[]}]}],filePathRelative:"MySQL/05 存储引擎.md"}},78384:(n,s,a)=>{a.r(s),a.d(s,{default:()=>t});const e=(0,a(20641).Fv)('<h2 id="存储引擎" tabindex="-1"><a class="header-anchor" href="#存储引擎" aria-hidden="true">#</a> 存储引擎</h2><p>存储引擎是为了描述表的。如在navicat建表时，可以看到引擎的选项</p><p><img src="/images/MySQL/image-20211026175535799.png" alt="image-20211026175535799"></p><p>linux查看数据库表存放的位置</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;%dir%&#39;</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><img src="/images/MySQL/image-20211026174954208.png" alt="image-20211026174954208"></p><h2 id="myisam" tabindex="-1"><a class="header-anchor" href="#myisam" aria-hidden="true">#</a> MyISAM</h2><blockquote><p>创建一张表用于测试</p></blockquote><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>test_myisam<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>MyISAM <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb3<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>查看生成的文件</p></blockquote><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>-rw-r-----. <span class="token number">1</span> mysql mysql <span class="token number">2786</span> Oct <span class="token number">26</span> 06:01 test_myisam_363.sdi\n-rw-r-----. <span class="token number">1</span> mysql mysql    <span class="token number">0</span> Oct <span class="token number">26</span> 06:01 test_myisam.MYD\n-rw-r-----. <span class="token number">1</span> mysql mysql <span class="token number">1024</span> Oct <span class="token number">26</span> 06:01 test_myisam.MYI\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol><li>MySQL8开始删除了原来的frm文件，并采用 Serialized Dictionary Information (SDI), 是MySQL8.0重新设计数据词典后引入的新产物,并开始已经统一使用InnoDB存储引擎来存储表的<strong>元数据信息</strong>。</li><li>MYD数据文件存储的是表数据</li><li>MYI索引文件存储的是索引</li></ol><h3 id="查找数据的过程" tabindex="-1"><a class="header-anchor" href="#查找数据的过程" aria-hidden="true">#</a> 查找数据的过程</h3><blockquote><p>MyISAM索引文件和数据文件是分离的（非聚集）</p></blockquote><p><img src="/images/MySQL/image-20210520094252854.png" alt="image-20210520094252854"></p><p>为Col1建立的索引，查找Col1=30的过程</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> Col1 <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>在MYI文件中按照B+Tree的数据结构，组织好索引。在MYD文件中存储了表数据</p><p>从根页节点开始遍历，找到30所对应的磁盘文件地址0xF3.</p><p>再根据0xF3去MYD中查找该数据。</p><h2 id="innodb" tabindex="-1"><a class="header-anchor" href="#innodb" aria-hidden="true">#</a> InnoDB</h2><blockquote><p>创建一个表用于测试,<strong>普通索引(由关键字KEY或INDEX定义的索引)</strong></p></blockquote><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>test_innodb<span class="token punctuation">`</span></span><span class="token punctuation">(</span>\n\t<span class="token identifier"><span class="token punctuation">`</span>a<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n\t<span class="token identifier"><span class="token punctuation">`</span>b<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n\t<span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>a<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n\t<span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>b<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">INNODB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>查看生成的文件</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token comment">-----. 1 mysql mysql 147456 Oct 26 06:28 test_innodb.ibd</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol><li>ibd文件，InnoDB索引实现（聚集） <ol><li><strong>ibd数据文件本身就是按B+Tree组织的一个索引结构文件</strong></li><li><strong>聚集索引</strong>-<strong>叶节点包含了完整的数据记录⭐</strong></li></ol></li></ol><p><img src="/images/MySQL/image-20210520094722981.png" alt="image-20210520094722981"></p><h3 id="使用innoddb的建议❤️" tabindex="-1"><a class="header-anchor" href="#使用innoddb的建议❤️" aria-hidden="true">#</a> 使用InnodDB的建议❤️</h3><blockquote><p>为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键</p></blockquote><ol><li><p>为什么必须建主键？</p><ol><li>如果不建主键 <ol><li>Mysql会选择一列，该列所有元素都不相等，以该列来建立索引组织数据</li><li>如果没有找到，则会自己建立一个<strong>隐藏列</strong>来组织数据</li></ol></li><li>如果建立主键，那么好处就是节省了mysql的资源，不用再额外再建立一个隐藏列。</li></ol></li><li><p>为什么使用<strong>整型</strong>的<strong>自增</strong>主键?</p><ol><li><p>为什么使用整型？</p><ol><li>如果使用uuid字符串来比较，比对时间和占用空间都会比较大</li><li>uuid字符串是根据ascii码来进行比较，如果前面都相等，只有最后一个字符不同，那么对比时间就会增加</li></ol></li><li><p>为什么使用自增？</p><ol><li>因为B+Tree中索引是有序的</li><li>自增的好处是插入的节点不会<strong>导致树的分裂与平衡</strong> https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html <ol><li><img src="/images/MySQL/image-20211026193427596.png" alt="image-20211026193427596"></li><li><img src="/images/MySQL/image-20211026193459095.png" alt="image-20211026193459095"></li><li><strong>如果只是自增，就只需要考虑平衡</strong></li></ol></li></ol></li></ol></li></ol><blockquote><p>在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： <code>NOT NULL PRIMARY KEY AUTO_INCREMENT</code>。</p></blockquote><h3 id="主键索引与二级索引⭐" tabindex="-1"><a class="header-anchor" href="#主键索引与二级索引⭐" aria-hidden="true">#</a> 主键索引与二级索引⭐</h3><p>InnodDB只有一个<strong>主键索引</strong>，在主键索引的叶子节点存储着表数据。</p><p>允许建立<strong>二级索引</strong>，但是二级索引中叶子节点存储的数据是主键的值。</p><ol><li>为什么<strong>非主键索引结构叶子节点存储的是主键值</strong>（<strong>二级索引⭐</strong>）？ <ol><li><strong>节省存储空间</strong>，不用再存储其他列的数据</li><li><strong>一致性</strong>，更新数据的时候，只需要更新主键索引的数据即可，不用管二级索引</li></ol></li></ol><p><img src="/images/MySQL/image-20210520101625218.png" alt="image-20210520101625218"></p><p><strong>二级索引也是稀疏索引，在查找到主键之后，还需要进行回表操作。</strong></p><h4 id="案例❤️" tabindex="-1"><a class="header-anchor" href="#案例❤️" aria-hidden="true">#</a> 案例❤️</h4><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> T<span class="token punctuation">(</span>\n    id <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span> \n    k <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span> \n    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token keyword">index</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>\n<span class="token punctuation">)</span><span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>文件</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@k8s-master test<span class="token punctuation">]</span><span class="token comment"># ls</span>\n T.ibd\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下</p><p><img src="/images/MySQL/image-20230509164902168.png" alt="image-20230509164902168"></p><ul><li><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</p></li><li><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）</p></li></ul><blockquote><p><strong>基于主键索引和普通索引的查询有什么区别</strong>?</p></blockquote><ul><li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li><li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。<strong>这个过程称为回表</strong>。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h4 id="重建索引" tabindex="-1"><a class="header-anchor" href="#重建索引" aria-hidden="true">#</a> 重建索引</h4><blockquote><p>如果你要重建索引 k，你的两个 SQL 语句可以这么写：</p></blockquote><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">alter</span> <span class="token keyword">table</span> T <span class="token keyword">drop</span> <span class="token keyword">index</span> k<span class="token punctuation">;</span>\n<span class="token keyword">alter</span> <span class="token keyword">table</span> T <span class="token keyword">add</span> <span class="token keyword">index</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>如果你要重建主键索引，也可以这么写</p></blockquote><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">alter</span> <span class="token keyword">table</span> T <span class="token keyword">drop</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">;</span>\n<span class="token keyword">alter</span> <span class="token keyword">table</span> T <span class="token keyword">add</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="myisam与innodb的区别" tabindex="-1"><a class="header-anchor" href="#myisam与innodb的区别" aria-hidden="true">#</a> MyISAM与InnoDB的区别</h2><ol><li>MyISAM的索引实现是<strong>非聚簇索引（稀疏索引）</strong><ol><li>用了两个文件来分别存储数据和索引</li></ol></li><li>InnoDB索引实现是聚簇索引</li></ol><p>还有其他很多方面。我专门提取出来写一个。</p><h2 id="聚簇索引vs-稀疏索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引vs-稀疏索引" aria-hidden="true">#</a> 聚簇索引VS 稀疏索引</h2><p>使用了聚簇索引，查找速度会快一点。因为在聚簇索引中存储了数据，找到了，就找到了。而非聚簇索引，找了之后还需要根据地址，跨文件查找（进行回表操作）</p><h3 id="稀疏索引" tabindex="-1"><a class="header-anchor" href="#稀疏索引" aria-hidden="true">#</a> 稀疏索引</h3><p>二级索引也是使用了稀疏索引</p><p><img src="/images/MySQL/image-202105200942528541.png" alt="image-20210520094252854"></p><h3 id="聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引" aria-hidden="true">#</a> 聚簇索引</h3><p>叶子节点中存储着数据</p><p><img src="/images/MySQL/image-202105200947229811.png" alt="image-20210520094722981"></p><h2 id="联合索引-复合索引-⭐" tabindex="-1"><a class="header-anchor" href="#联合索引-复合索引-⭐" aria-hidden="true">#</a> 联合索引（复合索引）⭐</h2><p>多个字段构成一个索引。</p><p>在开发中，不建议建立多个单值的索引</p><blockquote><p>底层存储结构</p></blockquote><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_name_age_position<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>position<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>\n<span class="token comment">-- 或者</span>\n<span class="token keyword">INDEX</span> <span class="token identifier"><span class="token punctuation">`</span>idx_name_age_position<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>position<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/../../../../saas-yong/fullstack/Java架构师之路/Mysql/imgs/image-20210520101928183.png" alt="image-20210520101928183"></p><h3 id="最左前缀原理⭐" tabindex="-1"><a class="header-anchor" href="#最左前缀原理⭐" aria-hidden="true">#</a> 最左前缀原理⭐</h3><p>使用复合索引的情况下如何确保顺序？本身还是B+Tree，但是先比较name,然后是age,然后是position。</p><h4 id="存在的问题" tabindex="-1"><a class="header-anchor" href="#存在的问题" aria-hidden="true">#</a> 存在的问题</h4><p>查询的时候（因为联合索引已经排好序的），通过使用最左前缀原理，来判断会不会走索引。如果不能走索引则会全表扫描。</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">KEY</span> <span class="token string">&#39;idx_name_age_position&#39;</span> <span class="token punctuation">(</span><span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;age&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;position&#39;</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">;</span>\n\n<span class="token comment"># 会走索引</span>\n<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employee <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">&#39;Bill&#39;</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>\n<span class="token comment"># 不会走索引，进行全表扫描 </span>\n<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employee <span class="token keyword">WHERE</span> age <span class="token operator">=</span> <span class="token number">30</span> <span class="token operator">AND</span> position <span class="token operator">=</span> <span class="token string">&#39;dev&#39;</span><span class="token punctuation">;</span>\n<span class="token comment"># 不会走索引，进行全表扫描</span>\n<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employee <span class="token keyword">WHERE</span> position <span class="token operator">=</span> <span class="token string">&#39;manager&#39;</span><span class="token punctuation">;</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>分析一下 <strong>EXPLAIN SELECT * FROM employee WHERE age = 30 AND position = &#39;dev&#39;</strong>;为什么会失效？</p><p><img src="/images/MySQL/image-20211026200841428.png" alt="image-20211026200841428"></p>',76),p={},t=(0,a(66262).A)(p,[["render",function(n,s){return e}]])},66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}}}]);
"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[35249],{81208:(e,i,a)=>{a.r(i),a.d(i,{data:()=>l});const l={key:"v-10b559f5",path:"/ElasticStack/02%20es%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/ElasticStack/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"索引 index",slug:"索引-index",children:[]},{level:2,title:"映射 mapping",slug:"映射-mapping",children:[]},{level:2,title:"字段Field",slug:"字段field",children:[]},{level:2,title:"字段类型 Type",slug:"字段类型-type",children:[]},{level:2,title:"文档 document",slug:"文档-document",children:[]},{level:2,title:"集群 cluster",slug:"集群-cluster",children:[]},{level:2,title:"节点 node",slug:"节点-node",children:[]},{level:2,title:"分片和副本 shards&replicas",slug:"分片和副本-shards-replicas",children:[{level:3,title:"分片",slug:"分片",children:[]},{level:3,title:"副本",slug:"副本",children:[]}]}],filePathRelative:"ElasticStack/02 es核心概念.md"}},48639:(e,i,a)=>{a.r(i),a.d(i,{default:()=>t});const l=(0,a(20641).Fv)('<h2 id="索引-index" tabindex="-1"><a class="header-anchor" href="#索引-index" aria-hidden="true">#</a> <strong>索引 index</strong></h2><p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，❤️可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引❤️</p><p>❤️一个索引由一个名字来标识（必须全部是小写字母的）❤️，并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字</p><h2 id="映射-mapping" tabindex="-1"><a class="header-anchor" href="#映射-mapping" aria-hidden="true">#</a> <strong>映射 mapping</strong></h2><p><strong>ElasticSearch中的映射（Mapping）用来定义一个文档</strong></p><p>mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分词器、是否被索引等等，这些都是映射里面可以设置的</p><h2 id="字段field" tabindex="-1"><a class="header-anchor" href="#字段field" aria-hidden="true">#</a> <strong>字段Field</strong></h2><p>相当于是数据表的字段|列</p><h2 id="字段类型-type" tabindex="-1"><a class="header-anchor" href="#字段类型-type" aria-hidden="true">#</a> <strong>字段类型 Type</strong></h2><p>每一个字段都应该有一个对应的类型，例如：Text、Keyword、Byte等</p><h2 id="文档-document" tabindex="-1"><a class="header-anchor" href="#文档-document" aria-hidden="true">#</a> <strong>文档 document</strong></h2><p>一个文档是一个可被索引的基础信息单元，类似一条记录。文档以JSON（Javascript Object Notation）格式来表示；</p><h2 id="集群-cluster" tabindex="-1"><a class="header-anchor" href="#集群-cluster" aria-hidden="true">#</a> <strong>集群 cluster</strong></h2><p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能</p><h2 id="节点-node" tabindex="-1"><a class="header-anchor" href="#节点-node" aria-hidden="true">#</a> <strong>节点 node</strong></h2><p>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能</p><p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中。这意味着，如果在网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中</p><p>在一个集群里，可以拥有任意多个节点。而且，如果当前网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</p><h2 id="分片和副本-shards-replicas" tabindex="-1"><a class="header-anchor" href="#分片和副本-shards-replicas" aria-hidden="true">#</a> <strong>分片和副本 shards&amp;replicas</strong></h2><h3 id="分片" tabindex="-1"><a class="header-anchor" href="#分片" aria-hidden="true">#</a> <strong>分片</strong></h3><ul><li>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了<strong>将索引划分成多份的能力，这些份就叫做分片</strong></li><li>当创建一个索引的时候，可以指定你想要的分片的数量</li><li>每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上</li><li>分片很重要，主要有两方面的原因 <ul><li>允许水平分割/扩展你的内容容量</li><li>允许在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量</li></ul></li><li>至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户来说，这些都是透明的</li></ul><h3 id="副本" tabindex="-1"><a class="header-anchor" href="#副本" aria-hidden="true">#</a> <strong>副本</strong></h3><ul><li>在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个<strong>故障转移机制</strong>是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做副本分片，或者直接叫副本</li><li>副本之所以重要，有两个主要原因 <ul><li>在分片/节点失败的情况下，提供了高可用性。（注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的）</li><li>扩展搜索量/吞吐量，因为搜索可以在所有的副本上并行运行 <ul><li>每个索引可以被分成多个分片。一个索引有0个或者多个副本</li><li>一旦设置了副本，每个索引就有了主分片和副本分片，分片和副本的数量可以在索引创建的时候指定</li><li>在索引创建之后，可以在任何时候动态地改变副本的数量，但是不能改变分片的数量</li></ul></li></ul></li></ul>',23),r={},t=(0,a(66262).A)(r,[["render",function(e,i){return l}]])},66262:(e,i)=>{i.A=(e,i)=>{const a=e.__vccOpts||e;for(const[e,l]of i)a[e]=l;return a}}}]);
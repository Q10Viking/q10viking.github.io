"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[12932],{15287:(e,t,l)=>{l.r(t),l.d(t,{data:()=>r});const r={key:"v-15615ccd",path:"/MySQL/65%20%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E4%BF%AE%E6%94%B9%E5%90%8C%E4%B8%80%E8%A1%8C%E6%95%B0%E6%8D%AE.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/MySQL/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[],filePathRelative:"MySQL/65 高并发下修改同一行数据.md"}},97559:(e,t,l)=>{l.r(t),l.d(t,{default:()=>u});var r=l(20641);const i=[(0,r.Lk)("li",null,"**乐观锁：在数据表中添加一个版本号（或者时间戳）字段，每次更新数据时都会检查该字段的值。**当多个并发的请求同时修改同一行数据时，只有一个请求能够成功执行更新操作，其他请求需要重新检查数据是否被修改过。如果数据没有被修改，那么它们可以重新尝试更新；如果数据已经被修改，则这些请求需要触发重试等相应的冲突处理逻辑。",-1),(0,r.Lk)("li",null,"**悲观锁：**在读取数据之前，使用数据库提供的锁机制，如SELECT ... FOR UPDATE语句，将要修改的行数据进行加锁。这样，其他并发的请求在读取相同行数据时会被阻塞，直到锁释放。这种方法能够确保同一时间只有一个请求在修改数据，但是会影响系统的并发性能。",-1),(0,r.Lk)("li",null,"**分布式锁：**通过使用分布式锁服务，如Redis的SETNX命令或ZooKeeper的临时节点，来实现对行级数据的互斥访问。在修改数据前先尝试获取锁，获取成功后执行数据修改操作，修改完成后释放锁。其他请求在获取锁失败时可以等待或执行相应的冲突处理逻辑。",-1),(0,r.Lk)("li",null,"**事务：**将对同一行数据的修改操作封装在数据库事务中。在事务中，数据库会自动处理并发修改的冲突，通过锁定相应的数据行来确保数据的一致性和完整性。并发的请求会被串行化执行，保证每个请求都能正确读取并修改数据。",-1)],n={},u=(0,l(66262).A)(n,[["render",function(e,t){return(0,r.uX)(),(0,r.CE)("ol",null,i)}]])},66262:(e,t)=>{t.A=(e,t)=>{const l=e.__vccOpts||e;for(const[e,r]of t)l[e]=r;return l}}}]);
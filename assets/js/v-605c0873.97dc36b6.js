"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[32220],{52007:(e,a,i)=>{i.r(a),i.d(a,{data:()=>r});const r={key:"v-605c0873",path:"/Algorithm/%E6%A0%91.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/Algorithm/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"树的度",slug:"树的度",children:[]},{level:2,title:"树的深度",slug:"树的深度",children:[]},{level:2,title:"树的表示",slug:"树的表示",children:[]},{level:2,title:"常用的孩子表示法",slug:"常用的孩子表示法",children:[]},{level:2,title:"二叉树",slug:"二叉树",children:[{level:3,title:"斜树",slug:"斜树",children:[]},{level:3,title:"满二叉树",slug:"满二叉树",children:[]},{level:3,title:"完全二叉树❤️",slug:"完全二叉树❤️",children:[]},{level:3,title:"二叉树的表示",slug:"二叉树的表示",children:[]},{level:3,title:"二叉树的遍历",slug:"二叉树的遍历",children:[]}]}],filePathRelative:"Algorithm/树.md"}},96774:(e,a,i)=>{i.r(a),i.d(a,{default:()=>t});const r=(0,i(20641).Fv)('<h2 id="树的度" tabindex="-1"><a class="header-anchor" href="#树的度" aria-hidden="true">#</a> 树的度</h2><p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度(Degree)。度为0的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。我们例子中的数结点的度的最大值是结点D的度，为3，所以树的度也为3</p><p><img src="/images/algorithm/image-20230924004052097.png" alt="image-20230924004052097"></p><h2 id="树的深度" tabindex="-1"><a class="header-anchor" href="#树的深度" aria-hidden="true">#</a> 树的深度</h2><p>当前树的深度为4</p><p><img src="/images/algorithm/image-20230924005010206.png" alt="image-20230924005010206"></p><h2 id="树的表示" tabindex="-1"><a class="header-anchor" href="#树的表示" aria-hidden="true">#</a> 树的表示</h2><p>树中某个结点的孩子可以有多个，这就意味着，我们在代码实现时要能体现结点之间的逻辑关系，比如谁是谁的双亲，谁是谁的孩子呢？所以简单的顺序存储结构是不能满足树的实现要求的。</p><p>一般情况下对树的存储有三种不同的表示法:双亲表示法、孩子表示法、孩子兄弟表示法</p><h4 id="双亲表示法" tabindex="-1"><a class="header-anchor" href="#双亲表示法" aria-hidden="true">#</a> 双亲表示法</h4><p>树这种结构，除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。</p><p>我们可以在每个结点中，附设一个指示器指示其双亲结点的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。</p><p>其中data是数据域，存储结点的数据信息。而parent是指针域,存储该结点的双亲的位置。</p><p><img src="/images/algorithm/image-20230924003245115.png" alt="image-20230924003245115"></p><p>有了这样的结构定义，我们就可以来实现双亲表示法了。由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这也就意味着，我们所有的结点都存有它双亲的位置</p><p>这样的存储结构，我们可以根据结点的 parent 指针很容易找到它的双亲结点，所用的时间复杂度为0[1)，直到 parent为-1时，表示找到了树结点的根。但如果我们要知道结点的孩子是什么，就需要请遍历整个结构才行</p><p><img src="/images/algorithm/image-20230924003342319.png" alt="image-20230924003342319"></p><h4 id="孩子表示法" tabindex="-1"><a class="header-anchor" href="#孩子表示法" aria-hidden="true">#</a> 孩子表示法</h4><p>双亲表示法我们知道，是由孩子指向双亲，孩子表示法则是由双亲结点指向孩子结点。但是，树中每个结点可能有多棵子树，怎么办呢？可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过,树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。</p><h5 id="方案一" tabindex="-1"><a class="header-anchor" href="#方案一" aria-hidden="true">#</a> 方案一</h5><p>一种是指针域的个数就等于树的度</p><p><img src="/images/algorithm/image-20230924004117303.png" alt="image-20230924004117303"></p><p>其中data是数据域。chid1到chidn是指针域，用来指向该结点的孩子结点。对于我们的例子来说，树的度是3，所以我们的指针域的个数是3</p><p><img src="/images/algorithm/image-20230924004148054.png" alt="image-20230924004148054"></p><p>这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。</p><p>既然很多指针域都可能为空，为什么不按需分配空间呢。于是我们有了第二种方案。</p><h5 id="方案二" tabindex="-1"><a class="header-anchor" href="#方案二" aria-hidden="true">#</a> 方案二</h5><p>第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数</p><p><img src="/images/algorithm/image-20230924004241408.png" alt="image-20230924004241408"></p><p>中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1 到 childn为指针域,指向该结点的各个孩子的结点</p><p><img src="/images/algorithm/image-20230924004259938.png" alt="image-20230924004259938"></p><p>这种方法克服了浪费空间的缺点,对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。</p><p>能否有更好的方法,既可以减少空指针的浪费又能使结点结构相同</p><h2 id="常用的孩子表示法" tabindex="-1"><a class="header-anchor" href="#常用的孩子表示法" aria-hidden="true">#</a> 常用的孩子表示法</h2><p>所以常用的孩子表示法是这样的，把每个结点放到一个顺序存储结构的数组中，再对每个结点的孩子建立把每个结点的孩子结点排列起来,以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表,采用顺序存储结构，存放进一个一维数组中</p><p><img src="/images/algorithm/image-20230924004547282.png" alt="image-20230924004547282"></p><p>这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。</p><p>但是，这也存在着问题，如何知道某个结点的双亲是谁呢?比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗?当然是可以。在存储时增加一个表示双亲结点的域就可以了。</p><h2 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h2><p>二叉树的特点有:</p><p>每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。</p><p>.左子树和右子树是有顺序的，次序不能任意颠倒。就像人是双手、双脚，但显然左手、左脚和右手、右脚是不一样的，右手戴左手套、右脚穿左鞋都会极其别扭和难受。</p><p>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。如下图，都是二叉树，但它们却是不同的二叉树。</p><p>​ <img src="/images/algorithm/image-20230924004834964.png" alt="image-20230924004834964"></p><p>二叉树具有五种基本形态:</p><p>1．空二叉树。</p><p>2．只有一个根结点。</p><p>3．根结点只有左子树。</p><p>4．根结点只有右子树。</p><p>5．根结点既有左子树又有右子树。</p><h3 id="斜树" tabindex="-1"><a class="header-anchor" href="#斜树" aria-hidden="true">#</a> 斜树</h3><p>顾名思义，斜树一定要是斜的，但是往哪斜还是有讲究。所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。斜树有很明显的特点，就是每一层都只有一个结点，<strong>结点的个数与二叉树的深度相同</strong>。</p><h3 id="满二叉树" tabindex="-1"><a class="header-anchor" href="#满二叉树" aria-hidden="true">#</a> 满二叉树</h3><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上,这样的二叉树称为满二叉树。</p><p>单是每个结点都存在左右子树，不能算是满二叉树，还必须要所有的叶子都在同一层上，这就做到了整棵树的平衡</p><p><img src="/images/algorithm/image-20230924005117206.png" alt="image-20230924005117206"></p><p>因此,满二叉树的特点有:</p><p>(1)叶子只能出现在最下一层。出现在其他层就不可能达成平衡。</p><p>(2）非叶子结点的度一定是2。否则就是“缺胳膊少腿”了。</p><p>(3)在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多</p><h3 id="完全二叉树❤️" tabindex="-1"><a class="header-anchor" href="#完全二叉树❤️" aria-hidden="true">#</a> 完全二叉树❤️</h3><p>对一棵具有n个结点的二叉树按层序编号，如果编号为i (1&lt;i&lt;n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</p><p><img src="/images/algorithm/image-20230924005254934.png" alt="image-20230924005254934"></p><p>首先从字面上要区分，“完全”和“满”的差异，满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。</p><p>其次，完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的。这里有个关键词是按层序编号。</p><p><strong>完全二叉树的数组表示法</strong></p><p><img src="/images/algorithm/image-20230924005339587.png" alt="image-20230924005339587"></p><blockquote><p><strong>推论1</strong>：对于位置为K的结点 <strong>左子结点=2<em>k+1 右子结点=2</em>(k+1)</strong></p><p>验证：C:2 2<em>2+1=5 2</em>(k+1)=6</p><p><strong>推论2</strong>：最后一个非叶节点的位置为 (N/2)-1，N为数组长度。</p></blockquote><h3 id="二叉树的表示" tabindex="-1"><a class="header-anchor" href="#二叉树的表示" aria-hidden="true">#</a> 二叉树的表示</h3><p>上面所说的数组存储结构一般只用于完全二叉树。二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法。</p><p>其中data是数据域，leftchild和rightchild都是指针域，分别存放指向左孩子和右孩子的指针。当然根据需要，增加双亲结点的指针和兄弟结点的指针都没什么问题。</p><h3 id="二叉树的遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的遍历" aria-hidden="true">#</a> 二叉树的遍历</h3><p>二叉树的遍历（traversing binary tree)是指从根结点出发,按照某种次序依次访问二叉树中所有结点，,使得每个结点被访问一次且仅被访问一次。</p><p>访问其实是要根据实际的需要来确定具体做什么，比如对每个结点进行相关计算，输出打印等。在这里我们可以简单地假定就是输出结点的数据信息。通过结点的指针域到达其他结点不能称为访问，我们可以把这种操作称之为<strong>经过</strong>结点</p>',74),p={},t=(0,i(66262).A)(p,[["render",function(e,a){return r}]])},66262:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,r]of a)i[e]=r;return i}}}]);
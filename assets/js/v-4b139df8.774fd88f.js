"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[81891],{49600:(t,s,e)=>{e.r(s),e.d(s,{data:()=>a});const a={key:"v-4b139df8",path:"/Redis/15%20RDB%E5%BF%AB%E7%85%A7%E6%8C%81%E4%B9%85%E5%8C%96.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/Redis/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"RDB快照（snapshot）",slug:"rdb快照-snapshot",children:[]},{level:2,title:"bgsave的写时复制(COW)机制⭐",slug:"bgsave的写时复制-cow-机制⭐",children:[]},{level:2,title:"save与bgsave对比",slug:"save与bgsave对比",children:[]}],filePathRelative:"Redis/15 RDB快照持久化.md"}},53058:(t,s,e)=>{e.r(s),e.d(s,{default:()=>n});const a=(0,e(20641).Fv)('<h2 id="rdb快照-snapshot" tabindex="-1"><a class="header-anchor" href="#rdb快照-snapshot" aria-hidden="true">#</a> <strong>RDB快照（snapshot）</strong></h2><p>在默认情况下， Redis 将内存数据库快照保存在名字为 <strong>dump.rdb 的二进制文件</strong>中。</p><p>你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集：</span>\n# save <span class="token number">60</span> <span class="token number">1000</span>    <span class="token comment">//关闭RDB只需要将所有的save保存策略注释掉即可</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>还可以手动执行命令生成RDB快照，进入redis客户端执行命令<strong>save</strong>或<strong>bgsave</strong>可以生成dump.rdb文件，每次命令执行都会<strong>将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件</strong>。</p><h2 id="bgsave的写时复制-cow-机制⭐" tabindex="-1"><a class="header-anchor" href="#bgsave的写时复制-cow-机制⭐" aria-hidden="true">#</a> <strong>bgsave的写时复制(COW)机制</strong>⭐</h2><blockquote><p>Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常处理写命令。简单来说，bgsave 子进程是由主线程 fork 生成的，可以<strong>共享主线程的所有内存数据</strong>。</p></blockquote><p>bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就<strong>会被复制一份</strong>，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p><h2 id="save与bgsave对比" tabindex="-1"><a class="header-anchor" href="#save与bgsave对比" aria-hidden="true">#</a> <strong>save与bgsave对比</strong></h2><blockquote><p><strong>redis配置自动生成rdb文件后台使用的是bgsave方式。</strong></p></blockquote><table><thead><tr><th><strong>命令</strong></th><th><strong>save</strong></th><th><strong>bgsave</strong></th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>是否阻塞redis其它命令</td><td>是</td><td>否(在生成子进程执行调用fork函数时会有短暂阻塞)</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fork子进程，消耗内存</td></tr></tbody></table>',11),r={},n=(0,e(66262).A)(r,[["render",function(t,s){return a}]])},66262:(t,s)=>{s.A=(t,s)=>{const e=t.__vccOpts||t;for(const[t,a]of s)e[t]=a;return e}}}]);
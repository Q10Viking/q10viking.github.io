"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[79978],{49887:(e,a,n)=>{n.r(a),n.d(a,{data:()=>s});const s={key:"v-5f2cdd20",path:"/Docker/20%20k8s%E5%91%A8%E8%BE%B9%E9%97%AE%E9%A2%98%E5%BD%92%E6%80%BB.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/Docker/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"kubectl 排查服务问题",slug:"kubectl-排查服务问题",children:[]},{level:2,title:"K8S真的放弃Docker了吗",slug:"k8s真的放弃docker了吗",children:[{level:3,title:"K8S CRI",slug:"k8s-cri",children:[]}]},{level:2,title:"部署项目",slug:"部署项目",children:[]}],filePathRelative:"Docker/20 k8s周边问题归总.md"}},3152:(e,a,n)=>{n.r(a),n.d(a,{default:()=>o});var s=n(20641);const c=(0,s.Fv)('<h2 id="kubectl-排查服务问题" tabindex="-1"><a class="header-anchor" href="#kubectl-排查服务问题" aria-hidden="true">#</a> kubectl 排查服务问题</h2><blockquote><p>K8S 上部署服务失败了怎么排查？</p></blockquote><p>用这个命令：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code> kubectl describe <span class="token variable">${RESOURCE}</span> <span class="token variable">${NAME}</span>              \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>拉到最后看到Events部分，会显示出 K8S 在部署这个服务过程的关键日志。</p><p>一般来说，通过<code>kubectl describe pod ${POD_NAME}</code>已经能定位绝大部分部署失败的问题了，当然，具体问题还是得具体分析。</p><p>如果服务部署成功了，且状态为running，那么就需要进入 Pod 内部的容器去查看自己的服务日志了：</p><ul><li>查看 Pod 内部容器打印的日志：</li></ul><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>kubectl logs <span class="token variable">${POD_NAME}</span>          \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul><li>进入 Pod 内部某个 container：</li></ul><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>  kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token variable">${POD_NAME}</span> <span class="token parameter variable">-c</span> <span class="token variable">${CONTAINER_NAME}</span> <span class="token punctuation">[</span>args<span class="token punctuation">]</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>​</p><p>这个命令的作用是通过 <code>kubectl</code>执行了<code>docker exec xxx</code>进入到容器实例内部。之后，就是用户检查自己服务的日志来定位问题。</p><h2 id="k8s真的放弃docker了吗" tabindex="-1"><a class="header-anchor" href="#k8s真的放弃docker了吗" aria-hidden="true">#</a> K8S真的放弃Docker了吗</h2><p>Docker作为非常流行的容器技术，之前经常有文章说它被K8S弃用了，取而代之的是另一种容器技术containerd！其实containerd只是从Docker中分离出来的底层容器运行时，使用起来和Docker并没有啥区别，从Docker转型containerd非常简单，基本没有什么门槛。只要把之前Docker命令中的docker改为crictl基本就可以了，都是同一个公司出品的东西，用法都一样。所以不管K8S到底弃用不弃用Docker，对我们开发者使用来说，基本没啥影响！</p><h3 id="k8s-cri" tabindex="-1"><a class="header-anchor" href="#k8s-cri" aria-hidden="true">#</a> K8S CRI</h3><p>K8S发布CRI（Container Runtime Interface），统一了容器运行时接口，凡是支持CRI的容器运行时，皆可作为K8S的底层容器运行时。</p><p>K8S为什么要放弃使用Docker作为容器运行时，而使用containerd呢？</p><p>如果你使用Docker作为K8S容器运行时的话，kubelet需要先要通过dockershim去调用Docker，再通过Docker去调用containerd。</p><p>如果你使用containerd作为K8S容器运行时的话，由于containerd内置了CRI插件，kubelet可以直接调用containerd。</p><p>使用containerd不仅性能提高了（调用链变短了），而且资源占用也会变小（Docker不是一个纯粹的容器运行时，具有大量其他功能）。</p><p>当然，未来Docker有可能自己直接实现K8S的CRI接口来兼容K8S的底层使用。</p><h2 id="部署项目" tabindex="-1"><a class="header-anchor" href="#部署项目" aria-hidden="true">#</a> 部署项目</h2>',23),r={href:"https://cloud.tencent.com/developer/article/1862330",target:"_blank",rel:"noopener noreferrer"},l=(0,s.Lk)("ul",null,[(0,s.Lk)("li",null,"将应用打包成docker镜像上传到本地仓库")],-1),t={},o=(0,n(66262).A)(t,[["render",function(e,a){const n=(0,s.g2)("OutboundLink");return(0,s.uX)(),(0,s.CE)(s.FK,null,[c,(0,s.Lk)("p",null,[(0,s.Lk)("a",r,[(0,s.eW)("简单！自己打包的 docker镜像，如何部署到本地 k8s 上？ - 腾讯云开发者社区-腾讯云 (tencent.com)"),(0,s.bF)(n)])]),l],64)}]])},66262:(e,a)=>{a.A=(e,a)=>{const n=e.__vccOpts||e;for(const[e,s]of a)n[e]=s;return n}}}]);
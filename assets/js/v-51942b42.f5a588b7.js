"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[91967],{15780:(n,s,o)=>{o.r(s),o.d(s,{data:()=>a});const a={key:"v-51942b42",path:"/concurrency/13%20Synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/concurrency/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"synchronized底层原理",slug:"synchronized底层原理",children:[]},{level:2,title:"Monitor监视器锁⭐",slug:"monitor监视器锁⭐",children:[]},{level:2,title:"同步方法的synchronized",slug:"同步方法的synchronized",children:[]},{level:2,title:"什么是monitor",slug:"什么是monitor",children:[]}],filePathRelative:"concurrency/13 Synchronized底层原理.md"}},19314:(n,s,o)=>{o.r(s),o.d(s,{default:()=>r});const a=(0,o(20641).Fv)('<h2 id="synchronized底层原理" tabindex="-1"><a class="header-anchor" href="#synchronized底层原理" aria-hidden="true">#</a> synchronized底层原理</h2><p><strong>synchronized内置锁是一种对象锁(锁的是对象而非引用)，作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的。</strong></p><ol><li><strong>synchronized是基于JVM</strong>内置锁实现，通过内部对象<strong>Monitor</strong>(监视器锁)实现，❤️基于进入与退出<strong>Monitor</strong>对象实现方法与代码块同步❤️，监视器锁的实现依赖底层操作系统的<strong>Mutex lock</strong>（互斥锁）实现，它是一个重量级锁性能较低。</li><li>当然，**JVM内置锁在1.5之后版本做了重大的优化，**如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等技术来减少锁操作的开销，内置锁的并发性能已经基本与Lock持平。</li></ol><p>❤️synchronized关键字被编译成字节码后会被翻译成monitorenter 和 monitorexit 两条指令分别在同步块逻辑代码的起始位置与结束位置❤️</p><p><img src="/images/concurrency/2512.png" alt="img"></p><p><strong>每个同步对象都有一个自己的Monitor(监视器锁)</strong>，加锁过程如下图所示</p><p><img src="/images/concurrency/2528.png" alt="img"></p><h2 id="monitor监视器锁⭐" tabindex="-1"><a class="header-anchor" href="#monitor监视器锁⭐" aria-hidden="true">#</a> Monitor监视器锁⭐</h2><p><strong>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态</strong>。Synchronized在JVM里的实现都是 <strong>基于进入和退出Monitor对象来实现方法同步和代码块同步</strong>，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p><ul><li><p><strong>monitorenter</strong>：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下</p><ol><li><strong>如果monitor的进入数为0</strong>，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者</li><li><strong>如果线程已经占有该monitor</strong>，只是重新进入，则进入monitor的进入数加1；</li><li><strong>如果其他线程已经占用了monitor</strong>，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li></ol></li><li><p><strong>monitorexit</strong>：执行monitorexit的线程必须是objectref所对应的monitor的所有者。<strong>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者</strong>。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p><ol><li><strong>monitorexit，指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁</strong>；</li></ol></li></ul><p>通过上面两段描述，我们应该能很清楚的看出Synchronized的实现原理，❤️<strong>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象</strong>，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，<strong>否则会抛出java.lang.IllegalMonitorStateException的异常的原因</strong>。❤️</p><h2 id="同步方法的synchronized" tabindex="-1"><a class="header-anchor" href="#同步方法的synchronized" aria-hidden="true">#</a> 同步方法的synchronized</h2><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedMethod</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>反编译结果</p><p><img src="/images/concurrency/image-20210620204330572.png" alt="image-20210620204330572"></p><p>从编译的结果来看，方法的同步并没有通过指令 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了 <strong>ACC_SYNCHRONIZED</strong> 标示符。<strong>JVM就是根据该标示符来实现方法的同步的</strong>：</p><p>当方法调用时，<strong>调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置</strong>，如果设置了，<strong>执行线程将先获取monitor</strong>，获取成功之后才能执行方法体，<strong>方法执行完后再释放monitor</strong>。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p><p>两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。<strong>两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度</strong>，会导致**“用户态和内核态”两个态之间来回切换**，对性能有较大影响。</p><h2 id="什么是monitor" tabindex="-1"><a class="header-anchor" href="#什么是monitor" aria-hidden="true">#</a> 什么是monitor</h2><ol><li>可以把它理解为 <strong>一个同步工具</strong>，也可以描述为 <strong>一种同步机制</strong>，它通常被 <strong>描述为一个对象</strong>。</li><li>❤️与一切皆对象一样，<strong>所有的Java对象是天生的Monitor</strong>，每一个Java对象都有成为Monitor的潜质，<strong>因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁</strong>。❤️</li><li><strong>也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址</strong>。</li></ol><p>在Java虚拟机（HotSpot）中，<strong>Monitor是由ObjectMonitor实现的</strong>，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token function">ObjectMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    _header       <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>\n    _count        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录个数</span>\n    _waiters      <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>\n    _recursions   <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    _object       <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>\n    _owner        <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>\n    _WaitSet      <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 处于wait状态的线程，会被加入到_WaitSet</span>\n    _WaitSetLock  <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>\n    _Responsible  <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>\n    _succ         <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>\n    _cxq          <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>\n    FreeNext      <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>\n    _EntryList    <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span> <span class="token comment">// 处于等待锁block状态的线程，会被加入到该列表</span>\n    _SpinFreq     <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>\n    _SpinClock    <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>\n    OwnerIsThread <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>ObjectMonitor中有两个队列，<strong>_WaitSet 和 _EntryList</strong>，用来保存ObjectWaiter对象列表（ <strong>每个等待锁的线程都会被封装成ObjectWaiter对象</strong> ），<strong>_owner指向持有ObjectMonitor对象的线程</strong>，当多个线程同时访问一段同步代码时：</p><ol><li>首先会进入 _EntryList 集合，<strong>当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1</strong>；</li><li>若线程调用 wait() 方法，<strong>将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒</strong>；</li><li>若当前线程执行完毕，<strong>也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)</strong>； <ol><li>同时，<strong>Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的</strong>，也是为什么Java中任意对象可以作为锁的原因，<strong>同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用</strong>。</li><li>监视器Monitor有两种同步方式：<strong>互斥与协作</strong>。多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，<strong>监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问</strong>。</li></ol></li></ol>',24),t={},r=(0,o(66262).A)(t,[["render",function(n,s){return a}]])},66262:(n,s)=>{s.A=(n,s)=>{const o=n.__vccOpts||n;for(const[n,a]of s)o[n]=a;return o}}}]);
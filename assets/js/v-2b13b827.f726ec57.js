"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[9519],{12148:(e,t,l)=>{l.r(t),l.d(t,{data:()=>i});const i={key:"v-2b13b827",path:"/sentinel/03%20sentinel.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/sentinel/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"流量控制",slug:"流量控制",children:[]},{level:2,title:"熔断降级",slug:"熔断降级",children:[]},{level:2,title:"系统负载保护",slug:"系统负载保护",children:[]},{level:2,title:"Sentinel工作流程",slug:"sentinel工作流程",children:[]}],filePathRelative:"sentinel/03 sentinel.md"}},40118:(e,t,l)=>{l.r(t),l.d(t,{default:()=>r});const i=(0,l(20641).Fv)('<h2 id="流量控制" tabindex="-1"><a class="header-anchor" href="#流量控制" aria-hidden="true">#</a> 流量控制</h2><p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示</p><p><img src="/images/sentinel/55449.png" alt="https://note.youdao.com/yws/public/resource/7ccbbecd48d3f995e3e36aab39a11049/xmlnote/0C689087E5364A1D91F71626342128F2/55449"></p><p>流量控制有以下几个角度:</p><ul><li>资源的调用关系，例如资源的调用链路，资源和资源之间的关系；</li><li>运行指标，例如 QPS、线程池、系统负载等；</li><li>控制的效果，例如直接限流、冷启动、排队等。</li></ul><p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。</p><h2 id="熔断降级" tabindex="-1"><a class="header-anchor" href="#熔断降级" aria-hidden="true">#</a> <strong>熔断降级</strong></h2><p>Sentinel 和 Hystrix 的原则是一致的: 当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果</p><p><img src="/images/sentinel/55453.png" alt="https://note.youdao.com/yws/public/resource/7ccbbecd48d3f995e3e36aab39a11049/xmlnote/7DE9A50C655F4F90A38E034DCB5606B6/55453"></p><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p><p>Hystrix 通过线程池的方式，来对依赖(在我们的概念中对应资源)进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本，还需要预先给各个资源做线程池大小的分配。</p><p>Sentinel 对这个问题采取了两种手段:</p><ul><li>通过并发线程数进行限制</li></ul><p>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p><ul><li>通过响应时间对资源进行降级</li></ul><p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p><h2 id="系统负载保护" tabindex="-1"><a class="header-anchor" href="#系统负载保护" aria-hidden="true">#</a> <strong>系统负载保护</strong></h2><p>Sentinel 同时提供系统维度的自适应保护能力。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p><p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p><h2 id="sentinel工作流程" tabindex="-1"><a class="header-anchor" href="#sentinel工作流程" aria-hidden="true">#</a> Sentinel工作流程</h2><p>在 Sentinel 里面，所有的资源都对应一个资源名称（resourceName），每次资源调用都会创建一个 Entry 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 SphU API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:</p><ul><li>NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li><li>ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li><li>StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；</li><li>FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li><li>AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li>DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；</li><li>SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li></ul><p><img src="/images/sentinel/54443.png" alt="https://note.youdao.com/yws/public/resource/7ccbbecd48d3f995e3e36aab39a11049/xmlnote/45B12EF8C4484FE58C41B9DF1B87DDEA/54443"></p><p>Sentinel 将 ProcessorSlot 作为 SPI 接口进行扩展（1.7.2 版本以前 SlotChainBuilder 作为 SPI），使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p><p>​ <img src="/images/sentinel/54447.png" alt="0"></p>',25),n={},r=(0,l(66262).A)(n,[["render",function(e,t){return i}]])},66262:(e,t)=>{t.A=(e,t)=>{const l=e.__vccOpts||e;for(const[e,i]of t)l[e]=i;return l}}}]);
"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[90797],{76731:(t,d,a)=>{a.r(d),a.d(d,{data:()=>n});const n={key:"v-09f01171",path:"/MySQL/19%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/MySQL/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"MySQL数据类型选择",slug:"mysql数据类型选择",children:[]},{level:2,title:"数值类型",slug:"数值类型",children:[{level:3,title:"优化建议",slug:"优化建议",children:[]},{level:3,title:"PS: INT显示宽度",slug:"ps-int显示宽度",children:[]}]},{level:2,title:"日期类型",slug:"日期类型",children:[{level:3,title:"优化建议",slug:"优化建议-1",children:[]}]},{level:2,title:"字符串",slug:"字符串",children:[{level:3,title:"优化建议",slug:"优化建议-2",children:[]}]},{level:2,title:"MySQL类型对应Java",slug:"mysql类型对应java",children:[{level:3,title:"varchar与char的区别❤️",slug:"varchar与char的区别❤️",children:[]}]}],filePathRelative:"MySQL/19 数据类型选择.md"}},64551:(t,d,a)=>{a.r(d),a.d(d,{default:()=>s});const n=(0,a(20641).Fv)('<h2 id="mysql数据类型选择" tabindex="-1"><a class="header-anchor" href="#mysql数据类型选择" aria-hidden="true">#</a> MySQL数据类型选择</h2><p>在MySQL中，选择正确的数据类型，对于性能至关重要。一般应该遵循下面两步：</p><p>（1）确定合适的大类型：数字、字符串、时间、二进制；</p><p>（2）确定具体的类型：有无符号、取值范围、变长定长等。</p><p>在MySQL数据类型设置方面，<strong>尽量用更小的数据类型，因为它们通常有更好的性能，花费更少的硬件资源。并且，尽量把字段定义为NOT NULL，避免使用NULL。</strong></p><hr><h2 id="数值类型" tabindex="-1"><a class="header-anchor" href="#数值类型" aria-hidden="true">#</a> 数值类型</h2><table><thead><tr><th>类型</th><th>大小</th><th>范围（有符号）</th><th>范围（无符号）</th><th>用途</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 字节</td><td>(-128, 127)</td><td>(0, 255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 字节</td><td>(-32 768, 32 767)</td><td>(0, 65 535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 字节</td><td>(-8 388 608, 8 388 607)</td><td>(0, 16 777 215)</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 字节</td><td>(-2 147 483 648, 2 147 483 647)</td><td>(0, 4 294 967 295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 字节</td><td>(-9 233 372 036 854 775 808, 9 223 372 036 854 775 807)</td><td>(0, 18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 字节</td><td>(-3.402 823 466 E+38, 1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td>0, (1.175 494 351 E-38, 3.402 823 466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8 字节</td><td>(1.797 693 134 862 315 7 E+308, 2.225 073 858 507 201 4 E-308), 0, (2.225 073 858 507 201 4 E-308, 1.797 693 134 862 315 7 E+308)</td><td>0, (2.225 073 858 507 201 4 E-308, 1.797 693 134 862 315 7 E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>依赖于M和D的值</td><td>依赖于M和D的值</td><td>小数值</td></tr></tbody></table><h3 id="优化建议" tabindex="-1"><a class="header-anchor" href="#优化建议" aria-hidden="true">#</a> 优化建议</h3><ol><li>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索 速度。 正例：无符号值可以避免误存负数，且扩大了表示范围。</li></ol><p><img src="/images/MySQL/image-20211028180308703.png" alt="image-20211028180308703"></p><ol start="2"><li>【强制】小数类型为 decimal，禁止使用 float 和 double。 说明：<strong>在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的 结果</strong>。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。</li><li>如果整形数据没有负数，如ID号，建议指定为UNSIGNED无符号类型，容量可以扩大一倍。</li><li>建议使用TINYINT代替ENUM、BITENUM、SET。</li><li>避免使用整数的显示宽度(参看文档最后)，也就是说，<strong>不要用INT(10)类似的方法指定字段显示宽度，直接用INT</strong>。</li></ol><h3 id="ps-int显示宽度" tabindex="-1"><a class="header-anchor" href="#ps-int显示宽度" aria-hidden="true">#</a> PS: <strong>INT显示宽度</strong></h3><p>我们经常会使用命令来创建数据表，而且同时会指定一个长度，如下。但是，这里的长度并非是TINYINT类型存储的最大长度，而是显示的最大长度。</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span><span class="token punctuation">(</span>\n    <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">TINYINT</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里表示user表的id字段的类型是TINYINT，可以存储的最大数值是255。所以，在存储数据时，如果存入值小于等于255，如200，虽然超过2位，但是没有超出TINYINT类型长度，所以可以正常保存；如果存入值大于255，如500，那么MySQL会自动保存为TINYINT类型的最大值255。</p><p>在查询数据时，不管查询结果为何值，都按实际输出。这里TINYINT(2)中2的作用就是，当需要在查询结果前填充0时，命令中加上ZEROFILL就可以实现，如：</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">TINYINT</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> ZEROFILL\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这样，查询结果如果是5，那输出就是05。如果指定TINYINT(5)，那输出就是00005，其实实际存储的值还是5，而且存储的数据不会超过255，只是MySQL输出数据时在前面填充了0。</p><p><strong>换句话说，在MySQL命令中，字段的类型长度TINYINT(2)、INT(11)不会影响数据的插入，只会在使用ZEROFILL时有用，让查询结果前填充0。</strong></p><hr><h2 id="日期类型" tabindex="-1"><a class="header-anchor" href="#日期类型" aria-hidden="true">#</a> 日期类型</h2><table><thead><tr><th>类型</th><th>大小(字节)</th><th>范围</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01 到 9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>&#39;-838:59:59&#39; 到 &#39;838:59:59&#39;</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901 到 2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00 到 9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00 到 2038-01-19 03:14:07</td><td>YYYYMMDDhhmmss</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><h3 id="优化建议-1" tabindex="-1"><a class="header-anchor" href="#优化建议-1" aria-hidden="true">#</a> 优化建议</h3><ol><li>MySQL能存储的最小时间粒度为秒。</li><li>建议用DATE数据类型来保存日期。<strong>MySQL中默认的日期格式是yyyy-mm-dd</strong>。</li><li>用MySQL的内建类型DATE、TIME、DATETIME来存储时间，而不是使用字符串。</li><li>当数据格式为TIMESTAMP和DATETIME时，可以用<strong>CURRENT_TIMESTAMP作为默认</strong>（MySQL5.6以后），MySQL会自动返回记录插入的确切时间。</li><li><strong>TIMESTAMP是UTC时间戳，与时区相关</strong>。</li><li>DATETIME的存储格式是一个YYYYMMDD HH:MM:SS的整数，与时区无关，你存了什么，读出来就是什么。</li><li>除非有特殊需求，<strong>一般的公司建议使用TIMESTAMP，它比DATETIME更节约空间</strong>，但是像阿里这样的公司一般会用DATETIME，因为不用考虑TIMESTAMP将来的时间上限问题。</li><li>有时人们把Unix的时间戳保存为整数值，但是这通常没有任何好处，这种格式处理起来不太方便，我们并不推荐它。</li></ol><p>【强制】表必备三字段：id, gmt_create, gmt_modified。 说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 datetime 类型</p><hr><h2 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串" aria-hidden="true">#</a> 字符串</h2><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255字节</td><td>定长字符串，char(n)当插入的字符数不足n时(n代表字符数)，插入空格进行补充保存。在进行检索时，尾部的空格会被去掉。</td></tr><tr><td>VARCHAR</td><td>0-65535 字节</td><td>变长字符串，varchar(n)中的n代表最大字符数，插入的字符数不足n时不会补充空格</td></tr><tr><td>TINYBLOB</td><td>0-255字节</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255字节</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535字节</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535字节</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215字节</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215字节</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295字节</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295字节</td><td>极大文本数据</td></tr></tbody></table><h3 id="优化建议-2" tabindex="-1"><a class="header-anchor" href="#优化建议-2" aria-hidden="true">#</a> 优化建议</h3><ol><li>字符串的长度相差较大用VARCHAR；字符串短，且所有值都接近一个长度用CHAR。</li><li>CHAR和VARCHAR适用于包括人名、邮政编码、电话号码和不超过255个字符长度的任意字母数字组合。那些要用来计算的数字不要用VARCHAR类型保存，因为可能会导致一些与计算相关的问题。换句话说，可能影响到计算的准确性和完整性。</li><li>尽量少用BLOB和TEXT，如果实在要用可以考虑将BLOB和TEXT字段单独存一张表，用id关联。</li><li>BLOB系列存储二进制字符串，与字符集无关。TEXT系列存储非二进制字符串，与字符集相关。</li><li>BLOB和TEXT都不能有默认值。</li></ol><p>【参考】因国际化需要，所有的字符存储与表示，均采用 utf8 字符集，那么字符计数方法需 要注意。 说明：</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code> <span class="token keyword">SELECT</span> LENGTH<span class="token punctuation">(</span><span class="token string">&quot;轻松工作&quot;</span><span class="token punctuation">)</span>； 返回为 <span class="token number">12</span>\n\n <span class="token keyword">SELECT</span> CHARACTER_LENGTH<span class="token punctuation">(</span><span class="token string">&quot;轻松工作&quot;</span><span class="token punctuation">)</span>； 返回为 <span class="token number">4</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="mysql类型对应java" tabindex="-1"><a class="header-anchor" href="#mysql类型对应java" aria-hidden="true">#</a> MySQL类型对应Java</h2><p><img src="/images/MySQL/types-mysql-java.png" alt="img"></p><table><thead><tr><th>Java类型</th><th>mysql类型</th></tr></thead><tbody><tr><td>int</td><td>int</td></tr><tr><td>Integer</td><td>int</td></tr><tr><td>double</td><td>double</td></tr><tr><td>Double</td><td>double</td></tr><tr><td>float</td><td>float</td></tr><tr><td>Float</td><td>float</td></tr><tr><td>long</td><td>bigint</td></tr><tr><td>Long</td><td>bigint</td></tr><tr><td>BigDecimal</td><td>decimal(19,2)</td></tr><tr><td>BigInt</td><td>decimal(19,2)</td></tr><tr><td>java.util.Date</td><td>datetime</td></tr><tr><td>java.sql.Date</td><td>date</td></tr><tr><td>LocalDateTime</td><td>datetime</td></tr><tr><td>LocalDate</td><td>date</td></tr><tr><td>String</td><td>varchar(255)</td></tr><tr><td>byte</td><td>tinyint</td></tr><tr><td>byte[]</td><td>tinyblob</td></tr><tr><td>short</td><td>smallint</td></tr><tr><td>boolean</td><td>bit(1)</td></tr><tr><td>char</td><td>char(1)</td></tr></tbody></table><h3 id="varchar与char的区别❤️" tabindex="-1"><a class="header-anchor" href="#varchar与char的区别❤️" aria-hidden="true">#</a> varchar与char的区别❤️</h3><p><strong>char的长度是不可变的，而varchar的长度是可变的</strong></p><p>定义一个char[10]和varchar[10]。</p><p>如果存进去的是‘tao’,那么char所占的长度依然为3，除了字符<code>tao</code>外，后面跟7个空格，varchar就立马把长度变为3了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。</p><p>❤️<strong>char的存取速度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找</strong>❤️</p><p>char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是<strong>以空间换取时间</strong>效率。</p><p>varchar是以空间效率为首位。</p><p><strong>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。</strong> <strong>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节</strong></p><p><strong>两者的存储数据都非unicode的字符数据</strong></p><p><strong>nchar和nvarchar是存储的unicode字符串数据</strong></p>',46),r={},s=(0,a(66262).A)(r,[["render",function(t,d){return n}]])},66262:(t,d)=>{d.A=(t,d)=>{const a=t.__vccOpts||t;for(const[t,n]of d)a[t]=n;return a}}}]);
"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[7144],{78810:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-4279d701",path:"/JVM/08%20%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/JVM/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"1. 对象内存分配",slug:"_1-对象内存分配",children:[{level:3,title:"对象一定分配在堆中吗",slug:"对象一定分配在堆中吗",children:[]}]},{level:2,title:"2. 对象在Eden区分配",slug:"_2-对象在eden区分配",children:[]},{level:2,title:"3. 对象在Eden区分配示例",slug:"_3-对象在eden区分配示例",children:[]},{level:2,title:"4. 大对象直接进入老年代",slug:"_4-大对象直接进入老年代",children:[]},{level:2,title:"5. 长期存活的对象将进入老年代",slug:"_5-长期存活的对象将进入老年代",children:[]},{level:2,title:"6. 对象动态年龄判断",slug:"_6-对象动态年龄判断",children:[]},{level:2,title:"7. 老年代空间分配担保机制",slug:"_7-老年代空间分配担保机制",children:[]},{level:2,title:"7. 日均百万级订单交易系统如何设置JVM参数",slug:"_7-日均百万级订单交易系统如何设置jvm参数",children:[]}],filePathRelative:"JVM/08 对象内存分配.md"}},50902:(n,s,a)=>{a.r(s),a.d(s,{default:()=>t});const e=(0,a(20641).Fv)('<h2 id="_1-对象内存分配" tabindex="-1"><a class="header-anchor" href="#_1-对象内存分配" aria-hidden="true">#</a> 1. 对象内存分配</h2><p><img src="/images/jvm/95092.png" alt="img"></p><h3 id="对象一定分配在堆中吗" tabindex="-1"><a class="header-anchor" href="#对象一定分配在堆中吗" aria-hidden="true">#</a> 对象一定分配在堆中吗</h3><p>不一定，对象还可以分配在栈上，对象栈上分配通常是指将对象引用分配到方法调用栈上，而不是在堆内存中分配对象的实例数据。这种分配方式主要涉及基于<strong>逃逸分析</strong>的优化技术。</p><p>逃逸分析是Java虚拟机的一种优化技术，用于分析对象的生命周期和作用域。如果分析表明某个对象的引用不会逃逸到方法调用栈之外，即不会被其他线程引用或返回给其他方法，那么Java虚拟机可能会将这个对象分配到栈上，而不是分配到堆内存中。</p><p>这样做的好处是可以显著提高对象的访问速度，因为栈上的对象引用可以更快地访问，而且不需要垃圾回收。但也需要注意以下几点：</p><ol><li><strong>对象的生命周期有限</strong>：对象栈上分配的对象的生命周期通常限制在方法调用期间。一旦方法返回，栈上的对象引用将失效，对象的数据也将被销毁。</li><li><strong>不适用于大对象</strong>：栈内存通常有限，不适合分配大型对象。对于较大的对象，仍然会分配在堆内存中。</li><li><strong>逃逸分析优化</strong>：逃逸分析是一个复杂的优化过程，Java虚拟机会根据分析结果来决定是否执行栈上分配。不是所有的对象都会被栈上分配，只有那些符合条件的对象才会被优化。</li><li><strong>多线程安全性</strong>：栈上分配的对象通常只能在创建它的线程中使用，不适合在多线程环境下共享。</li></ol><h2 id="_2-对象在eden区分配" tabindex="-1"><a class="header-anchor" href="#_2-对象在eden区分配" aria-hidden="true">#</a> 2. <strong>对象在Eden区分配</strong></h2><p>大多数情况下，对象在新生代中 Eden 区分配。<strong>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC</strong></p><ul><li><strong>Minor GC/Young GC</strong>：指发生<strong>新生代的的垃圾收集动作</strong>，Minor GC非常频繁，回收速度一般也比较快。</li><li><strong>Major GC/Full GC</strong>：一般会<strong>回收老年代 ，年轻代，方法区的垃圾</strong>，Major GC的速度一般会比Minor GC的慢10倍以上。</li></ul><p><strong>Eden与Survivor区默认8:1:1</strong></p><p>大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，<strong>让eden区尽量的大，survivor区够用即可</strong></p><p>VM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数<code>-XX:-UseAdaptiveSizePolicy</code></p><hr><h2 id="_3-对象在eden区分配示例" tabindex="-1"><a class="header-anchor" href="#_3-对象在eden区分配示例" aria-hidden="true">#</a> 3. 对象在Eden区分配示例</h2><blockquote><p>最初的分配到eden区</p></blockquote><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//添加运行JVM参数： -XX:+PrintGCDetails</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCTest</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token comment">/*, allocation3, allocation4, allocation5, allocation6*/</span><span class="token punctuation">;</span>\n        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">60000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//allocation2 = new byte[8000*1024];</span>\n\n      <span class="token comment">/*allocation3 = new byte[1000*1024];\n     allocation4 = new byte[1000*1024];\n     allocation5 = new byte[1000*1024];\n     allocation6 = new byte[1000*1024];*/</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token doc-comment comment">/**\n Heap\n PSYoungGen      total 75776K, used 65024K [0x000000076bb00000, 0x0000000770f80000, 0x00000007c0000000)\n     eden space 65024K, 100% used [0x000000076bb00000,0x000000076fa80000,0x000000076fa80000)\n     from space 10752K, 0% used [0x0000000770500000,0x0000000770500000,0x0000000770f80000)\n     to   space 10752K, 0% used [0x000000076fa80000,0x000000076fa80000,0x0000000770500000)\n ParOldGen       total 173568K, used 0K [0x00000006c3000000, 0x00000006cd980000, 0x000000076bb00000)\n    object space 173568K, 0% used [0x00000006c3000000,0x00000006c3000000,0x00000006cd980000)\n Metaspace       used 3366K, capacity 4496K, committed 4864K, reserved 1056768K\n    class space    used 358K, capacity 388K, committed 512K, reserved 1048576K\n */</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>我们可以看出eden区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用至少几M内存）。<strong>假如我们再为allocation2分配内存会出现什么情况呢？</strong></p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//添加运行JVM参数： -XX:+PrintGCDetails</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCTest</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token comment">/*, allocation3, allocation4, allocation5, allocation6*/</span><span class="token punctuation">;</span>\n        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">60000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n        allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">8000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n      <span class="token comment">/*allocation3 = new byte[1000*1024];\n     allocation4 = new byte[1000*1024];\n     allocation5 = new byte[1000*1024];\n     allocation6 = new byte[1000*1024];*/</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token doc-comment comment">/**\n Heap\n PSYoungGen      total 75776K, used 9450K [0x000000076bb00000, 0x0000000774f00000, 0x00000007c0000000)\n     eden space 65024K, 13% used [0x000000076bb00000,0x000000076c372a78,0x000000076fa80000)\n     from space 10752K, 7% used [0x000000076fa80000,0x000000076fb48030,0x0000000770500000)\n     to   space 10752K, 0% used [0x0000000774480000,0x0000000774480000,0x0000000774f00000)\n ParOldGen       total 173568K, used 60008K [0x00000006c3000000, 0x00000006cd980000, 0x000000076bb00000)\n     object space 173568K, 34% used [0x00000006c3000000,0x00000006c6a9a010,0x00000006cd980000)\n Metaspace       used 3367K, capacity 4496K, committed 4864K, reserved 1056768K\n    class space    used 358K, capacity 388K, committed 512K, reserved 1048576K\n */</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>因为给allocation2分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，GC期间虚拟机又发现allocation1无法存入Survior空间，所以只好把新生代的对象<strong>提前转移到老年代</strong>中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。</p><p>可以执行如下代码验证：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//添加运行JVM参数： -XX:+PrintGCDetails</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCTest</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">,</span> allocation3<span class="token punctuation">,</span> allocation4<span class="token punctuation">,</span> allocation5<span class="token punctuation">,</span> allocation6<span class="token punctuation">;</span>\n        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">60000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n        allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">8000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        allocation5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        allocation6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token doc-comment comment">/**\n Heap\n PSYoungGen      total 75776K, used 13788K [0x000000076bb00000, 0x0000000774f00000, 0x00000007c0000000)\n     eden space 65024K, 19% used [0x000000076bb00000,0x000000076c79f248,0x000000076fa80000)\n     from space 10752K, 8% used [0x000000076fa80000,0x000000076fb58030,0x0000000770500000)\n     to   space 10752K, 0% used [0x0000000774480000,0x0000000774480000,0x0000000774f00000)\n ParOldGen       total 173568K, used 60008K [0x00000006c3000000, 0x00000006cd980000, 0x000000076bb00000)\n    object space 173568K, 34% used [0x00000006c3000000,0x00000006c6a9a010,0x00000006cd980000)\n Metaspace       used 3367K, capacity 4496K, committed 4864K, reserved 1056768K\n    class space    used 358K, capacity 388K, committed 512K, reserved 1048576K\n */</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><hr><h2 id="_4-大对象直接进入老年代" tabindex="-1"><a class="header-anchor" href="#_4-大对象直接进入老年代" aria-hidden="true">#</a> 4. <strong>大对象直接进入老年代</strong></h2><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。</p><p>比如设置JVM参数：<code>-XX:PretenureSizeThreshold=1000000</code> (单位是字节) <code>-XX:+UseSerialGC</code> ，再执行下上面的第一个程序会发现大对象直接进了老年代</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象分配内存时的复制操作而降低效率。</p><hr><h2 id="_5-长期存活的对象将进入老年代" tabindex="-1"><a class="header-anchor" href="#_5-长期存活的对象将进入老年代" aria-hidden="true">#</a> 5. <strong>长期存活的对象将进入老年代</strong></h2><p>既然虚拟机采用了<strong>分代收集的思想来管理内存</strong>，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。</p><p>对象晋升到老年代的年龄阈值，可以通过参数 <strong>-XX:MaxTenuringThreshold</strong> 来设置。</p><hr><h2 id="_6-对象动态年龄判断" tabindex="-1"><a class="header-anchor" href="#_6-对象动态年龄判断" aria-hidden="true">#</a> 6. <strong>对象动态年龄判断</strong></h2><p>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时<strong>大于等于</strong>这批对象年龄最大值的对象，就可以<strong>直接进入老年代</strong>了，例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。<strong>对象动态年龄判断机制一般是在minor gc之后触发的。</strong></p><p>解决办法：增大年轻代</p><hr><h2 id="_7-老年代空间分配担保机制" tabindex="-1"><a class="header-anchor" href="#_7-老年代空间分配担保机制" aria-hidden="true">#</a> 7. <strong>老年代空间分配担保机制</strong></h2><ol><li><p>年轻代每次<strong>minor gc</strong>之前JVM都会计算下老年代<strong>剩余可用空间</strong></p></li><li><p>如果这个可用空间小于年轻代里现有的所有对象大小之和(<strong>包括垃圾对象</strong>)，就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了</p><p>2.1 如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的<strong>平均大小</strong>。</p><p>2.2 如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，<strong>如果回收完还是没有足够空间存放新的对象就会发生&quot;OOM&quot;</strong></p></li><li><p>当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”</p></li></ol><p><img src="/images/jvm/95124.png" alt="img"></p><h2 id="_7-日均百万级订单交易系统如何设置jvm参数" tabindex="-1"><a class="header-anchor" href="#_7-日均百万级订单交易系统如何设置jvm参数" aria-hidden="true">#</a> 7. <strong>日均百万级订单交易系统如何设置JVM参数</strong></h2><blockquote><p><strong>就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。</strong></p></blockquote><p><img src="/images/jvm/94575.png" alt="img"></p>',44),p={},t=(0,a(66262).A)(p,[["render",function(n,s){return e}]])},66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}}}]);
"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[22378],{44612:(e,i,s)=>{s.r(i),s.d(i,{data:()=>t});const t={key:"v-706a4d04",path:"/Redis/32%20Redis%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/Redis/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"Redis集群节点间通信机制",slug:"redis集群节点间通信机制",children:[]},{level:2,title:"集中式",slug:"集中式",children:[]},{level:2,title:"gossip",slug:"gossip",children:[{level:3,title:"gossip通信的10000端口",slug:"gossip通信的10000端口",children:[]}]},{level:2,title:"网络抖动",slug:"网络抖动",children:[]}],filePathRelative:"Redis/32 Redis集群节点间的通信机制.md"}},30529:(e,i,s)=>{s.r(i),s.d(i,{default:()=>r});const t=(0,s(20641).Fv)('<h2 id="redis集群节点间通信机制" tabindex="-1"><a class="header-anchor" href="#redis集群节点间通信机制" aria-hidden="true">#</a> Redis集群节点间通信机制</h2><p>Redis cluster节点间采取gossip协议进行通信</p><ul><li>维护集群的元数据(集群节点信息，主从角色，节点数量，各节点共享的数据等)有两种方式：集中式和gossip</li></ul><h2 id="集中式" tabindex="-1"><a class="header-anchor" href="#集中式" aria-hidden="true">#</a> 集中式</h2><ol><li><p>优点在于<strong>元数据的更新和读取，时效性非常好</strong>，一旦元数据出现变更立即就会更新到集中式的存储中，其他节点读取的时候立即就可以立即感知到；</p></li><li><p>不足在于所有的元数据的更新压力全部集中在一个地方，<strong>可能导致元数据的存储压力</strong>。</p></li></ol><p>很多中间件都会借助zookeeper集中式存储元数据。</p><h2 id="gossip" tabindex="-1"><a class="header-anchor" href="#gossip" aria-hidden="true">#</a> gossip</h2><p><img src="/images/Redis/101611.png" alt=""></p><p>gossip协议包含多种消息，包括ping，pong，meet，fail等等。</p><ol><li>meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信；</li><li>ping：每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据(类似自己感知到的集群节点增加和移除，hash slot信息等)；</li><li>pong: 对ping和meet消息的返回，包含自己的状态和其他信息，也可以用于信息广播和更新；</li><li>fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</li></ol><p>gossip协议的优点在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力；缺点在于元数据更新有延时可能导致集群的一些操作会有一些滞后。</p><h3 id="gossip通信的10000端口" tabindex="-1"><a class="header-anchor" href="#gossip通信的10000端口" aria-hidden="true">#</a> <strong>gossip通信的10000端口</strong></h3><p>每个节点都有一个专门用于节点间gossip通信的端口，就是自己提供服务的端口号+10000，比如8001，那么用于节点间通信的就是18001端口。 每个节点每隔一段时间都会往另外几个节点发送ping消息，同时其他几点接收到ping消息之后返回pong消息。</p><p><img src="/images/Redis/image-20211115052855712.png" alt=""></p><h2 id="网络抖动" tabindex="-1"><a class="header-anchor" href="#网络抖动" aria-hidden="true">#</a> <strong>网络抖动</strong></h2><p>真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又恢复正常。</p><p>为解决这种问题，Redis Cluster 提供了一种选项<code>cluster-node-timeout</code>，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。</p>',17),l={},r=(0,s(66262).A)(l,[["render",function(e,i){return t}]])},66262:(e,i)=>{i.A=(e,i)=>{const s=e.__vccOpts||e;for(const[e,t]of i)s[e]=t;return s}}}]);
"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[76216],{50942:(s,n,a)=>{a.r(n),a.d(n,{data:()=>e});const e={key:"v-1811783a",path:"/MySQL/14%20%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/MySQL/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"Limit使用",slug:"limit使用",children:[]},{level:2,title:"分页优化",slug:"分页优化",children:[{level:3,title:"根据自增且连续的主键排序的分页查询",slug:"根据自增且连续的主键排序的分页查询",children:[]},{level:3,title:"根据非主键字段排序的分页查询⭐",slug:"根据非主键字段排序的分页查询⭐",children:[]}]}],filePathRelative:"MySQL/14 分页查询优化.md"}},31017:(s,n,a)=>{a.r(n),a.d(n,{default:()=>l});const e=(0,a(20641).Fv)('<h2 id="limit使用" tabindex="-1"><a class="header-anchor" href="#limit使用" aria-hidden="true">#</a> Limit使用</h2><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">-- 从第一条记录开始查询，limit默认是从0开始的</span>\n<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>\n<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span>\n\n<span class="token comment">-- 从第六条记录开始查询10条</span>\n<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="分页优化" tabindex="-1"><a class="header-anchor" href="#分页优化" aria-hidden="true">#</a> 分页优化</h2><p>很多时候我们业务系统实现分页功能可能会用如下sql实现</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">limit</span> <span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。</p><h3 id="根据自增且连续的主键排序的分页查询" tabindex="-1"><a class="header-anchor" href="#根据自增且连续的主键排序的分页查询" aria-hidden="true">#</a> <strong>根据自增且连续的主键排序的分页查询</strong></h3><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">-- 0.054s</span>\n<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">limit</span> <span class="token number">90000</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 SQL 表示查询从第 90001开始的五行数据，没添加单独 order by，表示通过<strong>主键排序</strong>。我们再看表 employees ，<strong>因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 90001开始的五行数据</strong>，如下：</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">-- 0.038s</span>\n<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">where</span> id <span class="token operator">&gt;</span> <span class="token number">90000</span> <span class="token keyword">limit</span> <span class="token number">5</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>查询的结果是一致的。我们再对比一下执行计划：</p><p><img src="/images/MySQL/image-20211027215258906.png" alt="image-20211027215258906"></p><p><img src="/images/MySQL/image-20211027215238845.png" alt="image-20211027215238845"></p><p>显然改写后的 SQL 走了索引，而且扫描的行数大大减少，执行效率更高。</p><p>但是，<strong>这条改写的SQL 在很多场景并不实用</strong>，因为<strong>表中可能某些记录被删后，主键空缺，导致结果不一致</strong></p><h4 id="满足条件⭐" tabindex="-1"><a class="header-anchor" href="#满足条件⭐" aria-hidden="true">#</a> 满足条件⭐</h4><p>这种改写得满足以下两个条件：</p><ul><li>主键自增且连续</li><li>结果是按照主键排序的</li></ul><hr><h3 id="根据非主键字段排序的分页查询⭐" tabindex="-1"><a class="header-anchor" href="#根据非主键字段排序的分页查询⭐" aria-hidden="true">#</a> <strong>根据非主键字段排序的分页查询</strong>⭐</h3><p>再看一个根据非主键字段排序的分页查询，SQL 如下：</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">-- 0.592s</span>\n<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> name <span class="token keyword">limit</span> <span class="token number">90000</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="/images/MySQL/image-20211027215732415.png" alt="image-20211027215732415"></p><p>发现并没有使用 name 字段的索引（key 字段对应的值为 null），具体原因：<strong>扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引</strong>。</p><p>其实关键是<strong>让排序时返回的字段尽可能少</strong>，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，SQL改写如下</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">-- 0.047s</span>\n<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees e <span class="token keyword">inner</span> <span class="token keyword">join</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> employees <span class="token keyword">order</span> <span class="token keyword">by</span> name <span class="token keyword">limit</span> <span class="token number">90000</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> ed <span class="token keyword">on</span> e<span class="token punctuation">.</span>id <span class="token operator">=</span> ed<span class="token punctuation">.</span>id<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="/images/MySQL/image-20211027220145250.png" alt="image-20211027220145250"></p><p><strong>原 SQL 使用的是 filesort 排序，而优化后的 SQL 使用的是索引排序</strong></p>',28),p={},l=(0,a(66262).A)(p,[["render",function(s,n){return e}]])},66262:(s,n)=>{n.A=(s,n)=>{const a=s.__vccOpts||s;for(const[s,e]of n)a[s]=e;return a}}}]);
"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[35838],{12683:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-3f8d81ec",path:"/Algorithm/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/Algorithm/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"案例",slug:"案例",children:[]}],filePathRelative:"Algorithm/回溯算法.md"}},89866:(n,a,s)=>{s.r(a),s.d(a,{default:()=>k});var e=s(20641);const p=(0,e.Fv)('<p>回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。在探路的过程中一般使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。</p><p>从我们前面对回溯算法的说明可以看到，回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，只是在穷举的过程中可以根据一些条件避免无效的遍历，这个避免的过程也叫剪枝。</p><p>所以回溯法并不是什么很高效的算法，那么既然回溯法并不高效为什么还要用它呢？因为一些问题只能靠暴力搜索，没有更高效的解法。这些问题一般是什么样的问题呢？</p><p>组合问题：N个数里面按一定规则找出k个数的集合；</p><p>切割问题：一个字符串按一定规则有几种切割方式；</p><p>子集问题：一个N个数的集合里有多少符合条件的；</p><p>子集排列问题：N个数按一定规则全排列有几种排列方式；</p><p>棋盘问题：N皇后，解数独等等。</p><p>而回溯算法的题目一般有通用的解题步骤：</p><ol><li><p>定义一个解空间，它包含问题的解；</p></li><li><p>利用适于搜索的方法组织解空间，一般是个树；</p></li><li><p>利用深度优先法搜索解空间；</p></li><li><p>利用剪枝函数避免移动到不可能产生解的子空间。</p></li></ol><p>上面所说的解空间，一般会转化成树（即解空间树），也就是说回溯法解决的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，所以回溯法是在一颗高度有限的N叉树上进行遍历。</p><p>代码模板</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        存放结果<span class="token punctuation">;</span>\n        <span class="token keyword">return</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择：本层集合中元素<span class="token punctuation">(</span>树中节点孩子的数量就是集合的大小<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        处理节点<span class="token punctuation">;</span>\n        <span class="token function">backtrack</span><span class="token punctuation">(</span>新参数列表<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//递归处理当前节点下的子节点</span>\n        回溯，撤销处理结果\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="案例" tabindex="-1"><a class="header-anchor" href="#案例" aria-hidden="true">#</a> 案例</h2>',14),t={href:"https://q10viking.github.io/Algorithm/46%20%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%8E47%20%E5%85%A8%E6%8E%92%E5%88%972.html",target:"_blank",rel:"noopener noreferrer"},l={href:"https://q10viking.github.io/Algorithm/22%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.html#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95",target:"_blank",rel:"noopener noreferrer"},r={href:"https://q10viking.github.io/Algorithm/17%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html",target:"_blank",rel:"noopener noreferrer"},o={href:"https://q10viking.github.io/Algorithm/78%20%E5%AD%90%E9%9B%86%E5%90%88.html",target:"_blank",rel:"noopener noreferrer"},i={href:"https://q10viking.github.io/Algorithm/79%20%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D.html",target:"_blank",rel:"noopener noreferrer"},u={href:"https://q10viking.github.io/Algorithm/39%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html",target:"_blank",rel:"noopener noreferrer"},c={},k=(0,s(66262).A)(c,[["render",function(n,a){const s=(0,e.g2)("OutboundLink");return(0,e.uX)(),(0,e.CE)(e.FK,null,[p,(0,e.Lk)("p",null,[(0,e.Lk)("a",t,[(0,e.eW)("全排序"),(0,e.bF)(s)])]),(0,e.Lk)("p",null,[(0,e.Lk)("a",l,[(0,e.eW)("括号生成"),(0,e.bF)(s)])]),(0,e.Lk)("p",null,[(0,e.Lk)("a",r,[(0,e.eW)("电话号码组合"),(0,e.bF)(s)])]),(0,e.Lk)("p",null,[(0,e.Lk)("a",o,[(0,e.eW)("子集"),(0,e.bF)(s)])]),(0,e.Lk)("p",null,[(0,e.Lk)("a",i,[(0,e.eW)("搜素单词"),(0,e.bF)(s)])]),(0,e.Lk)("p",null,[(0,e.Lk)("a",u,[(0,e.eW)("组合总和"),(0,e.bF)(s)])])],64)}]])},66262:(n,a)=>{a.A=(n,a)=>{const s=n.__vccOpts||n;for(const[n,e]of a)s[n]=e;return s}}}]);
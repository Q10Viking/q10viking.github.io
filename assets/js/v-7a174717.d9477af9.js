"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[46075],{83806:(e,i,t)=>{t.r(i),t.d(i,{data:()=>a});const a={key:"v-7a174717",path:"/Redis/42%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/Redis/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"双写不一致情况",slug:"双写不一致情况",children:[]},{level:2,title:"读写并发不一致",slug:"读写并发不一致",children:[]},{level:2,title:"解决方案",slug:"解决方案",children:[]},{level:2,title:"总结",slug:"总结",children:[]}],filePathRelative:"Redis/42 缓存与数据库双写不一致.md"}},94677:(e,i,t)=>{t.r(i),t.d(i,{default:()=>l});const a=(0,t(20641).Fv)('<div class="custom-container tip"><p class="custom-container-title">TIP</p><p>在大并发下，同时操作数据库与缓存会存在数据不一致性问题。</p><p>缓存双写不一致是指在使用缓存的架构中，当数据更新时，由于缓存和数据库的写操作没有同步进行，导致数据在缓存和数据库之间出现不一致的情况。</p></div><h2 id="双写不一致情况" tabindex="-1"><a class="header-anchor" href="#双写不一致情况" aria-hidden="true">#</a> 双写不一致情况</h2><p><img src="/images/Redis/103029.png" alt=""></p><h2 id="读写并发不一致" tabindex="-1"><a class="header-anchor" href="#读写并发不一致" aria-hidden="true">#</a> 读写并发不一致</h2><p><img src="/images/Redis/103137.png" alt=""></p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h2><ol><li>对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</li><li>就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</li><li>❤️如果不能容忍缓存数据不一致，可以通过加<strong>读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读读的时候相当于无锁</strong>。(可以使用<strong>分布式锁</strong>)❤️</li><li>也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</li></ol><p><img src="/images/Redis/103108.png" alt=""></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> <strong>总结</strong></h2><p>以上我们针对的都是读多写少的情况加入缓存提高性能，如果写多读多的情况又不能容忍缓存数据不一致，那就没必要加缓存了，可以直接操作数据库。</p><p>❤️放入缓存的数据应该是对实时性、一致性要求不是很高的数据。切记不要为了用缓存，同时又要保证绝对的一致性做大量的过度设计和控制，增加系统复杂性！❤️</p>',11),r={},l=(0,t(66262).A)(r,[["render",function(e,i){return a}]])},66262:(e,i)=>{i.A=(e,i)=>{const t=e.__vccOpts||e;for(const[e,a]of i)t[e]=a;return t}}}]);
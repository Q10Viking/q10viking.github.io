"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[52146],{8019:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-61401077",path:"/concurrency/08%20volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E5%AE%9E%E7%8E%B0.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/concurrency/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[],filePathRelative:"concurrency/08 volatile内存语义实现.md"}},34419:(n,s,a)=>{a.r(s),a.d(s,{default:()=>t});const p=(0,a(20641).Fv)('<p>为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。</p><p>下图是JMM针对编译器制定的volatile重排序规则表。</p><table><thead><tr><th>第一个操作</th><th>第二个操作：普通读写</th><th>第二个操作：volatile读</th><th>第二个操作：volatile写</th></tr></thead><tbody><tr><td>普通读写</td><td>可以重排</td><td>可以重排</td><td>不可以重排</td></tr><tr><td>volatile读</td><td>不可以重排</td><td>不可以重排</td><td>不可以重排</td></tr><tr><td>volatile写</td><td>可以重排</td><td>不可以重排</td><td>不可以重排</td></tr></tbody></table><ol><li><p>当第一个为普通写，第二个也为普通写时，可以重排</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Jmm06_MemoryBarrier</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> m1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> m2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readAndWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n       <span class="token keyword">int</span> i <span class="token operator">=</span> m1<span class="token punctuation">;</span>   <span class="token comment">// 第一个volatile读</span>\n       <span class="token keyword">int</span> j <span class="token operator">=</span> m2<span class="token punctuation">;</span>   <span class="token comment">// 第二个volatile读</span>\n       <span class="token comment">//-------------------可以重排-----------------------------</span>\n       a <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>    <span class="token comment">// 普通写</span>\n\t   c <span class="token operator">=</span> <span class="token number">2</span>\n       <span class="token comment">//-------------------可以重排-----------------------------</span>\n       m1 <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 第一个volatile写</span>\n       m2 <span class="token operator">=</span> j <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">// 第二个 volatile写</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div></li><li><p>当第一个为普通读写，第二个为volatile读，可以重排</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Jmm06_MemoryBarrier</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> m1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> m2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readAndWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n       <span class="token keyword">int</span> i <span class="token operator">=</span> m1<span class="token punctuation">;</span>   <span class="token comment">// 第一个volatile读</span>\n       <span class="token keyword">int</span> j <span class="token operator">=</span> m2<span class="token punctuation">;</span>   <span class="token comment">// 第二个volatile读</span>\n       <span class="token comment">//-------------------可以重排-----------------------------</span>\n       a <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>    <span class="token comment">// 普通写</span>\n\t   c <span class="token operator">=</span> m1<span class="token punctuation">;</span>\t\t<span class="token comment">//\tvolatile读，普通写</span>\n       <span class="token comment">//-------------------可以重排-----------------------------</span>\n       m1 <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 第一个volatile写</span>\n       m2 <span class="token operator">=</span> j <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">// 第二个 volatile写</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ol start="3"><li><p>第一个为普通读写，第二个volatile写，不可以重排</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Jmm06_MemoryBarrier</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> m1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> m2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readAndWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n       <span class="token keyword">int</span> i <span class="token operator">=</span> m1<span class="token punctuation">;</span>   <span class="token comment">// 第一个volatile读</span>\n       <span class="token keyword">int</span> j <span class="token operator">=</span> m2<span class="token punctuation">;</span>   <span class="token comment">// 第二个volatile读</span>\n       <span class="token comment">//-------------------不可以重排-----------------------------</span>\n       a <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>    <span class="token comment">// 普通写</span>\n\t   m1 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\t\t<span class="token comment">//\tvolatile写</span>\n       <span class="token comment">//-------------------不可以重排-----------------------------</span>\n       m1 <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 第一个volatile写</span>\n       m2 <span class="token operator">=</span> j <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">// 第二个 volatile写</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ol start="4"><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li><li>当第一个操作是volatile写，第二个操作是volatile读或写时，不能重排序。</li></ol></li></ol></li></ol><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</p><blockquote><ul><li><ul><li>·在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>·在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>·在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>·在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul></li></ul></blockquote><p>volatile写<strong>插入内存屏障</strong>后生成的指令序列示意图</p><p><img src="/images/concurrency/14400" alt="img"></p><p>上面图中，StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作<strong>已经对任意处理器可见了</strong>。这是<strong>因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存</strong>。</p><p>这里比较有意思的是，volatile写后面的StoreLoad屏障。此屏障的作用是避免volatile写与 后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面 是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。<strong>为了保证能正确 实现volatile的内存语义，JMM在采取了保守策略</strong>：在每个volatile写的后面，或者在每个volatile 读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM最终选择了在每个 volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个 写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里可以看到JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p><hr><p>volatile读插入内存屏障后生成的指令序列示意图</p><p><img src="/images/concurrency/14399.png" alt="img"></p><p>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile写-读的内存语义，<strong>编译器可以根据具体情况省略不必要的屏障</strong>。下面通过具体的示例</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">VolatileBarrierExample</span> <span class="token punctuation">{</span>\n       <span class="token keyword">int</span> a<span class="token punctuation">;</span>\n       <span class="token keyword">volatile</span> <span class="token keyword">int</span> v1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n       <span class="token keyword">volatile</span> <span class="token keyword">int</span> v2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n       <span class="token keyword">void</span> <span class="token function">readAndWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n           <span class="token keyword">int</span> i <span class="token operator">=</span> v1<span class="token punctuation">;</span>　　    <span class="token comment">// 第一个volatile读</span>\n           <span class="token keyword">int</span> j <span class="token operator">=</span> v2<span class="token punctuation">;</span>    　  <span class="token comment">// 第二个volatile读</span>\n           a <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>         <span class="token comment">// 普通写</span>\n           v1 <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     　 <span class="token comment">// 第一个volatile写</span>\n          v2 <span class="token operator">=</span> j <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    　  <span class="token comment">// 第二个 volatile写</span>\n       <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化。</p><p><img src="/images/concurrency/14402.png" alt="img"></p><p>最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。<strong>此时编 译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器通常会在这里插 入一个StoreLoad屏障</strong>。</p>',18),e={},t=(0,a(66262).A)(e,[["render",function(n,s){return p}]])},66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,p]of s)a[n]=p;return a}}}]);
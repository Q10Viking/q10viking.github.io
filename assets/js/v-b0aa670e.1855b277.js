"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[79612],{43210:(e,t,i)=>{i.r(t),i.d(t,{data:()=>l});const l={key:"v-b0aa670e",path:"/concurrency/09%20happens-before%E5%8E%9F%E5%88%99.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/concurrency/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[],filePathRelative:"concurrency/09 happens-before原则.md"}},26264:(e,t,i)=>{i.r(t),i.d(t,{default:()=>o});const l=(0,i(20641).Fv)("<blockquote><p>只靠sychronized和volatile关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，从JDK 5开始，Java使用新的JSR-133内存模型，<strong>提供了happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据</strong>，happens-before 原则内容如下</p></blockquote><ol><li>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行</li><li>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)</li><li>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li><li>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</li><li>传递性 A先于B ，B先于C 那么A必然先于C</li><li>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li><li>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断</li><li>对象终结规则对象的构造函数执行，结束先于finalize()方法</li></ol>",2),r={},o=(0,i(66262).A)(r,[["render",function(e,t){return l}]])},66262:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,l]of t)i[e]=l;return i}}}]);
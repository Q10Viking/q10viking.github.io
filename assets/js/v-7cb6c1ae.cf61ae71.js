"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[85980],{80080:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-7cb6c1ae",path:"/Redis/16%20AOF-%E6%8C%81%E4%B9%85%E5%8C%96.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/Redis/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"AOF**（append-only file）**",slug:"aof-append-only-file",children:[]},{level:2,title:"配置允许AOF",slug:"配置允许aof",children:[]},{level:2,title:"AOF重写",slug:"aof重写",children:[{level:3,title:"重写频率相关配置",slug:"重写频率相关配置",children:[]},{level:3,title:"bgrewriteaof",slug:"bgrewriteaof",children:[]}]}],filePathRelative:"Redis/16 AOF-持久化.md"}},10950:(n,e,s)=>{s.r(e),s.d(e,{default:()=>p});var a=s(20641);const r=(0,a.Fv)('<h2 id="aof-append-only-file" tabindex="-1"><a class="header-anchor" href="#aof-append-only-file" aria-hidden="true">#</a> AOF**（append-only file）**</h2><p><strong>RDB快照功能并不是非常耐久</strong>（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么<strong>服务器将丢失最近写入、且仍未保存到快照中的那些数据</strong>。</p><p>从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化，将⭐<strong>修改的每一条指令记录进文件appendonly.aof</strong>⭐中(<strong>先写入os cache，每隔一段时间fsync到磁盘</strong>)</p><blockquote><p>比如执行命令**“set zhuge 666”**，aof文件里会记录如下数据</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>*3\n$3\nset\n$5\nzhuge\n$3\n666\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>⭐<strong>这是一种resp协议格式数据，星号后面的数字代表命令有多少个参数，$号后面的数字代表这个参数有几个字符</strong>⭐</p><p>注意，如果执行带过期时间的set命令，aof文件里记录的是并不是执行的原始命令，而是记录key过期的<strong>时间戳</strong></p><blockquote><p>比如执行**“set tuling 888 ex 1000”**，对应aof文件里记录如下</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>*3\n$3\nset\n$6\ntuling\n$3\n888\n*3\n$9\nPEXPIREAT\n$6\ntuling\n$13\n1604249786301\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="配置允许aof" tabindex="-1"><a class="header-anchor" href="#配置允许aof" aria-hidden="true">#</a> 配置允许AOF</h2><p>你可以通过修改配置文件来<strong>打开 AOF 功能</strong>：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code># appendonly yes\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div>',12),l={href:"http://redisdoc.com/string/set.html#set",target:"_blank",rel:"noopener noreferrer"},t=(0,a.Fv)('<p>你可以配置 <strong>Redis 多久才将数据 fsync 到磁盘一次</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。\nappendfsync everysec：每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。\nappendfsync no：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</strong></p><h2 id="aof重写" tabindex="-1"><a class="header-anchor" href="#aof重写" aria-hidden="true">#</a> <strong>AOF重写</strong></h2><p>AOF文件里可能有太多没用指令，所以AOF会定期根据<strong>内存的最新数据</strong>生成aof文件</p><blockquote><p>执行了如下几条命令：</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>127.0.0.1:6379&gt; incr readcount\n(integer) 1\n127.0.0.1:6379&gt; incr readcount\n(integer) 2\n127.0.0.1:6379&gt; incr readcount\n(integer) 3\n127.0.0.1:6379&gt; incr readcount\n(integer) 4\n127.0.0.1:6379&gt; incr readcount\n(integer) 5\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>重写后AOF文件里变成</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>*3\n$3\nSET\n$2\nreadcount\n$1\n5\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="重写频率相关配置" tabindex="-1"><a class="header-anchor" href="#重写频率相关配置" aria-hidden="true">#</a> 重写频率相关配置</h3><p>如下两个配置可以控制AOF自动重写频率</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># auto-aof-rewrite-min-size 64mb   //aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</span>\n<span class="token comment"># auto-aof-rewrite-percentage 100  //aof文件自上一次重写后文件大小增长了100%则再次触发重写</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="bgrewriteaof" tabindex="-1"><a class="header-anchor" href="#bgrewriteaof" aria-hidden="true">#</a> bgrewriteaof</h3><p>当然AOF还可以手动重写，进入redis客户端执行命令⭐<strong>bgrewriteaof</strong>⭐重写AOF</p><p>注意，<strong>AOF重写redis会fork出一个子进程去做(与bgsave命令类似)，不会对redis正常命令处理有太多影响</strong></p>',15),i={},p=(0,s(66262).A)(i,[["render",function(n,e){const s=(0,a.g2)("OutboundLink");return(0,a.uX)(),(0,a.CE)(a.FK,null,[r,(0,a.Lk)("p",null,[(0,a.eW)("从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 "),(0,a.Lk)("a",l,[(0,a.eW)("SET"),(0,a.bF)(s)]),(0,a.eW)("）， 这个命令就会被追加到 AOF 文件的末尾。这样的话， 当 Redis 重新启动时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。")]),t],64)}]])},66262:(n,e)=>{e.A=(n,e)=>{const s=n.__vccOpts||n;for(const[n,a]of e)s[n]=a;return s}}}]);
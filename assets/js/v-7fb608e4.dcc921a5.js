"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[59152],{89312:(e,r,o)=>{o.r(r),o.d(r,{data:()=>t});const t={key:"v-7fb608e4",path:"/cloudnative/01%20Docker%E4%BB%8B%E7%BB%8D.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/cloudnative/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"Docker的优点",slug:"docker的优点",children:[{level:3,title:"简化程序",slug:"简化程序",children:[]},{level:3,title:"避免选择恐惧症",slug:"避免选择恐惧症",children:[]},{level:3,title:"节省开支",slug:"节省开支",children:[]}]},{level:2,title:"Docker的架构⭐",slug:"docker的架构",children:[{level:3,title:"Docker daemon（ Docker守护进程）",slug:"docker-daemon-docker守护进程",children:[]},{level:3,title:"Client（ Docker客户端）",slug:"client-docker客户端",children:[]},{level:3,title:"Images（ Docker镜像）",slug:"images-docker镜像",children:[]},{level:3,title:"Container（容器）",slug:"container-容器",children:[]},{level:3,title:"Registry",slug:"registry",children:[]}]}],filePathRelative:"cloudnative/01 Docker介绍.md"}},62447:(e,r,o)=>{o.r(r),o.d(r,{default:()=>k});var t=o(20641);const c={class:"custom-container tip"},a=(0,t.Lk)("p",{class:"custom-container-title"},"TIP",-1),i={href:"https://www.docker.com/",target:"_blank",rel:"noopener noreferrer"},n={href:"https://hub.docker.com/",target:"_blank",rel:"noopener noreferrer"},s=(0,t.Lk)("p",null,[(0,t.eW)("Docker是一个开源的"),(0,t.Lk)("strong",null,"容器引擎"),(0,t.eW)("，它有助于更快地交付应用。 Docker可将应用程序和基础设施层隔离，并且能将基础设施当作程序一样进行管理。使用 Docker可更快地打包、测试以及部署应用程序，并可以缩短从编写到部署运行代码的周期。")],-1),l=(0,t.Fv)('<p><img src="/images/cloudnative/202112151643391.jpg" alt="202112151643391"></p><h2 id="docker的优点" tabindex="-1"><a class="header-anchor" href="#docker的优点" aria-hidden="true">#</a> Docker的优点</h2><h3 id="简化程序" tabindex="-1"><a class="header-anchor" href="#简化程序" aria-hidden="true">#</a> 简化程序</h3><p>Docker 让开发者可以打包他们的应用以及依赖包到一个<strong>可移植</strong>的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。</p><h3 id="避免选择恐惧症" tabindex="-1"><a class="header-anchor" href="#避免选择恐惧症" aria-hidden="true">#</a> 避免选择恐惧症</h3><p>如果你有选择恐惧症，还是资深患者。Docker 帮你 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了<strong>运行环境和配置</strong>，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。</p><h3 id="节省开支" tabindex="-1"><a class="header-anchor" href="#节省开支" aria-hidden="true">#</a> <strong>节省开支</strong></h3><p>一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p><h2 id="docker的架构" tabindex="-1"><a class="header-anchor" href="#docker的架构" aria-hidden="true">#</a> Docker的架构⭐</h2><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>1️⃣ 客户端</p><p>2️⃣ 服务端 宿主机有运行的容器Containers运行着镜像</p><p>3️⃣ 镜像仓库</p></div><p><img src="/images/cloudnative/202112151649256.jpg" alt="202112151649256"></p><h3 id="docker-daemon-docker守护进程" tabindex="-1"><a class="header-anchor" href="#docker-daemon-docker守护进程" aria-hidden="true">#</a> <strong>Docker daemon（ Docker守护进程）</strong></h3><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Docker daemon是一个运行在宿主机（ DOCKER-HOST）的后台进程。可通过 Docker客户端与之通信。</p></div><h3 id="client-docker客户端" tabindex="-1"><a class="header-anchor" href="#client-docker客户端" aria-hidden="true">#</a> <strong>Client（ Docker客户端）</strong></h3><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Docker客户端是 Docker的用户界面，它可以接受用户命令和配置标识，并与 Docker daemon通信。图中， docker build等都是 Docker的相关命令</p></div><h3 id="images-docker镜像" tabindex="-1"><a class="header-anchor" href="#images-docker镜像" aria-hidden="true">#</a> <strong>Images（ Docker镜像）</strong></h3><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Docker镜像是一个只读模板，它包含创建 Docker容器的说明。<strong>它和系统安装光盘有点像</strong>，使用系统安装光盘可以安装系统，同理，使用Docker镜像可以运行 Docker镜像中的程序。</p></div><h3 id="container-容器" tabindex="-1"><a class="header-anchor" href="#container-容器" aria-hidden="true">#</a> <strong>Container（容器）</strong></h3><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>容器是镜像的可运行实例。<strong>镜像和容器的关系有点类似于面向对象中，类和对象的关系</strong>。可通过 Docker API或者 CLI命令来启停、移动、删除容器。</p></div><h3 id="registry" tabindex="-1"><a class="header-anchor" href="#registry" aria-hidden="true">#</a> <strong>Registry</strong></h3><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Docker Registry是一个集中存储与分发镜像的服务。构建完 Docker镜像后，就可在当前宿主机上运行。但如果想要在其他机器上运行这个镜像，就需要手动复制。此时可借助 Docker Registry来避免镜像的手动复制。</p></div><p>一个 Docker Registry可包含多个 Docker仓库，每个仓库可包含多个镜像标签，每个标签对应一个 Docker镜像。这跟 Maven的仓库有点类似，如果把 Docker Registry比作 Maven仓库的话，那么 Docker仓库就可理解为某jar包的路径，而镜像标签则可理解为jar包的版本号。</p><p>Docker Registry可分为公有Docker Registry和私有Docker Registry。 最常⽤的Docker Registry莫过于官⽅的Docker Hub， 这也是默认的Docker Registry。 Docker Hub上存放着⼤量优秀的镜像， 我们可使⽤Docker命令下载并使⽤。</p>',23),d={},k=(0,o(66262).A)(d,[["render",function(e,r){const o=(0,t.g2)("OutboundLink");return(0,t.uX)(),(0,t.CE)(t.FK,null,[(0,t.Lk)("div",c,[a,(0,t.Lk)("p",null,[(0,t.Lk)("a",i,[(0,t.eW)("Empowering App Development for Developers | Docker"),(0,t.bF)(o)])]),(0,t.Lk)("p",null,[(0,t.Lk)("a",n,[(0,t.eW)("Docker Hub"),(0,t.bF)(o)]),(0,t.eW)(" 注册一个账号，我的是q10viking 1193094618@qq.com")]),s]),l],64)}]])},66262:(e,r)=>{r.A=(e,r)=>{const o=e.__vccOpts||e;for(const[e,t]of r)o[e]=t;return o}}}]);
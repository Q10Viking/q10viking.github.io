"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[94148],{54241:(e,i,l)=>{l.r(i),l.d(i,{data:()=>r});const r={key:"v-396b851b",path:"/SpringCloud/12%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/SpringCloud/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"分布式锁",slug:"分布式锁",children:[]},{level:2,title:"MySQL实现分布式锁",slug:"mysql实现分布式锁",children:[]}],filePathRelative:"SpringCloud/12 分布式锁.md"}},66558:(e,i,l)=>{l.r(i),l.d(i,{default:()=>a});const r=(0,l(20641).Fv)('<h2 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁" aria-hidden="true">#</a> 分布式锁</h2><ul><li><p>在单体的应用开发场景中涉及并发同步的时候，往往采用Synchronized（同步）或者其他同一个JVM内Lock机制来解决多线程间的同步问题。</p></li><li><p>在分布式集群工作的开发场景中，就需要一种更加高级的锁机制来处理跨机器的进程之间的数据同步问题，这种跨机器的锁就是分布式锁。</p></li></ul><p>目前分布式锁，比较成熟、主流的方案：</p><ol><li>基于数据库的分布式锁。db操作性能较差，并且有锁表的风险，一般不考虑</li><li>基于Redis的分布式锁。适用于并发量很大、性能要求很高而可靠性问题可以通过其他方案去弥补的场景</li><li>基于ZooKeeper的分布式锁。适用于高可靠（高可用），而并发量不是太高的场景</li></ol><h2 id="mysql实现分布式锁" tabindex="-1"><a class="header-anchor" href="#mysql实现分布式锁" aria-hidden="true">#</a> MySQL实现分布式锁</h2>',5),t={},a=(0,l(66262).A)(t,[["render",function(e,i){return r}]])},66262:(e,i)=>{i.A=(e,i)=>{const l=e.__vccOpts||e;for(const[e,r]of i)l[e]=r;return l}}}]);
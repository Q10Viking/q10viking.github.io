"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[46576],{27664:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-0c558f2a",path:"/spring/06%20aop.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"Spring AOP与AspectJ",slug:"spring-aop与aspectj",children:[]},{level:2,title:"@Lazy的动态代理",slug:"lazy的动态代理",children:[]}],filePathRelative:"spring/06 aop.md"}},52164:(n,e,s)=>{s.r(e),s.d(e,{default:()=>t});const a=(0,s(20641).Fv)('<h2 id="spring-aop与aspectj" tabindex="-1"><a class="header-anchor" href="#spring-aop与aspectj" aria-hidden="true">#</a> Spring AOP与AspectJ</h2><p>想用AspectJ的@Before等注解时。Spring得必须支持AspectJ的解析支持。</p><p>AnnotationAwareAspectJAutoProxyCreator</p><p>Spring会把五个注解解析为对应的Advice类：</p><ol><li>@Before：AspectJMethodBeforeAdvice，实际上就是一个MethodBeforeAdvice</li><li>@AfterReturning：AspectJAfterReturningAdvice，实际上就是一个AfterReturningAdvice</li><li>@AfterThrowing：AspectJAfterThrowingAdvice，实际上就是一个MethodInterceptor</li><li>@After：AspectJAfterAdvice，实际上就是一个MethodInterceptor</li><li>@Around：AspectJAroundAdvice，实际上就是一个MethodInterceptor</li></ol><h2 id="lazy的动态代理" tabindex="-1"><a class="header-anchor" href="#lazy的动态代理" aria-hidden="true">#</a> @Lazy的动态代理</h2><p>TargetSource</p><hr><p>cglib和jdk动态代理的选择</p><p>@EnableAspecj targetClass = true</p><p>exposeProxy AopContext</p><p>创建代理，执行代理（链路的创建）</p><p>advice通过适配封装为Interceptor</p><p>ThrowsAdviceInterceptor</p><p>执行</p><p>spring aop</p><p>解析，执行</p><hr><p>设计模式：</p><p>模板方法，责任链，代理，适配器</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">&quot;execution(public void com.zhouyu.service.UserService.test()) &amp;&amp; args(a,b)&quot;</span><span class="token punctuation">,</span>argNames<span class="token operator">=</span><span class="token string">&quot;a,b&quot;</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span><span class="token class-name">String</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">//....</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>@Aspect//作用是把当前类标识为一个切面供容器读取\n@Component\npublic class InterfaceLogAspect {\n\t//全路径是怕有重名的注解\n    @Around(&quot;@annotation(路径.InterfaceLog)&quot;)\n    public Object log(ProceedingJoinPoint pjp) throws Exception {\n}\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>',22),p={},t=(0,s(66262).A)(p,[["render",function(n,e){return a}]])},66262:(n,e)=>{e.A=(n,e)=>{const s=n.__vccOpts||n;for(const[n,a]of e)s[n]=a;return s}}}]);
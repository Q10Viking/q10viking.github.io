"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[13269],{50356:(i,n,e)=>{e.r(n),e.d(n,{data:()=>o});const o={key:"v-8188e670",path:"/spring/12%20%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E7%B1%BB.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/spring/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[],filePathRelative:"spring/12 解析配置类.md"}},74890:(i,n,e)=>{e.r(n),e.d(n,{default:()=>l});var o=e(20641);const t={href:"https://www.processon.com/view/link/614c83cae0b34d7b342f6d14",target:"_blank",rel:"noopener noreferrer"},r={href:"https://www.processon.com/view/link/5f9512d5e401fd06fda0b2dd",target:"_blank",rel:"noopener noreferrer"},s=(0,o.Fv)("<ol><li>在启动Spring时，需要传入一个AppConfig.class给ApplicationContext，ApplicationContext会根据AppConfig类封装为一个BeanDefinition，这种BeanDefinition我们把它称为配置类BeanDefinition。</li><li>ConfigurationClassPostProcessor中会把配置类BeanDefinition取出来</li><li>构造一个ConfigurationClassParser用来解析配置类BeanDefinition，并且会生成一个配置类对象ConfigurationClass</li><li>如果配置类上存在@Component注解，那么<strong>解析配置类中的内部类（这里有递归，如果内部类也是配置类的话）</strong></li><li>如果配置类上存在@PropertySource注解，那么则解析该注解，并得到PropertySource对象，并添加到environment中去</li><li>如果配置类上存在@ComponentScan注解，那么则解析该注解，进行扫描，扫描得到一系列的BeanDefinition对象，然后判断这些BeanDefinition是不是也是配置类BeanDefinition（只要存在@Component注解就是配置类，所以基本上扫描出来的都是配置类），如果是则继续解析该配置类，<strong>（也有递归）</strong>，并且会生成对应的ConfigurationClass</li><li>如果配置类上存在@Import注解，那么则判断Import的类的类型： <ol><li>如果是ImportSelector，那么调用执行selectImports方法得到类名，然后在把这个类当做配置类进行解析**（也是递归）**</li><li>如果是ImportBeanDefinitionRegistrar，那么则生成一个ImportBeanDefinitionRegistrar实例对象，并添加到配置类对象中（ConfigurationClass）的<strong>importBeanDefinitionRegistrars</strong>属性中。</li></ol></li><li>如果配置类上存在@ImportResource注解，那么则把导入进来的资源路径存在配置类对象中的<strong>importedResources</strong>属性中。</li><li>如果配置类中存在@Bean的方法，那么则把这些方法封装为BeanMethod对象，并添加到配置类对象中的<strong>beanMethods</strong>属性中。</li><li>如果配置类实现了某些接口，则看这些接口内是否定义了@Bean的默认方法</li><li>如果配置类有父类，则把父类当做配置类进行解析</li><li>AppConfig这个配置类会对应一个ConfigurationClass，同时在解析的过程中也会生成另外的一些ConfigurationClass，接下来就利用reader来进一步解析ConfigurationClass <ol><li>如果ConfigurationClass是通过@Import注解导入进来的，则把这个类生成一个BeanDefinition，同时解析这个类上@Scope,@Lazy等注解信息，并注册BeanDefinition</li><li>如果ConfigurationClass中存在一些BeanMethod，也就是定义了一些@Bean，那么则解析这些@Bean，并生成对应的BeanDefinition，并注册</li><li>如果ConfigurationClass中导入了一些资源文件，比如xx.xml，那么则解析这些xx.xml文件，得到并注册BeanDefinition</li><li>如果ConfigurationClass中导入了一些ImportBeanDefinitionRegistrar，那么则执行对应的registerBeanDefinitions进行BeanDefinition的注册</li></ol></li></ol>",1),a={},l=(0,e(66262).A)(a,[["render",function(i,n){const e=(0,o.g2)("OutboundLink"),a=(0,o.g2)("common-progresson-snippet");return(0,o.uX)(),(0,o.CE)(o.FK,null,[(0,o.Lk)("p",null,[(0,o.Lk)("a",t,[(0,o.eW)("配置类解析横向流程-ProcessOn"),(0,o.bF)(e)])]),(0,o.bF)(a,{src:"https://www.processon.com/view/link/614c83cae0b34d7b342f6d14"}),(0,o.Lk)("p",null,[(0,o.Lk)("a",r,[(0,o.eW)("Spring配置类解析流程"),(0,o.bF)(e)])]),(0,o.bF)(a,{src:"https://www.processon.com/view/link/5f9512d5e401fd06fda0b2dd"}),s],64)}]])},66262:(i,n)=>{n.A=(i,n)=>{const e=i.__vccOpts||i;for(const[i,o]of n)e[i]=o;return e}}}]);
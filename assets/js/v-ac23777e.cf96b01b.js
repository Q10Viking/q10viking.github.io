"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[50919],{6610:(e,i,r)=>{r.r(i),r.d(i,{data:()=>a});const a={key:"v-ac23777e",path:"/Lock/02%20Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E9%94%81%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/Lock/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"CAP角度分析redis和zk锁",slug:"cap角度分析redis和zk锁",children:[]},{level:2,title:"RedLock实现原理",slug:"redlock实现原理",children:[{level:3,title:"实现原理",slug:"实现原理",children:[]}]},{level:2,title:"存在问题",slug:"存在问题",children:[]}],filePathRelative:"Lock/02 Redis主从架构锁失效问题.md"}},54418:(e,i,r)=>{r.r(i),r.d(i,{default:()=>d});const a=(0,r(20641).Fv)('<h2 id="cap角度分析redis和zk锁" tabindex="-1"><a class="header-anchor" href="#cap角度分析redis和zk锁" aria-hidden="true">#</a> CAP角度分析redis和zk锁</h2><p>redis主从架构满足的是AP架构。主从切换会导致锁的失效。</p><p>zk leader节点收到数据之后，会同步到slave子节点，有半数以上的节点同步成功，leader节点才响应客户端。如果主节点挂了，那么子节点成为主节点，数据仍然在。</p><h2 id="redlock实现原理" tabindex="-1"><a class="header-anchor" href="#redlock实现原理" aria-hidden="true">#</a> RedLock实现原理</h2><p>针对redis主从架构可能失效的问题，出现了红锁的解决方案。</p><p>牺牲了性能了，但是保证了一致性。</p><h3 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理" aria-hidden="true">#</a> 实现原理</h3><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>绿色部分是主节点。并且这三个redis不是集群。</p></div><p><img src="/images/Redis/image-20220810150530278.png" alt="image-20220810150530278"></p><h2 id="存在问题" tabindex="-1"><a class="header-anchor" href="#存在问题" aria-hidden="true">#</a> 存在问题</h2><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>红锁不能百分之百解决redis主从架构的锁失效问题。</p></div><p>还是主从问题。redis如果有从节点，如redis2挂了，redis2的从节点没有同步redis2的数据，那么下个线程来加锁，还是能半数以上成功。</p>',12),t={},d=(0,r(66262).A)(t,[["render",function(e,i){return a}]])},66262:(e,i)=>{i.A=(e,i)=>{const r=e.__vccOpts||e;for(const[e,a]of i)r[e]=a;return r}}}]);
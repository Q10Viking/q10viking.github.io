"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[77871],{42434:(e,s,a)=>{a.r(s),a.d(s,{data:()=>n});const n={key:"v-5a5b380a",path:"/Redis/37%20%E9%94%AE%E5%80%BC%E8%AE%BE%E8%AE%A1-%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/Redis/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"key名设计",slug:"key名设计",children:[]},{level:2,title:"value设计",slug:"value设计",children:[]},{level:2,title:"bigkey的危害",slug:"bigkey的危害",children:[]},{level:2,title:"bigkey的产生",slug:"bigkey的产生",children:[]},{level:2,title:"如何优化bigkey",slug:"如何优化bigkey",children:[]}],filePathRelative:"Redis/37 键值设计-开发规范.md"}},639:(e,s,a)=>{a.r(s),a.d(s,{default:()=>i});const n=(0,a(20641).Fv)('<h2 id="key名设计" tabindex="-1"><a class="header-anchor" href="#key名设计" aria-hidden="true">#</a> <strong>key名设计</strong></h2><ol><li><p>【建议】: 可读性和可管理性</p><p>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>trade:order:1\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>【建议】：简洁性</p><p>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>user<span class="token operator">:</span><span class="token punctuation">{</span>uid<span class="token punctuation">}</span><span class="token operator">:</span>friends<span class="token operator">:</span>messages<span class="token operator">:</span><span class="token punctuation">{</span>mid<span class="token punctuation">}</span> 简化为 u<span class="token operator">:</span><span class="token punctuation">{</span>uid<span class="token punctuation">}</span><span class="token operator">:</span>fr<span class="token operator">:</span>m<span class="token operator">:</span><span class="token punctuation">{</span>mid<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>【强制】：不要包含特殊字符</p><p>反例：包含空格、换行、单双引号以及其他转义字符</p></li></ol><h2 id="value设计" tabindex="-1"><a class="header-anchor" href="#value设计" aria-hidden="true">#</a> <strong>value设计</strong></h2><ul><li>【强制】：拒绝bigkey(防止网卡流量、慢查询)</li></ul><p>在Redis中，一个字符串最大512MB，一个二级数据结构（例如hash、list、set、zset）可以存储大约40亿个(2^32-1)个元素，但实际中如果下面两种情况，我就会认为它是bigkey。</p><ol><li>字符串类型：它的big体现在单个value值很大，一般认为超过10KB就是bigkey。</li><li>非字符串类型：哈希、列表、集合、有序集合，它们的big体现在元素个数太多。</li></ol><blockquote><p><strong>一般来说，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</strong></p></blockquote><p>反例：一个包含200万个元素的list。</p><p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞）</p><h2 id="bigkey的危害" tabindex="-1"><a class="header-anchor" href="#bigkey的危害" aria-hidden="true">#</a> <strong>bigkey的危害</strong></h2><ol><li><p>导致redis阻塞</p></li><li><p>网络拥塞</p><blockquote><p>bigkey也就意味着每次获取要产生的网络流量较大，假设一个bigkey为1MB，客户端每秒访问量为1000，那么每秒产生1000MB的流量，对于普通的千兆网卡(按照字节算是128MB/s)的服务器来说简直是灭顶之灾，而且一般服务器会采用单机多实例的方式来部署，也就是说一个bigkey可能会对其他实例也造成影响，其后果不堪设想。</p></blockquote></li><li><p>过期删除</p><blockquote><p>有个bigkey，它安分守己（只执行简单的命令，例如hget、lpop、zscore等），但它设置了过期时间，当它过期后，会被删除，如果没有使用Redis 4.0的过期异步删除(<strong>lazyfree-lazy-expire yes</strong>)，就会存在阻塞Redis的可能性。</p></blockquote></li></ol><h2 id="bigkey的产生" tabindex="-1"><a class="header-anchor" href="#bigkey的产生" aria-hidden="true">#</a> <strong>bigkey的产生</strong></h2><p>一般来说，bigkey的产生都是由于程序设计不当，或者对于数据规模预料不清楚造成的，来看几个例子：</p><ol><li>社交类：粉丝列表，如果某些明星或者大v不精心设计下，必是bigkey。</li><li>统计类：例如按天存储某项功能或者网站的用户集合，除非没几个人用，否则必是bigkey。</li><li>缓存类：将数据从数据库load出来序列化放到Redis里，这个方式非常常用，但有两个地方需要注意，第一，是不是有必要把所有字段都缓存；第二，有没有相关关联的数据，有的同学为了图方便把相关数据都存一个key下，产生bigkey。</li></ol><h2 id="如何优化bigkey" tabindex="-1"><a class="header-anchor" href="#如何优化bigkey" aria-hidden="true">#</a> <strong>如何优化bigkey</strong></h2><ol><li><p>拆</p><p>big hash：可以讲数据分段存储，比如一个大的key，假设存了1百万的用户数据，可以拆分成200个key，每个key下面存放5000个用户数据</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>big list： list1、list2、<span class="token punctuation">..</span>.listN\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>如果bigkey不可避免，也要思考一下要不要每次把所有元素都取出来(例如有时候仅仅需要hmget，而不是hgetall)，删除也是一样，尽量使用优雅的方式来处理。</p></li><li><p>【推荐】：选择适合的数据类型。</p><p>例如：实体类型(要合理控制和使用数据结构，但也要注意节省内存和性能之间的平衡)</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 反例</span>\n<span class="token builtin class-name">set</span> user:1:name tom\n<span class="token builtin class-name">set</span> user:1:age <span class="token number">19</span>\n<span class="token builtin class-name">set</span> user:1:favor football\n<span class="token comment"># 正例</span>\nhmset user:1 name tom age <span class="token number">19</span> favor football\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li><li><p>【推荐】：<strong>控制key的生命周期，redis不是垃圾桶</strong>。</p><p>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)。</p></li></ol>',16),l={},i=(0,a(66262).A)(l,[["render",function(e,s){return n}]])},66262:(e,s)=>{s.A=(e,s)=>{const a=e.__vccOpts||e;for(const[e,n]of s)a[e]=n;return a}}}]);
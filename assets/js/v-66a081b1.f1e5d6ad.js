"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[32445],{76939:(n,s,a)=>{a.r(s),a.d(s,{data:()=>t});const t={key:"v-66a081b1",path:"/MySQL/16%20Join%E5%85%B3%E8%81%94%E4%BC%98%E5%8C%96.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/MySQL/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"mysql的表关联常见有两种算法",slug:"mysql的表关联常见有两种算法",children:[{level:3,title:"嵌套循环连接 Nested-Loop Join(NLJ) 算法",slug:"嵌套循环连接-nested-loop-join-nlj-算法",children:[]},{level:3,title:"基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法",slug:"基于块的嵌套循环连接-block-nested-loop-join-bnl-算法",children:[]}]},{level:2,title:"对于关联sql的优化",slug:"对于关联sql的优化",children:[]},{level:2,title:"对于小表定义的明确",slug:"对于小表定义的明确",children:[]},{level:2,title:"测试数据",slug:"测试数据",children:[]}],filePathRelative:"MySQL/16 Join关联优化.md"}},34162:(n,s,a)=>{a.r(s),a.d(s,{default:()=>p});const t=(0,a(20641).Fv)('<h2 id="mysql的表关联常见有两种算法" tabindex="-1"><a class="header-anchor" href="#mysql的表关联常见有两种算法" aria-hidden="true">#</a> <strong>mysql的表关联常见有两种算法</strong></h2><ul><li><p>Nested-Loop Join 算法</p></li><li><p>Block Nested-Loop Join 算法</p></li></ul><h3 id="嵌套循环连接-nested-loop-join-nlj-算法" tabindex="-1"><a class="header-anchor" href="#嵌套循环连接-nested-loop-join-nlj-算法" aria-hidden="true">#</a> <strong>嵌套循环连接</strong> <strong>Nested-Loop Join(NLJ) 算法</strong></h3><p>一次一行循环地从第一张表（称为<strong>驱动表</strong>）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（<strong>被驱动表</strong>）里取出满足条件的行，然后取出两张表的结果合集。</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">inner</span> <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a<span class="token operator">=</span> t2<span class="token punctuation">.</span>a<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><img src="/images/MySQL/image-20211028192758723.png" alt="image-20211028192758723"></p><p>从执行计划中可以看到这些信息：</p><ul><li>驱动表是 t2，被驱动表是 t1。先执行的就是驱动表(执行计划结果的id如果一样则按从上到下顺序执行sql)；优化器一般会优先选择**小表做驱动表，**用where条件过滤完驱动表，然后再跟被驱动表做关联查询。<strong>所以使用 inner join 时，排在前面的表并不一定就是驱动表。</strong></li><li>当使用left join时，左表是驱动表，右表是被驱动表，当使用right join时，右表时驱动表，左表是被驱动表，当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表。</li><li>使用了 NLJ算法。一般 join 语句中，如果执行计划 Extra 中未出现 <strong>Using join buffer</strong> ⭐则表示使用的 join 算法是 NLJ。</li></ul><h4 id="上面sql的大致流程如下" tabindex="-1"><a class="header-anchor" href="#上面sql的大致流程如下" aria-hidden="true">#</a> <strong>上面sql的大致流程如下：</strong></h4><ol><li>从表 t2 中读取一行数据（如果t2表有查询过滤条件的，用先用条件过滤完，再从过滤结果里取出一行数据）；</li><li>从第 1 步的数据中，取出关联字段 a，到表 t1 中查找；</li><li>取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端；</li><li>重复上面 3 步。</li></ol><p>整个过程会读取 t2 表的所有数据(<strong>扫描100行</strong>)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表中的对应行(<strong>扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100行</strong>)。因此整个过程扫描了 <strong>200 行</strong>。</p><p>如果被驱动表的关联字段没索引，<strong>使用NLJ算法性能会比较低(下面有详细解释)</strong>，mysql会选择Block Nested-Loop Join算法。</p><h3 id="基于块的嵌套循环连接-block-nested-loop-join-bnl-算法" tabindex="-1"><a class="header-anchor" href="#基于块的嵌套循环连接-block-nested-loop-join-bnl-算法" aria-hidden="true">#</a> <strong>基于块的嵌套循环连接</strong> <strong>Block Nested-Loop Join(BNL)算法</strong></h3><p>把<strong>驱动表</strong>的数据读入到 join_buffer 中，然后扫描<strong>被驱动表</strong>，把<strong>被驱动表</strong>每一行取出来跟 join_buffer 中的数据做对比。</p><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">inner</span> <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>b<span class="token operator">=</span> t2<span class="token punctuation">.</span>b<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><img src="/images/MySQL/image-20211028193337265.png" alt="image-20211028193337265"></p><p>Extra 中 的Using join buffer (Block Nested Loop)说明该关联查询使用的是 BNL 算法。</p><h4 id="上面sql的大致流程如下-1" tabindex="-1"><a class="header-anchor" href="#上面sql的大致流程如下-1" aria-hidden="true">#</a> <strong>上面sql的大致流程如下：</strong></h4><ol><li>把 t2 的所有数据放入到 <strong>join_buffer</strong> 中</li><li>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比</li><li>返回满足 join 条件的数据</li></ol><p>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = <strong>10100</strong>。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= <strong>100 万次</strong>。</p><p>这个例子里表 t2 才 100 行，要是表 t2 是一个大表，join_buffer 放不下怎么办呢？·</p><p>join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t2 的所有数据话，策略很简单，就是<strong>分段放</strong>。</p><p>比如 t2 表有1000行记录， join_buffer 一次只能放800行数据，那么执行过程就是先往 join_buffer 里放800行记录，然后从 t1 表里取数据跟 join_buffer 中数据对比得到部分结果，然后清空 join_buffer ，再放入 t2 表剩余200行记录，再次从 t1 表里取数据跟 join_buffer 中数据对比。所以就多扫了一次 t1 表。</p><p>⭐<strong>被驱动表的关联字段没索引为什么要选择使用 BNL 算法而不使用 Nested-Loop Join 呢？</strong></p><p>如果上面第二条sql使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = 100万次，这个是<strong>磁盘扫描</strong>。</p><p>很显然，用BNL磁盘扫描次数少很多，相比于磁盘扫描，<strong>BNL的内存计算会快得多</strong>。</p><p>因此MySQL对于被驱动表的关联字段没索引的关联查询，一般都会使用 BNL 算法。如果有索引一般选择 NLJ 算法，有索引的情况下 NLJ 算法比 BNL算法性能更高</p><h2 id="对于关联sql的优化" tabindex="-1"><a class="header-anchor" href="#对于关联sql的优化" aria-hidden="true">#</a> <strong>对于关联sql的优化</strong></h2><ul><li><strong>关联字段加索引</strong>，让mysql做join操作时尽量选择NLJ算法，驱动表因为需要全部查询出来，所以过滤的条件也尽量要走索引，避免全表扫描，总之，能走索引的过滤条件尽量都走索引</li><li><strong>小表驱动大表</strong>，写多表连接sql时如果<strong>明确知道</strong>哪张表是小表可以用straight_join写法固定连接驱动方式，省去mysql优化器自己判断的时间</li></ul><p><strong>straight_join解释：straight_join</strong>功能同join类似，但能让左边的表来驱动右边的表，能改表优化器对于联表查询的执行顺序。</p><p>比如：select * from t2 straight_join t1 on t2.a = t1.a; 代表指定mysql选着 t2 表作为驱动表。</p><ul><li><strong>straight_join</strong>只适用于inner join，并不适用于left join，right join。（因为left join，right join已经代表指定了表的执行顺序）</li><li>尽可能让优化器去判断，因为大部分情况下mysql优化器是比人要聪明的。使用<strong>straight_join</strong>一定要慎重，因为部分情况下人为指定的执行顺序并不一定会比优化引擎要靠谱。</li></ul><h2 id="对于小表定义的明确" tabindex="-1"><a class="header-anchor" href="#对于小表定义的明确" aria-hidden="true">#</a> <strong>对于小表定义的明确</strong></h2><p>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，<strong>过滤完成之后</strong>，计算参与 join 的各个字段的总数据量，<strong>数据量小的那个表，就是“小表”</strong>，应该作为驱动表。</p><h2 id="测试数据" tabindex="-1"><a class="header-anchor" href="#测试数据" aria-hidden="true">#</a> 测试数据</h2><div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">-- 示例表：</span>\n<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>a<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>b<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>a<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>\n\n<span class="token keyword">create</span> <span class="token keyword">table</span> t2 <span class="token operator">like</span> t1<span class="token punctuation">;</span>\n\n\n<span class="token comment">-- t1生成10000条数据</span>\n<span class="token keyword">CREATE</span> <span class="token keyword">DEFINER</span><span class="token operator">=</span><span class="token identifier"><span class="token punctuation">`</span>root<span class="token punctuation">`</span></span><span class="token variable">@`%`</span> <span class="token keyword">PROCEDURE</span> <span class="token identifier"><span class="token punctuation">`</span>t_generate<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token operator">IN</span> <span class="token identifier"><span class="token punctuation">`</span>num<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">)</span>\n<span class="token keyword">BEGIN</span>\n\t<span class="token comment">#Routine body goes here...</span>\n\t<span class="token keyword">while</span> num <span class="token operator">&lt;=</span> <span class="token number">10000</span> <span class="token keyword">do</span>   \n\t  <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">set</span> num<span class="token operator">=</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  \n\t<span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span>\n<span class="token keyword">END</span>\n\n<span class="token comment">-- t2生成100条数据</span>\n<span class="token keyword">CREATE</span> <span class="token keyword">DEFINER</span><span class="token operator">=</span><span class="token identifier"><span class="token punctuation">`</span>root<span class="token punctuation">`</span></span><span class="token variable">@`%`</span> <span class="token keyword">PROCEDURE</span> <span class="token identifier"><span class="token punctuation">`</span>t_generate<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token operator">IN</span> <span class="token identifier"><span class="token punctuation">`</span>num<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">)</span>\n<span class="token keyword">BEGIN</span>\n\t<span class="token comment">#Routine body goes here...</span>\n\t<span class="token keyword">while</span> num <span class="token operator">&lt;=</span> <span class="token number">100</span> <span class="token keyword">do</span>   \n\t  <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t2<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">set</span> num<span class="token operator">=</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  \n\t<span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span>\n<span class="token keyword">END</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div>',36),e={},p=(0,a(66262).A)(e,[["render",function(n,s){return t}]])},66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,t]of s)a[n]=t;return a}}}]);
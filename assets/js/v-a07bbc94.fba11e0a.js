"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[10034],{86986:(e,o,i)=>{i.r(o),i.d(o,{data:()=>l});const l={key:"v-a07bbc94",path:"/zk/04%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/zk/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[],filePathRelative:"zk/04 文件系统数据结构.md"}},27396:(e,o,i)=>{i.r(o),i.d(o,{default:()=>t});const l=(0,i(20641).Fv)('<p>Zookeeper维护一个类似文件系统的数据结构：</p><img src="/images/zk/image-20210426150533144.png" alt="image-20210426150533144"><p>每个子目录项都被称作为 <strong>znode(目录节点)</strong>，和文件系统类似，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode。</p><p>有四种类型的znode：</p><ol><li><p>PERSISTENT-持久化目录节点</p><ol><li>客户端与zookeeper断开连接后，该节点依旧存在，只要不手动删除该节点，他将<strong>永远存在</strong></li></ol></li><li><p>PERSISTENT_SEQUENTIAL-持久化顺序编号节点</p><ol><li>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称<strong>进行顺序编号</strong></li></ol></li><li><p>EPHEMERAL-临时目录节点</p><ol><li>客户端与zookeeper断开连接后，该节点被删除</li></ol></li><li><p>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</p><ol><li>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</li></ol></li><li><p>Container节点</p><ol><li>如果<strong>Container节点下面没有子节点</strong>，则Container节点在未来会被Zookeeper<strong>自动清除</strong>,定时任务默认60s 检查一次</li><li>Container节点 (3.5.3版本新增)：Container容器节点，当容器中没有任何子节点，该容器节点会被zk定期删除（定时任务默认60s 检查一次)。 和持久节点的区别是 ZK 服务端启动后，会有一个单独的线程去扫描，所有的容器节点，当发现容器节点的子节点数量为 0 时，会自动删除该节点。<strong>可以用于 leader 或者锁的场景中</strong></li></ol></li><li><p>TTL节点</p><ol><li>( 默认禁用，只能通过系统配置 <em>zookeeper.extendedTypesEnabled=true</em> 开启，不稳定)</li></ol></li></ol><img src="/images/zk/25510.png" alt="img"><img src="/images/zk/image-20210429185829067.png" alt="image-20210429185829067">',7),r={},t=(0,i(66262).A)(r,[["render",function(e,o){return l}]])},66262:(e,o)=>{o.A=(e,o)=>{const i=e.__vccOpts||e;for(const[e,l]of o)i[e]=l;return i}}}]);
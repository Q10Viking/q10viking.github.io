"use strict";(self.webpackChunkq10viking_github_io=self.webpackChunkq10viking_github_io||[]).push([[47667],{43859:(e,r,t)=>{t.r(r),t.d(r,{data:()=>a});const a={key:"v-96bc9e74",path:"/JVM/13%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.html",title:"",lang:"zh-CN",frontmatter:{sidebarDepth:3,sidebar:"auto",prev:{text:"Back To 目录",link:"/JVM/"},"typora-root-url":"..\\.vuepress\\public"},excerpt:"",headers:[{level:2,title:"垃圾收集算法",slug:"垃圾收集算法",children:[]},{level:2,title:"分代收集理论",slug:"分代收集理论",children:[]},{level:2,title:"复制算法",slug:"复制算法",children:[]},{level:2,title:"标记-清除算法",slug:"标记-清除算法",children:[]},{level:2,title:"标记-整理算法",slug:"标记-整理算法",children:[]}],filePathRelative:"JVM/13 垃圾收集算法.md"}},97751:(e,r,t)=>{t.r(r),t.d(r,{default:()=>n});const a=(0,t(20641).Fv)('<h2 id="垃圾收集算法" tabindex="-1"><a class="header-anchor" href="#垃圾收集算法" aria-hidden="true">#</a> 垃圾收集算法</h2><p><img src="/images/jvm/95317.png" alt="img"></p><h2 id="分代收集理论" tabindex="-1"><a class="header-anchor" href="#分代收集理论" aria-hidden="true">#</a> 分代收集理论</h2><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。<strong>一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法</strong>。</p><p>比如<strong>在新生代中，每次收集都会有大量对象(近99%)死去</strong>，所以可以<strong>选择复制算法</strong>，只需要<strong>付出少量对象的复制成本</strong>就可以完成每次垃圾收集。</p><p>而老年代的对象存活几率是比较高的，而且<strong>没有额外的空间对它进行分配担保</strong>，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法<strong>慢10倍以上</strong>。</p><hr><h2 id="复制算法" tabindex="-1"><a class="header-anchor" href="#复制算法" aria-hidden="true">#</a> 复制算法</h2><blockquote><p>空间换时间的思想，内存利用率不高，需要额外划分一块内存</p></blockquote><p>为了解决效率问题，“复制”收集算法出现了。<strong>它可以将内存分为大小相同的两块</strong>，每次使用其中的一块。</p><p>当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使<strong>每次的内存回收都是对内存区间的一半进行回收</strong>。</p><p><img src="/images/jvm/95776.png" alt="img"></p><h2 id="标记-清除算法" tabindex="-1"><a class="header-anchor" href="#标记-清除算法" aria-hidden="true">#</a> 标记-清除算法</h2><p>算法分为“标记”和“清除”阶段：<strong>标记存活的对象</strong>， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，<strong>在标记完成后统一回收所有被标记的对象</strong> 。</p><p>它是最基础的收集算法，比较简单，但是会带来两个明显的问题</p><ol><li><strong>效率问题 (如果需要标记的对象太多，效率不高)</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><p><img src="/images/jvm/94592.png" alt="img"></p><h2 id="标记-整理算法" tabindex="-1"><a class="header-anchor" href="#标记-整理算法" aria-hidden="true">#</a> 标记-整理算法</h2><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="/images/jvm/94590" alt="img"></p>',20),i={},n=(0,t(66262).A)(i,[["render",function(e,r){return a}]])},66262:(e,r)=>{r.A=(e,r)=>{const t=e.__vccOpts||e;for(const[e,a]of r)t[e]=a;return t}}}]);
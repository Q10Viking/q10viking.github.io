---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /java/
typora-root-url: ..\.vuepress\public
---



## 克隆

### 背景

普通的对象复制，存在的问题，如下代码

```java
public class CloneTest {
    public static void main(String[] args) {
        // 等号赋值（ 基本类型）
        int number = 6;
        int number2 = number;
        // 修改 number2 的值
        number2 = 9;
        System.out.println("number：" + number);
        System.out.println("number2：" + number2);
        // 等号赋值（对象）
        Dog dog = new Dog();
        dog.name = "旺财";
        dog.age = 5;
        Dog dog2 = dog;
        // 修改 dog2 的值
        dog2.name = "大黄";
        dog2.age = 3;
        System.out.println(dog.name + "，" + dog.age + "岁");
        System.out.println(dog2.name + "，" + dog2.age + "岁");
    }
}
/**
 * number：6
 * number2：9
 * 大黄，3岁
 * 大黄，3岁
 */
```

> 可以看到再dog2中修改名字直接影响到了dog对象，这是因为他们引用的都是堆上同一个对象

![](/images/java/21bdbb00-c95b-11e9-80ba-3b9ebd4a5c21.png)

## 浅拷贝

两步骤

1. 实现`Cloneable`接口，这只是一个标记接口，里面并没有方法

   ```java
   public interface Cloneable {
   }
   ```

2. 覆盖Object中的clone方法，这个方法默认是protected类型，我们将它改为public，一边外界能够访问。注意：如果没有实现`Cloneable`接口，jvm会抛出异常`CloneNotSupportedException`

   ```java
   public class Object{
       // 是一个native方法
       protected native Object clone() throws CloneNotSupportedException;
   }
   ```

   

> 实现

```java
@Data
@AllArgsConstructor
public class User implements Cloneable{
    public String name;
    public int age;

    // 重写clone方法
    @Override
    public User clone() throws CloneNotSupportedException {
        return (User)super.clone();
    }
}
```

> 测试

```java
public class ShallowClone {
    public static void main(String[] args) throws CloneNotSupportedException {
       User user = new User("张三", 18);
       User user2 = user.clone();
       user2.setName("Q10Viking");
        System.out.println(user);
        System.out.println(user2);
    }
}
/**
 * User(name=张三, age=18)
 * User(name=Q10Viking, age=18)
 */
```



### 存在的问题

如果对象的属性还引用了其他对象，那么浅拷贝只会复制这个对象的引用地址。

```java
@Data
@AllArgsConstructor
public class User implements Cloneable{
    private String name;
    private City city;

    @Override
    public User clone() throws CloneNotSupportedException {
        return (User)super.clone();
    }
}

@Data
@AllArgsConstructor
public class City {
    private String name;
}
```

> 测试

```java
public class ShallowProblemTest {
    public static void main(String[] args) throws CloneNotSupportedException {
        User user = new User("张三", new City("北京"));
        User user2 = user.clone();

        user2.setName("Q10Viking");
        user2.getCity().setName("广州");

        System.out.println(user);
        System.out.println(user2);
    }
}
/**
 * User(name=张三, city=City(name=广州))
 * User(name=Q10Viking, city=City(name=广州))
 */
```

> 可以user2改变City，影响到了user的city,但是name不受影响

## 深拷贝

深克隆就是复制整个对象信息，包含值类型和引用类型
---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /java/
typora-root-url: ..\.vuepress\public
---



## 克隆

### 背景

普通的对象复制，存在的问题，如下代码

```java
public class CloneTest {
    public static void main(String[] args) {
        // 等号赋值（ 基本类型）
        int number = 6;
        int number2 = number;
        // 修改 number2 的值
        number2 = 9;
        System.out.println("number：" + number);
        System.out.println("number2：" + number2);
        // 等号赋值（对象）
        Dog dog = new Dog();
        dog.name = "旺财";
        dog.age = 5;
        Dog dog2 = dog;
        // 修改 dog2 的值
        dog2.name = "大黄";
        dog2.age = 3;
        System.out.println(dog.name + "，" + dog.age + "岁");
        System.out.println(dog2.name + "，" + dog2.age + "岁");
    }
}
/**
 * number：6
 * number2：9
 * 大黄，3岁
 * 大黄，3岁
 */
```

> 可以看到再dog2中修改名字直接影响到了dog对象，这是因为他们引用的都是堆上同一个对象

![](/images/java/21bdbb00-c95b-11e9-80ba-3b9ebd4a5c21.png)

## 浅拷贝

两步骤

1. 实现`Cloneable`接口，这只是一个标记接口，里面并没有方法。注意：实现了这个接口，必须要覆盖Object的clone方法

   ```java
   public interface Cloneable {
   }
   ```

2. 覆盖Object中的clone方法，这个方法默认是protected类型，我们将它改为public，一边外界能够访问。注意：如果没有实现`Cloneable`接口，jvm会抛出异常`CloneNotSupportedException`

   ```java
   public class Object{
       // 是一个native方法
       protected native Object clone() throws CloneNotSupportedException;
   }
   ```

   

> 实现

```java
@Data
@AllArgsConstructor
public class User implements Cloneable{
    public String name;
    public int age;

    // 重写clone方法
    @Override
    public User clone() throws CloneNotSupportedException {
        return (User)super.clone();
    }
}
```

> 测试

```java
public class ShallowClone {
    public static void main(String[] args) throws CloneNotSupportedException {
       User user = new User("张三", 18);
       User user2 = user.clone();
       user2.setName("Q10Viking");
        System.out.println(user);
        System.out.println(user2);
    }
}
/**
 * User(name=张三, age=18)
 * User(name=Q10Viking, age=18)
 */
```



### 存在的问题

如果对象的属性还引用了其他对象，那么浅拷贝只会复制这个对象的引用地址。

```java
@Data
@AllArgsConstructor
public class User implements Cloneable{
    private String name;
    private City city;

    @Override
    public User clone() throws CloneNotSupportedException {
        return (User)super.clone();
    }
}

@Data
@AllArgsConstructor
public class City {
    private String name;
}
```

> 测试

```java
public class ShallowProblemTest {
    public static void main(String[] args) throws CloneNotSupportedException {
        User user = new User("张三", new City("北京"));
        User user2 = user.clone();

        user2.setName("Q10Viking");
        user2.getCity().setName("广州");

        System.out.println(user);
        System.out.println(user2);
    }
}
/**
 * User(name=张三, city=City(name=广州))
 * User(name=Q10Viking, city=City(name=广州))
 */
```

> 可以user2改变City，影响到了user的city,但是name不受影响

## 深拷贝

深克隆就是复制整个对象信息，包含值类型和引用类型,解决浅拷贝的问题

**深克隆的实现方式** 通常包含以下两种。

  * 序列化实现深克隆：先将原对象序列化到内存的字节流中，再从字节流中反序列化出刚刚存储的对象，这个新对象和原对象就不存在任何地址上的共享，这样就实现了深克隆。
  * 所有引用类型都实现克隆：要复制对象的所有引用类型都要实现克隆，所有对象都是复制的新对象，从而实现了深克隆。



### 引用对象实现了Clone接口

1. 引用对象要实现Clone接口，并且覆盖Object的clone方法
2. 在父对象中，还需要手动对引用对象进行clone.

```java
@Data
@AllArgsConstructor
public class City implements Cloneable{
    private String name;

    @Override
    public City clone() throws CloneNotSupportedException {
        return (City)super.clone();
    }
}


@Data
@AllArgsConstructor
public class User implements Cloneable{
    private String name;
    private City city;

    @Override
    public User clone() throws CloneNotSupportedException {
        User user =  (User)super.clone();
        user.setCity(city.clone());
        return user;
    }
}
```

> 测试

```java
public class DeepCloneTest {
    public static void main(String[] args) throws CloneNotSupportedException {
        User user = new User("张三", new City("北京"));
        User user2 = user.clone();

        user2.setName("Q10Viking");
        user2.getCity().setName("广州");
        System.out.println(user);
        System.out.println(user2);
    }
}
/**
 * User(name=张三, city=City(name=北京))
 * User(name=Q10Viking, city=City(name=广州))
 */
```



> 如果属性比较多，那么这种方式处理起来会相当繁琐，那么还有第二种方式，通过序列的方式



### 序列化实现深拷贝

先将要拷贝对象写入到内存中的字节流中，然后再从这个字节流中读出刚刚存储的信息，作为一个新对象返回，那么这个新对象和原对象就不存在任何地址上的共享，自然实现了深拷贝。

- 对象要实现序列化接口，包括引用的对象也要实现序列化接口

```java
@Data
@AllArgsConstructor
public class User implements Serializable {
    private String name;
    private City city;
}


@Data
@AllArgsConstructor
public class City implements Serializable{
    private String name;
}
```



> 测试

```java
public class DeepCloneTest {
    public static void main(String[] args) throws CloneNotSupportedException {
        User user = new User("张三", new City("北京"));
        User user2 = CloneUtils.clone(user);

        user2.setName("Q10Viking");
        user2.getCity().setName("广州");
        System.out.println(user);
        System.out.println(user2);
    }
}
/**
 * User(name=张三, city=City(name=北京))
 * User(name=Q10Viking, city=City(name=广州))
 */
```

> 使用ByteArrayOutputStream与ObjectOutputStream等类实现序列化工具

```java
public class CloneUtils {
    public static <T extends Serializable> T clone(T obj) {
        T cloneObj = null;
        try {
            //写入字节流
            ByteArrayOutputStream bo = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bo);
            oos.writeObject(obj);
            oos.close();
            //分配内存,写入原始对象,生成新对象
            ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());//获取上面的输出字节流
            ObjectInputStream oi = new ObjectInputStream(bi);
            //返回生成的新对象
            cloneObj = (T) oi.readObject();
            oi.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return cloneObj;
    }
}
```



## 序列化和反序列化

> 内存中的数据对象只有转换成二进制流才能进行数据持久化或者网络传输，将对象转换成二进制流的过程叫做序列化（Serialization）；相反，把二进制流恢复为数据对象的过程就称之为反序列化（Deserialization）



[Intellij IDEA 如何自动生成 serialVersionUID-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1697377) 根据提示设置后之后，需要重启idea.

> 先把对象序列化到磁盘，再从磁盘中反序列化出对象

```java
public class SerializableTest {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Mobile mobile = new Mobile("iPhone");

        System.out.println(mobile);
        // 创建输出流（序列化内容到磁盘）
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("test.out"));
        // 序列化对象
        oos.writeObject(mobile);
        oos.flush();
        oos.close();

        // 创建输入流（从磁盘反序列化）
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("test.out"));
        // 反序列化
        Mobile mobile1 = (Mobile) ois.readObject();
        ois.close();
        System.out.println(mobile);
    }
}
/**
 * Mobile(name=iPhone)
 * Mobile(name=iPhone)
 */
```

![image-20230515220516992](/images/java/image-20230515220516992.png)
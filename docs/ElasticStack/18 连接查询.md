---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /ElasticStack/
typora-root-url: ..\.vuepress\public
---



## 嵌套对象

### 案例分析

案例:设计一个用户document数据类型，其中包含一个**地址数据的数组**，这种设计方式相对复杂，但是在管理数据时，更加的灵活。

```json
PUT /user_index
{
  "mappings": {
    "properties": {
      "login_name": {
        "type": "keyword"
      },
      "age": {
        "type": "short"
      },
      "address": {
        "properties": {
          "province": {
            "type": "keyword"
          },
          "city": {
            "type": "keyword"
          },
          "street": {
            "type": "keyword"
          }
        }
      }
    }
  }
}
```

插入数据

```json
PUT /user_index/_doc/1
{
  "login_name": "jack",
  "age": 25,
  "address": [
    {
      "province": "北京",
      "city": "北京",
      "street": "枫林三路"
    },
    {
      "province": "天津",
      "city": "天津",
      "street": "华夏路"
    }
  ]
}

PUT /user_index/_doc/2
{
  "login_name": "rose",
  "age": 21,
  "address": [
    {
      "province": "河北",
      "city": "廊坊",
      "street": "燕郊经济开发区"
    },
    {
      "province": "天津",
      "city": "天津",
      "street": "华夏路"
    }
  ]
}
```

#### 问题

但是上述的数据建模有其明显的缺陷，就是针对地址数据做数据搜索的时候，经常会搜索出不必要的数据，如：在上述数据环境中，搜索一个province为北京，city为天津的用户。

```json
GET /user_index/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "address.province": "北京"
          }
        },
        {
          "match": {
            "address.city": "天津"
          }
        }
      ]
    }
  }
} 
```

![image-20220813144816961](/images/elasticsearch/image-20220813144816961.png)

得到的结果并不准确，**搜索出来的结果没有配套**，这个时候就需要使用nested object来定义数据建模。

### nested object定义数据模型❤️

::: tip

推荐的设计方式

:::

使用nested object作为地址数组的集体类型，可以解决上述问题，document模型如下：

```json
PUT /user_index
{
  "mappings": {
    "properties": {
      "login_name": {
        "type": "keyword"
      },
      "age": {
        "type": "short"
      },
      "address": {
        "type": "nested",
        "properties": {
          "province": {
            "type": "keyword"
          },
          "city": {
            "type": "keyword"
          },
          "street": {
            "type": "keyword"
          }
        }
      }
    }
  }
}
```

再次搜索，就搜索不出来，刚刚那种交错的匹配数据了

![image-20220813145452631](/images/elasticsearch/image-20220813145452631.png)

#### 原理

虽然语法变的复杂了，但是在数据的读写操作上都不会有错误发生，是推荐的设计方式。

其原因是：普通的数组数据在ES中会被扁平化处理，处理方式如下：

```json
{
  "login_name" : "jack",
  "address.province" : [ "北京", "天津" ],
  "address.city" : [ "北京", "天津" ]
  "address.street" : [ "枫林三路", "华夏路" ]
}
```

那么nested object数据类型ES在保存的时候不会有扁平化处理，保存方式如下：所以在搜索的时候一定会有需要的搜索结果。

```json
{
  "login_name" : "jack"
}
{
  "address.province" : "北京",
  "address.city" : "北京"，
  "address.street" : "枫林三路"
}
{
  "address.province" : "天津",
  "address.city" : "天津",
  "address.street" : "华夏路",
}
```


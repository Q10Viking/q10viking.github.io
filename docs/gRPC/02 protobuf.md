---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /gRPC/
typora-root-url: ..\.vuepress\public
---





## 什么是ProtoBuf

ProtoBuf(Protocol Buffers)是一种跨平台、语言无关、可扩展的序列化结构数据的方法，可用于网络数据交换及存储。

在序列化结构化数据的机制中，ProtoBuf是灵活、高效、自动化的，相对常见的XML、JSON，描述同样的信息，ProtoBuf序列化后数据量更小 (在网络中传输消耗的网络流量更少)、序列化/反序列化速度更快、更简单。

**一旦定义了要处理的数据的数据结构之后，就可以利用ProtoBuf的代码生成工具生成相关的代码**。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言(proto3支持C++, Java, Python, Go, Ruby, Objective-C, C#)或从各种不同流中对你的结构化数据轻松读写。





## ProtoBuf协议工作流程

![img](/images/grpc/163592231440.png)



在开发 gRPC 应用程序时，先要定义服务接口，其中应包含如下信息：消费者消费服务的方式、消费者能够远程调用的方法以及调用这些方法所使用的参数和消息格式等。在服务定义中所使用的语言叫作**接口定义语言**（interface definition language，IDL）。

借助服务定义，可以生成服务器端代码，也就是服务器端骨架 （这里的“骨架”和“存根”都是代理。服务器端代理叫作“骨架”（skeleton），客户端代理叫作“存根”（stub）。），它通过提供低层级的通信抽象简化了服务器端的逻辑。同时，还可以生成客户端代码，也就是客户端存根，它使用抽象简化了客户端的通信，为不同的编程语言隐藏了低层级的通信。就像调用本地函数那样，客户端能够远程调用我们在服务接口定义中所指定的方法。底层的 gRPC 框架处理所有的复杂工作，通常包括确保严格的服务契约、数据序列化、网络通信、认证、访问控制、可观察性等。



为了理解 gRPC 的基本概念，我们来看一个使用 gRPC 实现微服务的实际场景。假设我们正在构建一个在线零售应用程序，该应用程序由多个微服务组成。

如图 1-1 所示，假设我们要构建一个微服务来展现在线零售应用程序中可售商品的详情。例如，将 `ProductInfo` 服务建模为 gRPC 服务，通过网络对外暴露。

![img](/images/grpc/1636103739847-5bc59.png)



服务定义是在 ProductInfo.proto 文件中声明的，服务器端和客户端都会使用该文件来生成代码。这里假设 `ProductInfo` 服务使用 Go 语言来实现，消费者使用 Java 语言来实现，两者之间的通信则通过 HTTP/2 来进行。

典型的序列化和反序列化过程往往需要如下组件：

- IDL（Interface description language）文件：参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）。为了建立一个与语言和平台无关的约定，这个约定需要采用与具体开发语言、平台无关的语言来进行描述。这种语言被称为接口描述语言（IDL），采用IDL撰写的协议约定称之为IDL文件。
- IDL Compiler：IDL文件中约定的内容为了在各语言和平台可见，需要有一个编译器，将IDL文件转换成各语言对应的动态库。
- Stub/Skeleton Lib：负责序列化和反序列化的工作代码。Stub是一段部署在分布式系统客户端的代码，一方面接收应用层的参数，并对其序列化后通过底层协议栈发送到服务端，另一方面接收服务端序列化后的结果数据，反序列化后交给客户端应用层；Skeleton部署在服务端，其功能与Stub相反，从传输层接收序列化参数，反序列化后交给服务端应用层，并将应用层的执行结果序列化后最终传送给客户端Stub。
- Client/Server：指的是应用层程序代码，他们面对的是IDL所生存的特定语言的class或struct。
- 底层协议栈和互联网：序列化之后的数据通过底层的传输层、网络层、链路层以及物理层协议转换成数字信号在互联网中传递。



> 可以看到，对于序列化协议来说，使用方只需要关注业务对象本身，即 idl （Interface description language）定义，序列化和反序列化的代码只需要通过工具生成即可。
















































---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /RocketMQ/
typora-root-url: ..\.vuepress\public
---



## 过滤消息



### 根据Tag过滤

::: tip

TAG是RocketMQ中特有的一个消息属性。RocketMQ的最佳实践中就建议，使用RocketMQ时，一个应用可以就用一个Topic，**而应用中的不同业务就用TAG来区分**。

:::

:::: code-group
::: code-group-item TagFilterConsumer

```java
public class TagFilterConsumer {

    public static void main(String[] args) throws InterruptedException, MQClientException, IOException {

        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("tag_filter_consumer_group");

        consumer.subscribe("tag_filter_topic", "TagA || TagC");

        consumer.registerMessageListener(new MessageListenerConcurrently() {

            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                            ConsumeConcurrentlyContext context) {
                System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs);
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });

        consumer.start();

        System.out.printf("Consumer Started.%n");
    }
}

```

:::
::: code-group-item TagFilterProducer

```java
public class TagFilterProducer {
    public static void main(String[] args) throws MQClientException, MQBrokerException, RemotingException, InterruptedException, UnsupportedEncodingException {

        DefaultMQProducer producer = new DefaultMQProducer("tag_filter_producer_grouper");
        producer.setNamesrvAddr(Addr.NAME_SERVER_ADDR);
        producer.start();

        String[] tags = new String[] {"TagA", "TagB", "TagC"};

        for (int i = 0; i < 15; i++) {
            Message msg = new Message("tag_filter_topic",
                    tags[i % tags.length],
                    "Hello world".getBytes(RemotingHelper.DEFAULT_CHARSET));

            SendResult sendResult = producer.send(msg);
            System.out.printf("%s%n", sendResult);
        }

        producer.shutdown();
    }
}
```

:::
::::



> 过滤消息时，虽然只获取TagA或TagC的消息，没有获取TagB的消息，但是消费者位点是发生了变化的。也就是说**在同一个消费组，只要一个过滤的消费者消费了（TagA和TagC）那么同组的另外一个消费者过滤（TagB）就收不到了。反之也成立**

![image-20220608124840129](/images/RocketMQ/image-20220608124840129.png)



### sql92过滤


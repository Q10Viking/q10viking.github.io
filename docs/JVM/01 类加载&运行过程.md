---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /JVM/
typora-root-url: ..\.vuepress\public
---



::: tip

[Source Code](https://github.com/Q10Viking/learncode/tree/main/jvm/_01_jvm_classload)

:::

## java程序启动底层发生了什么？

::: tip

在控制台输入 java org.hzz.Math

:::

![image-20220817175748092](/images/jvm/image-20220817175748092.png)

::: details Math.java

```java
public class Math {
    public static final int initData = 666;
    public static User user = new User();

    public int compute() {  //一个方法对应一块栈帧内存区域
        int a = 1;
        int b = 2;
        int c = (a + b) * 10;
        return c;
    }

    public static void main(String[] args) {
        Math math = new Math();
        math.compute();
        System.out.println("Hello JVM");
    }
}
```

:::

```sh
D:\learncode\jvm\_01_jvm_classload\target\classes> java org.hzz.Math
Hello JVM
```

1. 创建java虚拟机（JVM）

2. JVM创建引导类加载器

3. 引导类加载器加载并实例化sun.misc.Launcher  (`This class is used by the system to launch the main application.`)

4. 在Launcher构造方法内部，其创建了两个类加载器**ExtClassLoader,AppClassLoader**

::: details Launcher.java

   ```java
   /**
    * This class is used by the system to launch the main application.
   Launcher */
   public class Launcher {
       private static Launcher launcher = new Launcher();
       private ClassLoader loader;
       public Launcher() {
               // Create the extension class loader
               ClassLoader extcl;
               try {
                   extcl = ExtClassLoader.getExtClassLoader();
               } catch (IOException e) {
                   throw new InternalError(
                       "Could not create extension class loader", e);
               }
   
               // Now create the class loader to use to launch the application
               try {
                   loader = AppClassLoader.getAppClassLoader(extcl);
               } catch (IOException e) {
                   throw new InternalError(
                       "Could not create application class loader", e);
               }
               // Also set the context class loader for the primordial thread.
               Thread.currentThread().setContextClassLoader(loader);
           // ... 
       }
       // ...
       /*
        * Returns the class loader used to launch the main application.
        */
       public ClassLoader getClassLoader() {
           return loader;
       }
   }
   ```
:::

5. JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们的应用程序（如Math）
6. 加载完成后JVM会执行Math类的main方法

![img](/images/jvm/102280)

### Hotspot源码JVM启动main方法流程

1. 创建java虚拟机（JVM）

2. JVM创建引导类加载器

3. 引导类加载器加载并实例化sun.misc.Launcher  (`This class is used by the system to launch the main application.`)

4. 在Launcher构造方法内部，其创建了两个类加载器**ExtClassLoader,AppClassLoader**

![img](/images/jvm/106918.png)

## 

> 验证Launcher是被引导类加载器加载的

```java
public class LauncherTest {
    public static void main(String[] args) {
        System.out.println(LauncherTest.class.getClassLoader());
        System.out.println(Launcher.class.getClassLoader());
    }
}
/**
 * sun.misc.Launcher$AppClassLoader@18b4aac2
 * null
 */
```



----------



## 类加载全过程⭐

> 类的完全加载过程：**加载 >> 验证 >> 准备 >> 解析 >> 初始化**，（只执行一遍）

```java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
    }
```

![image-20210325020601096](/images/jvm/image-20210325020601096.png)



::: tip

**加载**：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个**代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口

❤️注意：经过尽管调用了loadClass，但是如果不使用，它模式是懒加载的（**即不会初始化**）。

:::

1. 验证：校验class字节码文件符合java规范

   1. 如开头是以 cafe babe

2. 准备：**静态变量**分配内存，**初始值赋值，赋予默认值**

   1. int 默认值0，boolean 默认值 false

   2. 引用类型则null

3. 解析

   1. **静态链接**，**将符号引用替换为直接引用**，**静态方法**替换为指向数据所存的内存地址或句柄；提高效率，**不会变（能够确定内存的地址位置）**,**符号引用（字面符号量）**如：main方法，类名称
   2. **动态链接**，在**运行期间**完成**符号引用替换为直接引用**，如实例方法的调用，找到内存位置，**会变**，直到运行时才知道指向的内存地址，如**多态，接口**的影响。
   3. class字节码中Constant pool**常量池**(**字面符号量**)，这些最终会被加载到 JVM内存中，就会存在地址
      1. 常量池中： #12 为**标识符**  **字面符号量**

4. 初始化（❤️类默认是懒加载，如果不使用该类，初始化方法不会被触发❤️）

   1. **静态变量初始化为指定的值**；

      1. > static int a = 3;

   2. **执行静态代码块**；

      1. > static{ //... }

::: tip

类被加载到**方法区**中后主要包含 **运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用**等信息

:::

**类加载器的引用**：这个类到类加载器实例的引用

**对应class实例的引用**：❤️类加载器在**加载类信息**放到方法区中后，会创建**一个对应的Class 类型的对象实例**放到堆(Heap)中❤️, 作为开发人员访问方法区中**类定义**的入口和切入点



## 类的懒加载（懒初始化）❤️

::: tip

类的完全加载过程：**加载 >> 验证 >> 准备 >> 解析 >> 初始化**，（只执行一遍）而类的懒加载主要是体现在懒初始化上。

jar包或者war包里面的类**不是一次性全部加载的**，使用到时才会被加载

❤️**主类在运行过程中如果使用到其它类，会逐步加载这些类,并且默认使用的类加载器是加载该主类时的类加载器**❤️

:::

> 下面这个程序验证：1. 类加载过程初始化的验证  2. 懒加载
>
> ❤️可以看到静态变量A和静态代码块执行了，但是D和C并没有被加载。❤️

```java
public class TestDynamicLoad {
    public static A a = new A();

    static {
        System.out.println("*************load TestDynamicLoad*******************");
    }

    public D d = new D();

    public static void main(String[] args) {
        System.out.println("*************main method****************************");
        B b = new B();
        C c = null;
    }
}

class A {
    static {
        System.out.println("*************load A*********************************");
    }
}

class B {
    static {
        System.out.println("*************load B*********************************");
    }
}

class C {
    static {
        System.out.println("*************load C*********************************");
    }
}

class D {
    static {
        System.out.println("*************load D*********************************");
    }
}
/**
 * *************load A*********************************
 * *************load TestDynamicLoad*******************
 * *************main method****************************
 * *************load B*********************************
 */
```



### 类加载初始化时机😊

::: tip

类默认是懒加载机制，只有使用到了的时候才会进行加载，从而触发初始化

**Java类加载会初始化**的情况有且仅有以下五种：（也称为主动引用）

:::

1. 通过init指令，如new newInstance
2. getStatic（读取一个静态字段）
3. putstatic（设置一个静态字段）
4. invokeStatic（调用一个类的静态方法）这四条指令字节码命令时
5. 子类初始化会先调用父类

> ❤️如下面的代码并不会执行A类中的静态代码块，虽然使用了A.class.getName()，classLoader.loadClass("org.hzz.dynamicload.a.A")等，但是并没有真正触发加载。那么为什么，A.class.getName(),能获取到信息呢？因为A.class只是被加载到了方法区（类信息），而不是在堆的Class对象❤️

```java
/**
 * 类A并没有被加载
 */
public class TestA {
    public static void main(String[] args) throws Exception {
        ClassLoader classLoader = A.class.getClassLoader();
        System.out.println(A.class.getName());
        // 类加载 是一个懒加载，只有使用到了才会进行加载
        Class<?> aClass = classLoader.loadClass("org.hzz.dynamicload.a.A");
        System.out.println(A.class == aClass);
        System.out.println(A.class);
        // 初始化
        //aClass.newInstance();
        // A.hello();
    }
}

/**
 * org.hzz.dynamicload.a.A
 * true
 * class org.hzz.dynamicload.a.A
 */
class A {
    static {
        System.out.println("A init success");
    }

    public static void hello() {
    }
}
```



### Class.forName

::: tip

更能验证类懒加载（懒初始化的例子）

:::

```java
public class TestB {
    public static void main(String[] args) throws ClassNotFoundException {
        Class b0 = B.class;  // 懒加载，不会初始化
        // 懒加载，不会初始化B
        Class<?> b1 = Class.forName("org.hzz.B",false,TestB.class.getClassLoader());
        System.out.println(b1 == b0); // true
        // 会初始化
        Class<?> b2 = Class.forName("org.hzz.B");
        System.out.println(b1 == b2); // true
    }
}
/**输出
 * true
 * B init success
 * true
 */
class B{
    static {
        System.out.println("B init success");
    }
}
```



## Hotspot源码JVM启动main方法流程

![img](/images/jvm/106918.png)

## IDEA 查看sun包源码

::: tip

目标在IDEA中sun.misc.Launcher.class变成了sun.misc.Launcher.java

:::

```sh
# 将openjdk的代码下载到本地目录E:\openjdk\jdk8\
git clone https://github.com/openjdk-mirror/jdk.git
# 查看所有分支
git branch -r
# 选择origin/jdk8u/jdk8u/master 分支
git checkout origin/jdk8u/jdk8u/master
```

![image-20220817183845957](/images/jvm/image-20220817183845957.png)

IDEA中指定源码路径

![image-20220817190108274](/images/jvm/image-20220817190108274.png)



### 参考

[用IDEA调试JDK源码 (含阅读调试源码的技巧)](https://blog.csdn.net/qq_42322103/article/details/104369824?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-104369824-blog-123503216.t5_layer_targeting_s_randoms&spm=1001.2101.3001.4242.2&utm_relevant_index=4)

[idea 查看java源码_IDEA查看Java的sun包下的源码](https://blog.csdn.net/weixin_34779181/article/details/114514893)


---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /JVM/
typora-root-url: ..\.vuepress\public
---

## 三色标记

**在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，❤️多标和漏标❤️的情况就有可能发生**

**Gcroots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：**

1. **黑色**： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。
2. **灰色**： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。
3. **白色**： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。

![img](/images/jvm/95383.png)



```java
public class ThreeColorRemark {

    public static void main(String[] args) {
        A a = new A();
        //开始做并发标记
        D d = a.b.d;   // 1.读
        a.b.d = null;  // 2.写
        a.d = d;       // 3.写
    }
}

class A {
    B b = new B();
    D d = null;
}

class B {
    C c = new C();
    D d = new D();
}

class C {
}

class D {
}
```



## 多标-浮动垃圾

在并发标记过程中，如果**由于方法运行结束导致部分局部变量(gcroot)被销毁**，**这个gcroot引用的对象之前又被扫描过(被标记为非垃圾对象)**，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“**浮动垃圾**”。

浮动垃圾并不会影响垃圾回收的正确性，只是需要**等到下一轮垃圾回收中才被清除**。

另外，**针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色**，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。

------------------

## 处理漏标

由于在并发标记用户线程还在继续，可能产生新的对象没有被标记到，最后被当成了垃圾对象被回收掉了.**漏标会导致被引用的对象被当成垃圾误删除**

有两种解决方案： **增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB） 。**

1. **增量更新**就是**当黑色对象插入新的指向白色对象的引用关系时**， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， **黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了**。
2. **原始快照**就是**当灰色对象要删除指向白色对象的引用关系时**， 就将这个要删除的引用记录下来， 将白色对象直接标记为黑色(**目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾**) 

对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过**写屏障**实现的

### 写屏障

给某个对象的成员变量赋值时，其底层代码大概长这样：

```c++
/**
* @param field 某对象的成员变量，如 a.b.d 
* @param new_value 新值，如 null
*/
void oop_field_store(oop* field, oop new_value) { 
    *field = new_value; // 赋值操作
} 
```

所谓的写屏障，其实就是指在赋值操作前后，加入一些处理

```c++
void oop_field_store(oop* field, oop new_value) {  
    pre_write_barrier(field);          // 写屏障-写前操作
    *field = new_value; 
    post_write_barrier(field, value);  // 写屏障-写后操作
}
```

- **写屏障实现SATB**

  当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d = null），我们可以利用写屏障，将B**原来成员变量的引用**对象D记录下来：

  ```java
  void pre_write_barrier(oop* field) {
      oop old_value = *field;    // 获取旧值
      remark_set.add(old_value); // 记录原来的引用对象
  }
  ```

- **写屏障实现增量更新**

  当对象A的成员变量的引用发生变化时，比如新增引用（a.d = d），我们可以利用写屏障，将A**新的成员变量引用**对象D记录下来

  ```java
  void post_write_barrier(oop* field, oop new_value) {  
      remark_set.add(new_value);  // 记录新引用的对象
  }
  ```

  -------------



### 读屏障

```java
oop oop_field_load(oop* field) {
    pre_load_barrier(field); // 读屏障-读取前操作
    return *field;
}
```

读屏障是直接针对第一步：D d = a.b.d，当读取成员变量时，一律记录下来：

```java
void pre_load_barrier(oop* field) {  
    oop old_value = *field;
    remark_set.add(old_value); // 记录读取到的对象
}
```

----------

### 为什么G1用SATB?CMS用增量更新？

SATB相对增量更新效率会高（当然SATB可能造成更多的浮动垃圾），因为不需要在重新标记阶段再次深度扫面被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region,CMS就一块老年代区域，重新深度扫描对象的G1的代价会比CMS高，所以G1选择SATM不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。

----------

## **小结**

现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过**栈/队列/缓存日志**等方式进行实现、遍历方式可以是广度/深度遍历等等。

对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下：

- **CMS：写屏障 + 增量更新**
- **G1，Shenandoah：写屏障 + SATB**
- **ZGC：读屏障**
---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /JVM/
typora-root-url: ..\.vuepress\public
---

## 垃圾收集算法

![img](/images/jvm/95317.png)

## 分代收集理论

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。**一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法**。

比如**在新生代中，每次收集都会有大量对象(近99%)死去**，所以可以**选择复制算法**，只需要**付出少量对象的复制成本**就可以完成每次垃圾收集。

而老年代的对象存活几率是比较高的，而且**没有额外的空间对它进行分配担保**，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法**慢10倍以上**。

-------------

## 复制算法

> 空间换时间的思想，内存利用率不高，需要额外划分一块内存

为了解决效率问题，“复制”收集算法出现了。**它可以将内存分为大小相同的两块**，每次使用其中的一块。

当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使**每次的内存回收都是对内存区间的一半进行回收**。

![img](/images/jvm/95776.png)



## 标记-清除算法

算法分为“标记”和“清除”阶段：**标记存活的对象**， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，**在标记完成后统一回收所有被标记的对象** 。

它是最基础的收集算法，比较简单，但是会带来两个明显的问题

1. **效率问题  (如果需要标记的对象太多，效率不高)**
2. **空间问题（标记清除后会产生大量不连续的碎片）**

![img](/images/jvm/94592.png)

## 标记-整理算法

根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

![img](/images/jvm/94590)
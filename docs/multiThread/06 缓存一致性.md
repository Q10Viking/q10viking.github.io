---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /multiThread/
typora-root-url: ..\.vuepress\public
---

## 缓存一致性

计算机体系结构中，缓存一致性是共享资源数据的一致性，这些数据最终存储在多个本地缓存中。当系统中的客户机维护公共内存资源的缓存时，可能会出现数据不一致的问题，这在多处理系统中的cpu中尤其如此。

![202203021401306](/images/multiThread/202203021401306.png)

在共享内存多处理器系统中，每个处理器都有一个单独的缓存内存，共享数据可能有多个副本:一个副本在主内存中，一个副本在请求它的每个处理器的本地缓存中。当数据的一个副本发生更改时，其他副本必须反映该更改。**缓存一致性是确保共享操作数(数据)值的变化能够及时地在整个系统中传播的规程**

![202203021402877](/images/multiThread/202203021402877.png)

## **缓存一致性的要求**

### 写传播（Write Propagation）

对任何缓存中的数据的更改都必须传播到对等缓存中的其他副本(该缓存行的副本)。

### 事务串行化（Transaction Serialization）

对单个内存位置的读/写必须被所有处理器以相同的顺序看到。理论上，一致性可以在加载/存储粒度上执行。然而，在实践中，它通常在缓存块的粒度上执行

### 一致性机制（Coherence mechanisms）

确保一致性的两种最常见的机制是**窥探机制（snooping ）和基于目录的机制（directory-based）**，这两种机制各有优缺点。如果有足够的带宽可用，基于协议的窥探往往会更快，因为所有事务都是所有处理器看到的请求/响应。其缺点是窥探是不可扩展的。每个请求都必须广播到系统中的所有节点，这意味着随着系统变大，(逻辑或物理)总线的大小及其提供的带宽也必须增加。另一方面，目录往往有更长的延迟(3跳 请求/转发/响应)，但使用更少的带宽，因为消息是点对点的，而不是广播的。由于这个原因，许多较大的系统(>64处理器)使用这种类型的缓存一致性。
---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /MySQL/
typora-root-url: ..\.vuepress\public
---

## 索引数据结构

> 索引的出现其实就是为了提高数据查询的效率

**索引是帮助MySQL高效获取数据的排好序的数据结构**，作用，减少在磁盘上的查询次数

索引比喻就像目录页

- 二叉树
- 红黑树
- Hash表
- B-Tree

```sql
-- 如果没有索引就会一行一行的去寻找
select * from t where t.col2 = 89; 
```

数据表都是存储在磁盘上的，磁盘IO读取，一行行的查找，效率比较低。所以**引入索引，来控制磁盘IO查找的次数**。



## 二叉树

对于单边增长的数据，没有效果

为Col2建立索引，二叉树的key为Col2的值，value则为数据行所在的地址

这样再次查询Col2 = 89时，只需要查询两次，就可以找到该数据行

```sql
select * from t where t.col2 = 89; 
```

![image-20210519183353632](/images/MySQL/image-20210519183353632.png)

### 缺点

如果数据都是**单边递增或者单向递减**，使用二叉树建立的索引，会导致数据的深度变得非常深

![image-20211026164251738](/images/MySQL/image-20211026164251738.png)

这样如果查询Col1 = 6,那么在查询效率上并没得到提升。还是需要遍历6次

```sql
select * from t where t.col1 = 6; 
```



## 红黑树

**二叉平衡树**，会**改变单边增长的效果**，

![image-20211026164550332](/images/MySQL/image-20211026164550332.png)

这样再次查找Col1 = 6的数据，则只会查找3次就可以找到了

### 缺点

随着**数据量的增长,（如，几十万，几百万的数量），树的高度会增加**，查询速度也会变得缓慢。可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间

如果一条数据在整个数的叶子节点，而高度为20，那么就需要20次的磁盘IO查找，才能找到该数据。

关键：**磁盘查找的次数与树的高度有关。**

## B-Tree

**数据页节点的引入，在横向放置更多的数据，来控制了树的高度**

默认页节点的大小，可以通过该sql进行查询

```mysql
# 页的大小sql
mysql> show global status like 'innodb_page_size';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| Innodb_page_size | 16384 |
+------------------+-------+
```

可以看到一个页的大小为16kb。如为bigint类型的字段建立索引，bigint为8B,地址分配的空间为6B



![image-20211026171434814](/images/MySQL/image-20211026171434814.png)

16KB/（8B+6B）约等于1170，也就是说可以存储1170个索引

![image-20211026172506634](/images/MySQL/image-20211026172506634.png)

而叶子节点包含data数据大概1KB，加起来是1kB,大概可以存储16个索引，所以可以存储的索引数据为1170x1170x16 = 21,902,400 ,大概两千万的索引，即两千万的数据量，而查找一条数据，只需要3次磁盘IO就可以了，因为深度h=3得到了控制。

### 特点

1. 叶节点具有相同的深度，叶节点的指针为空
2. 所有索引元素不重复
3. **节点中的数据索引从左到右递增排列**

> 排好序的左节点小于右节点

![image-20210519184218251](/images/MySQL/image-20210519184218251.png)

**data为数据所在磁盘上的地址**

## B+Tree(B-Tree的变种)

::: tip

树的高度由每页存储索引的数量有关,由于B-Tree非叶子节点会存储数据，每页存储的索引数量就会变少，树的高度就会相对增加，而B+Tree解决了这个问题

:::

1. 非叶子节点**不存储data,只存储索引**（冗余），**可以放更多的索引**
   1. data为数据在磁盘的地址
   2. 非叶子节点为冗余索引，取一些中间的索引
2. **叶子节点包含所有索引字段**
3. 叶子节点**用指针连接**，提高**区间访问**的性能（在范围查询时，非常方便）
   1. 如Col>20,那么在找到20后，就可以根据指针，快速进行查找

![image-20210519182100028](/images/MySQL/image-20210519182100028.png)

如查找col=30，那么先从根节点尽心查找，先将根节点加入内存（**常驻内存**），如通过二分查找算法，快速找到，数据页所在的磁盘地址，如在15和56之间，然后加载第二个数据页，在第一个数据页中继续查找，发现数据页的地址在20-49之间，然后再加载内存，20-30的数据页，找到30，根据data的指针，加载磁盘上的数据。

### Mysql为什么选择B+Tree而不是B-Tree❤️

1. 同样存储两千万的数据量，由于B-Tree每个页都带有data,导致存储的索引数量变少（16KB/1KB=16个）。导致了树的深度变高。树的深度变高，导致磁盘查找的次数变多，16KB的n次方=两千万。n远远大于B+Tree的3层。

2. 而且在范围查找时，由于叶子节点之间没有建立指针关联，导致B-Tree相比之下会比较慢

## Hash

Mysql中使用的索引除了B+Tree索引外，还有Hash索引，在navicat中看到

![image-20211026185526369](/images/MySQL/image-20211026185526369.png)

使用hash索引来存储（为name建立hash索引）

哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。

不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。

![image-20210520095911155](/images/MySQL/image-20210520095911155.png)

> 举例：假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：

![image-20230509161248838](/images/MySQL/image-20230509161248838.png)

- User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2
- 如果你现在要找身份证号在 [ID_card_X, ID_card_Y] 这个区间的所有用户，就必须全部扫描一遍了

> 如果你现在要找身份证号在 [ID_card_X, ID_card_Y] 这个区间的所有用户，就必须全部扫描一遍了



### 优点

1. 对索引的key进行一次hash计算就可以定位出数据存储的位置
2. **很多时候Hash索引要比B+Tree效率高**

### 缺点

1. **仅能满足“=”，“IN”,不支持范围查询**
2. **存在hash冲突**

## MySQL中支持的索引

![image-20211026185526369](/images/MySQL/image-202110261855263691.png)

1. B+Tree索引  （工作中大多数情况都是用）
2. Hash索引 **存在缺点**

如果用不到索引，或者索引失效，那么就会进行磁盘的遍历操作
---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /MySQL/
typora-root-url: ..\.vuepress\public
---



::: tip

本章实战数据来源，参考：[王者荣耀数据](https://q10viking.github.io/MySQL/31%20SQL%E5%87%BD%E6%95%B0.html#%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE)

:::





## SELECT 查询的基础语法

### 查询列

> 对数据表中的某一列进行检索，在 SELECT 后面加上这个列的字段名即可

比如我们想要检索数据表中都有哪些英雄

```sql
mysql> SELECT name FROM heros;
+--------------+
| name         |
+--------------+
| 夏侯惇       |
| 钟无艳       |
| 张飞         |
| 牛魔         |
| 吕布         |
...
| 哪吒         |
| 阿轲         |
| 娜可露露     |
| 兰陵王       |
| 铠           |
| 百里守约     |
+--------------+
```

#### 查询多列

对多个列进行检索，在列名之间用逗号 (,) 分割即可

检索有哪些英雄，他们的最大生命、最大法力、最大物攻和最大物防分别是多少

```sql
mysql> SELECT name, hp_max, mp_max, attack_max, defense_max FROM heros;
+--------------+--------+--------+------------+-------------+
| name         | hp_max | mp_max | attack_max | defense_max |
+--------------+--------+--------+------------+-------------+
| 夏侯惇       |   7350 |   1746 |        321 |         397 |
| 钟无艳       |   7000 |   1760 |        318 |         409 |
| 张飞         |   8341 |    100 |        301 |         504 |
| 牛魔         |   8476 |   1926 |        273 |         394 |
| 吕布         |   7344 |      0 |        343 |         390 |
...
| 哪吒         |   7268 |   1808 |        320 |         408 |
| 阿轲         |   5968 |      0 |        427 |         349 |
| 娜可露露     |   6205 |   1808 |        385 |         359 |
| 兰陵王       |   6232 |   1822 |        388 |         342 |
| 铠           |   6700 |   1784 |        328 |         388 |
| 百里守约     |   5611 |   1784 |        410 |         329 |
+--------------+--------+--------+------------+-------------+
```



### 别名

```sql
mysql> SELECT name AS hero_name FROM heros;
+--------------+
| hero_name    |
+--------------+
| 夏侯惇       |
| 钟无艳       |
| 张飞         |
| 牛魔         |
| 吕布         |
...
| 哪吒         |
| 阿轲         |
| 娜可露露     |
| 兰陵王       |
| 铠           |
| 百里守约     |
+--------------+
```

### 查询常数

- 在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的
- 如果我们想整合不同的数据源，**用常数列作为这个表的标记**，就需要查询常数

```sql
mysql> SELECT '王者荣耀' as platform, name FROM heros;
+--------------+--------------+
| platform     | name         |
+--------------+--------------+
| 王者荣耀     | 夏侯惇       |
| 王者荣耀     | 钟无艳       |
| 王者荣耀     | 张飞         |
| 王者荣耀     | 牛魔         |
| 王者荣耀     | 吕布         |
...
| 王者荣耀     | 哪吒         |
| 王者荣耀     | 阿轲         |
| 王者荣耀     | 娜可露露     |
| 王者荣耀     | 兰陵王       |
| 王者荣耀     | 铠           |
| 王者荣耀     | 百里守约     |
+--------------+--------------+
```

需要说明的是，如果常数是个字符串，那么使用单引号`‘王者荣耀’`就非常重要了，比如‘王者荣耀’。单引号说明引号中的字符串是个常数，否则 SQL 会把王者荣耀当成列名进行查询，但实际上数据表里没有这个列名，就会引起错误。

如果常数是个数字，就可以直接写数字，不需要单引号

```sql
SELECT 123 AS platform, name FROM heros;
```

### 去除重复行👍

关于单个表的 SELECT 查询，还有一个非常实用的操作，就是从结果中去掉重复的行。使用的关键字是 DISTINCT

比如我们想要看下 heros 表中关于攻击范围的取值都有哪些

```sql
mysql> SELECT DISTINCT attack_range FROM heros;
+--------------+
| attack_range |
+--------------+
| 近战         |
| 远程         |
+--------------+
```

如果我们带上英雄名称，会是怎样呢：

```sql
mysql> SELECT DISTINCT attack_range, name FROM heros;
+--------------+--------------+
| attack_range | name         |
+--------------+--------------+
| 近战         | 夏侯惇       |
| 近战         | 钟无艳       |
| 近战         | 张飞         |
| 近战         | 牛魔         |
| 近战         | 吕布         |
...
| 近战         | 哪吒         |
| 近战         | 阿轲         |
| 近战         | 娜可露露     |
| 近战         | 兰陵王       |
| 近战         | 铠           |
| 远程         | 百里守约     |
+--------------+--------------+
```

这里有两点需要注意：

1. DISTINCT 需要**放到所有列名的前面**，如果写成`SELECT name, DISTINCT attack_range FROM heros`会报错。
2. DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 69 条，因为这 69 个英雄名称不同，都有攻击范围（attack_range）这个属性值。如果你想要看都有哪些不同的攻击范围（attack_range），只需要写`DISTINCT attack_range`即可，后面不需要再加其他的列名了。

### 排序检索数据😘

1. 排序的列名：ORDER BY 后面**可以有一个或多个列名**，如果是多个列名进行排序，会按照后面第一个列先进行排序，当第一列的值相同的时候，再按照第二列进行排序，以此类推。
2. 排序的顺序：ORDER BY 后面可以注明排序规则，ASC 代表递增排序，DESC 代表递减排序。如果没有注明排序规则，默认情况下是按照 ASC 递增排序。我们很容易理解 ORDER BY 对数值类型字段的排序规则，但如果排序字段类型为文本数据，就需要参考数据库的设置方式了，这样才能判断 A 是在 B 之前，还是在 B 之后。比如使用 MySQL 在创建字段的时候设置为 BINARY 属性，就代表区分大小写。
3. **非选择列排序**：ORDER BY 可以使用非选择列进行排序，所以即使在 SELECT 后面没有这个列名，你同样可以放到 ORDER BY 后面进行排序。
4. ORDER BY 的位置：ORDER BY 通常位于 SELECT 语句的最后一条子句，否则会报错。



显示英雄名称及最大生命值，按照最大生命值从高到低的方式进行排序

```sql
mysql> SELECT name, hp_max FROM heros ORDER BY hp_max DESC;
+--------------+--------+
| name         | hp_max |
+--------------+--------+
| 廉颇         |   9328 |
| 白起         |   8638 |
| 程咬金       |   8611 |
...
| 姜子牙       |   5399 |
| 花木兰       |   5397 |
| 武则天       |   5037 |
+--------------+--------+
```

显示英雄名称及最大生命值，按照第一排序最大法力从低到高，当最大法力值相等的时候则按照第二排序进行，即最大生命值从高到低的方式进行排序

```sql
SELECT name, hp_max FROM heros ORDER BY mp_max ASC, hp_max DESC;
# 由于ASC是默认的，可以省略
SELECT name, hp_max FROM heros ORDER BY mp_max, hp_max DESC;
```



### 约束返回结果的数量❤️

可以约束返回结果的数量，使用 LIMIT 关键字。

返回英雄名称及最大生命值，按照最大生命值从高到低排序，返回 5 条记录即可

```sql
# 可以看到不必依赖order by
mysql> SELECT name, hp_max FROM heros LIMIT 5;
+-----------+--------+
| name      | hp_max |
+-----------+--------+
| 夏侯惇    |   7350 |
| 钟无艳    |   7000 |
| 张飞      |   8341 |
| 牛魔      |   8476 |
| 吕布      |   7344 |
+-----------+--------+
5 rows in set (0.01 sec)

mysql> SELECT name, hp_max FROM heros ORDER BY hp_max DESC LIMIT 5;
+-----------+--------+
| name      | hp_max |
+-----------+--------+
| 廉颇      |   9328 |
| 白起      |   8638 |
| 程咬金    |   8611 |
| 刘禅      |   8581 |
| 牛魔      |   8476 |
+-----------+--------+
```



### SELECT 的执行顺序💕

1. 关键字的顺序是不能颠倒的：

```sql
SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...
```

2. SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：

```sql
FROM > WHERE > GROUP BY > HAVING > SELECT 的字段 > DISTINCT > ORDER BY > LIMIT
```

比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的：

```sql
SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5
FROM player JOIN team ON player.team_id = team.team_id # 顺序 1
WHERE height > 1.80 # 顺序 2
GROUP BY player.team_id # 顺序 3
HAVING num > 2 # 顺序 4
ORDER BY num DESC # 顺序 6
LIMIT 2 # 顺序 7
```

在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的


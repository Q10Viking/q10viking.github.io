---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /MySQL/
typora-root-url: ..\.vuepress\public
---

## 表锁

```sql
lock table 表名 read(write);
# 如：
lock table test read;
show open tables;  # 查看是否操作成功
# 释放表锁
unlock tables;
```

## 行锁

```sql
begin;
update account set name="lilei02" where id = 1;
# 此时没有提交，事务2进来了,进行操作 update account set name="lilei03" where id = 1;
# 但是会被阻塞
commit  # 当前事务提交
# 事务2阻塞的update account set name="lilei03" where id = 1;这行语句才会执行



事务1： update account set name="lilei02" where id = 1;
事务2： update account set name="lilei03" where id = 2;会阻塞
```

## 锁分析

> **通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况**

```sql
mysql> show status like 'innodb_row_lock%';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| Innodb_row_lock_current_waits | 0     |
| Innodb_row_lock_time          | 12654 |
| Innodb_row_lock_time_avg      | 6327  |
| Innodb_row_lock_time_max      | 12654 |
| Innodb_row_lock_waits         | 2     |
+-------------------------------+-------+
```

对各个状态量的说明如下：

```sql
Innodb_row_lock_current_waits: 当前正在等待锁定的数量
Innodb_row_lock_time: 从系统启动到现在锁定总时间长度
Innodb_row_lock_time_avg: 每次等待所花平均时间
Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间
Innodb_row_lock_waits: 系统启动后到现在总共等待的次数
```

对于这5个状态变量，比较重要的主要是：

```
Innodb_row_lock_time_avg （等待平均时长）
Innodb_row_lock_waits （等待总次数）
Innodb_row_lock_time（等待总时长）
```

> 尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。

### **查看INFORMATION_SCHEMA系统库锁相关数据表**

```sql
-- 查看事务 其中会有事务对应的线程id
select * from INFORMATION_SCHEMA.INNODB_TRX;
-- 查看锁  -- 
select * from INFORMATION_SCHEMA.INNODB_LOCKS;  
-- mysql8 换成了
select * from `performance_schema`.data_locks;



-- 查看锁等待
select * from INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
-- mysql8 换成了
select * from performance_schema.data_lock_waits;

-- 释放锁，trx_mysql_thread_id可以从INNODB_TRX表里查看到
kill trx_mysql_thread_id

-- 查看锁等待详细信息
show engine innodb status\G;
```

![image-20220520020557241](/images/MySQL/image-20220520020557241.png)





```
Lock wait timeout exceeded; try restarting transaction; nested exception is com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Lock wait timeout exceeded; try restarting transaction
```

[(28条消息) 服务提示MySQL的 Lock wait timeout exceeded； try restarting transaction_yulang1992514的博客-CSDN博客](https://blog.csdn.net/yulang1992514/article/details/117756550)





```
INNODB	140257823599832:1235:140257727161488	3034814	104	9	test	user				140257727161488	TABLE	IX	GRANTED	
INNODB	140257823599832:174:4:2:140257727158432	3034814	94	191	test	user			PRIMARY	140257727158432	RECORD	X,REC_NOT_GAP	GRANTED	2
```

锁升级了

程序持有一个事务，插入数据。

再navicat中delete全部数据，它超时

[(28条消息) 服务提示MySQL的 Lock wait timeout exceeded； try restarting transaction_yulang1992514的博客-CSDN博客](https://blog.csdn.net/yulang1992514/article/details/117756550)

[(28条消息) MySql行锁变表锁，性能下降？间隙锁（X,GAP），行锁（X,REC_NOT_GAP），区间锁（X）带你进阶。_a_teacher_java的博客-CSDN博客](https://blog.csdn.net/a_teacher_java/article/details/124806667)
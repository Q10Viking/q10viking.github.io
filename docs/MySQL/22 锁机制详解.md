---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /MySQL/
typora-root-url: ..\.vuepress\public
---

## **锁详解**

锁是计算机协调多个进程或线程并发访问某一资源的机制。

在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。



## **锁分类**

- 从性能上分为**乐观锁**(用版本对比来实现)和**悲观锁**
  - 乐观锁没有锁等待
  - 悲观锁会有锁等待的阻塞
- 从对数据库操作的类型分，分为**读锁**和**写锁**(都属于悲观锁)
  - 读锁（共享锁，S锁(**S**hared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响
  - 写锁（排它锁，X锁(e**X**clusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁
- 从对数据操作的粒度分，分为**全局锁**、**表锁**和**行锁**





## 全局锁

全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句

**全局锁的典型使用场景是，做全库逻辑备份。**也就是把整库每个表都 select 出来存成文本。

以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。

但是让整库都只读，听上去就很危险：

- 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
- 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。

---------

看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？我们来看一下不加锁会有什么问题。

假设你现在要维护一个购买系统，关注的是用户账户余额表和用户课程表。

现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课

> 如果时间顺序上是先备份账户余额表 (u_account)，然后用户购买，然后备份用户课程表 (u_course)，会怎么样呢？

![image-20230509175034320](/images/MySQL/image-20230509175034320.png)

























## **表锁**

每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；一般用在整表数据迁移的场景。

```sql
--建表SQL
CREATE TABLE `mylock` (
	`id` INT (11) NOT NULL AUTO_INCREMENT,
	`NAME` VARCHAR (20) DEFAULT NULL,
	PRIMARY KEY (`id`)
) ENGINE = MyISAM DEFAULT CHARSET = utf8;

--插入数据
INSERT INTO`mylock` (`id`, `NAME`) VALUES ('1', 'a');
INSERT INTO`mylock` (`id`, `NAME`) VALUES ('2', 'b');
INSERT INTO`mylock` (`id`, `NAME`) VALUES ('3', 'c');
INSERT INTO`mylock` (`id`, `NAME`) VALUES ('4', 'd');
```

- 手动增加表锁: 

  ```sql
  lock table 表名称 read(write),表名称2 read(write);
  ```

- 查看表上加过的锁

  ```sql
  show open tables;
  ```

- 删除表锁

  ```sql
  unlock tables;
  ```

### **案例分析(加读锁）**

```
mysql> lock table mylock read;
Query OK, 0 rows affected (0.00 sec)
```

当前session和其他session都可以读该表

当前session中插入或者更新锁定的表都会报错，其他session插入或更新则会等待

```sql
-- 当前session插入失败
mysql> INSERT INTO `mylock` (`id`, `NAME`) VALUES ('1', 'a');
ERROR 1099 (HY000): Table 'mylock' was locked with a READ lock and can't be updated

-- 其他session则会等待，直到加锁的session释放锁
mysql> INSERT INTO `mylock` (`id`, `NAME`) VALUES ('1', 'a');
```

### **案例分析(加写锁）**

```sql
 lock table mylock write;
```

当前session对该表的增删改查都没有问题，其他session对该表的所有操作被阻塞(直到锁被释放)



## 行锁⭐

每次操作锁住一行数据。开销大，加锁慢；**会出现死锁**；锁定粒度最小，发生锁冲突的概率最低，并发度最高。

InnoDB与MYISAM的最大不同有两点：

- **InnoDB支持事务（TRANSACTION）**
- **InnoDB支持行级锁**

### **行锁演示**

一个session开启事务更新不提交，**另一个session更新同一条记录会阻塞，更新不同记录不会阻塞**

![image-20211030094505516](/images/MySQL/image-20211030094505516.png)

**总结：**⭐

1. **MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自动给涉及的表加写锁。**
2. **InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁**。但是**update、insert、delete操作会加行锁**。

简而言之，就是**读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞**。

---------

### **行锁与事务隔离级别案例分析⭐**

## 测试数据

```sql
CREATE TABLE `account` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `balance` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `account` (`name`, `balance`) VALUES ('lilei', '450');
INSERT INTO `account` (`name`, `balance`) VALUES ('hanmei', '16000');
INSERT INTO `account` (`name`, `balance`) VALUES ('lucy', '2400');

```


---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /MySQL/
typora-root-url: ..\.vuepress\public
---

## **并发事务处理带来的问题**

### 更新丢失（Lost Update）或脏写

当两个或多个事务选择同一行，然后**基于最初选定的值更新该行时**，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–**最后的更新覆盖了由其他事务所做的更新**。如对于库存的更新

![image-20211028210715442](/images/MySQL/image-20211028210604376.png)

###  脏读（Dirty Reads）

一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。

一句话：**事务A读取到了事务B已经修改但尚未提交的数据**，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。

![image-20211028211206718](/images/MySQL/image-20211028211206718.png)



### 不可重读（Non-Repeatable Reads） 

一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。

一句话：**事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性**

![image-20211028211540355](/images/MySQL/image-20211028211540355.png)

### 幻读（Phantom Reads）

个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。

一句话：**事务A读取到了事务B提交的新增数据，不符合隔离性**

![image-20211028211855230](/images/MySQL/image-20211028211855230.png)



## **事务隔离级别**

“脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由**数据库提供一定的事务隔离机制来解决**。

![image-20211028212211452](/images/MySQL/image-20211028212211452.png)

数据库的事务隔离越严格**,并发副作用越小,但付出的代价也就越大**,因为事务隔离实质上就是使事务在一定程度上“串行化”进行,这显然与“并发”是矛盾的。

同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用对“不可重复读"和“幻读”并不敏感,可能更关心数据并发访问的能力。

### 查看隔离级别

**常看当前数据库的事务隔离级别: **

```sql
# mysql8
mysql> show variables like 'transaction_isolation';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
```

**设置事务隔离级别**：

```sql
set tx_isolation='REPEATABLE-READ';
```

**Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔离级别，如果Spring设置了就用已经设置的隔离级别**⭐⭐⭐





## 查看长事务

可以在 information_schema 库的 innodb_trx 这个表中查询长事务(事务一直没有提交)，比如下面这个语句，用于查找持续时间超过 60s 的事务

```sql
 select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60;
```




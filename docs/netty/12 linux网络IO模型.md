---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /netty/
typora-root-url: ..\.vuepress\public
---



## **同步和异步，阻塞和非阻塞**

### **同步和异步**

> **关注的是调用方是否主动获取结果**

- 同步:同步的意思就是调用方需要主动等待结果的返回

- 异步:异步的意思就是不需要主动等待结果的返回，而是通过其他手段比如，状态通知，回调函数等。

### **阻塞和非阻塞**

> **主要关注的是等待结果返回调用方的状态**

- 阻塞:是指结果返回之前，当**前线程被挂起**，不做任何事

- 非阻塞:是指结果在返回之前，线程可以做一些其他事，不会被挂起。



### **两者的组合**

1. 同步阻塞: 同步阻塞基本也是编程中最常见的模型，打个比方你去商店买衣服，你去了之后发现衣服卖完了，那你就在店里面一直等，期间不做任何事(包括看手机)，等着商家进货，直到有货为止，这个效率很低。

2. 同步非阻塞: 同步非阻塞在编程中可以抽象为一个轮询模式，你去了商店之后，发现衣服卖完了，这个时候不需要傻傻的等着，你可以去其他地方比如奶茶店，买杯水，但是你还是需要时不时的去商店问老板新衣服到了吗。

3. 异步阻塞:异步阻塞这个编程里面用的较少，有点类似你写了个线程池,submit然后马上future.get()，这样线程其实还是挂起的。有点像你去商店买衣服，这个时候发现衣服没有了，这个时候你就给老板留给电话，说衣服到了就给我打电话，然后你就守着这个电话，一直等着他响什么事也不做。这样感觉的确有点傻，所以这个模式用得比较少。

4. 异步非阻塞:异步非阻塞。好比你去商店买衣服，衣服没了，你只需要给老板说这是我的电话，衣服到了就打。然后你就随心所欲的去玩，也不用操心衣服什么时候到，衣服一到，电话一响就可以去买衣服了





## Linux下的五种IO模型

![https://note.youdao.com/yws/public/resource/4499dc41109fc444d647af81e868e011/xmlnote/OFFICE6C84C36E9C454DBDAD5CE3108A3A73CE/10037](/images/netty/10037.png)

总的来说，阻塞IO就是JDK里的BIO编程，IO复用就是JDK里的NIO编程，Linux下异步IO的实现建立在epoll之上，是个伪异步实现，而且相比IO复用，没有体现出性能优势，使用不广。非阻塞IO使用轮询模式，会不断检测是否有数据到达，大量的占用CPU的时间，是绝不被推荐的模型。信号驱动IO需要在网络通信时额外安装信号处理函数，使用也不广泛。



### 阻塞IO模型

![https://note.youdao.com/yws/public/resource/4499dc41109fc444d647af81e868e011/xmlnote/OFFICE4AB853E4CDD54BA287E251DD432E9F1B/10038](/images/netty/10038.png)

### IO复用

![https://note.youdao.com/yws/public/resource/4499dc41109fc444d647af81e868e011/xmlnote/OFFICE722B9A51523B45B2ACB3C53D589C11EF/10039](/images/netty/10039.png)

> 比较上面两张图，IO复用需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。
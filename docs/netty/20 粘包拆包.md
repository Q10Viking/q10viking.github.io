---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /netty/
typora-root-url: ..\.vuepress\public
---



## **什么是TCP粘包半包**

![https://note.youdao.com/yws/public/resource/f71d324d40f6c4bfb67e419a8fb42862/xmlnote/OFFICE4FCB9257726549F6B0D2D8C565EACA30/10116](/images/netty/10116.png)

假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。

1. 服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；

2. 服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；

3. 服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；

4. 服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。

如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。



## **TCP粘包/半包发生的原因**

### 粘包

> 客户端发送

由于TCP协议本身的机制（面向连接的可靠地协议-三次握手机制）客户端与服务器会维持一个连接（Channel），数据在连接不断开的情况下，可以持续不断地将多个数据包发往服务器，但是如果发送的网络数据包太小，那么他本身会启用Nagle算法（可配置是否启用）对较小的数据包进行合并（基于此，TCP的网络延迟要UDP的高些）然后再发送（超时或者包大小足够）。那么这样的话，服务器在接收到消息（数据流）的时候就无法区分哪些数据包是客户端自己分开发送的，这样产生了粘包；

> 服务端接收

服务器在接收到数据库后，放到缓冲区中，如果消息没有被及时从缓存区取走，下次在取数据的时候可能就会出现一次取出多个数据包的情况，造成粘包现象



> UDP

本身作为无连接的不可靠的传输协议（适合频繁发送较小的数据包），他不会对数据包进行合并发送（也就没有Nagle算法之说了），他直接是一端发送什么数据，直接就发出去了，既然他不会对数据合并，每一个数据包都是完整的（数据+UDP头+IP头等等发一次数据封装一次）也就没有粘包一说了。



### 半包(拆包)

> 就是一个数据包被分成了多次接收

应用程序写入数据的字节大小大于套接字发送缓冲区的大小



## 代码演示拆包与半包

[Source Code]()

客户端发送下面的消息100条

```sh
Java,Golang,Python,Javascript,C++
```

在服务端接收的时候，都粘贴在了一起

```sh
Server Accept[Java,Golang,Python,Javascript,C++   # 被粘包了
Java,Golang,Python,Javascript,C++
Java,Golang,Python,Javascript,C++
Java,Golang,Python,Javascript,C++
Java,Golang,Python,Javascript,C++
Java,Gola] and the counter is:1    # 这条数据已经被拆包了
```

服务端正确的处理结果,这里服务端添加了`LineBasedFrameDecoder`专门来处理数据以`\r\n` 结尾的数据

```sh
Server Accept[Java,Golang,Python,Javascript,C++] and the counter is:97
Server Accept[Java,Golang,Python,Javascript,C++] and the counter is:98
Server Accept[Java,Golang,Python,Javascript,C++] and the counter is:99
Server Accept[Java,Golang,Python,Javascript,C++] and the counter is:100
```



### 原理






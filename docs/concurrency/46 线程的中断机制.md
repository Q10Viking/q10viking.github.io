---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /concurrency/
typora-root-url: ..\.vuepress\public
---



## API说明

- interrupt()： 将线程的中断标志位设置为true，不会停止线程
- isInterrupted(): 判断当前线程的中断标志位是否为true，不会清除中断标志位
- Thread.interrupted()：判断当前线程的中断标志位是否为true，并清除中断标志位，重置为fasle

[Source Code](https://github.com/Q10Viking/learncode/tree/main/concurrency/src/main/java/org/hzz/basic/interrupt)

```java
public class ThreadInterruptDemo {
    static int i = 0;
    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            while(true){
                i++;
                System.out.printf("i = %d\n",i);
                // isInterrupted不会清除中断标志位
                if(Thread.currentThread().isInterrupted()){
                    System.out.println("检测到中断标志");
                }
                if(i == 10){
                    System.out.println("检测到 i = 10 线程t1退出循环");
                    break;
                }
            }
        });

        t1.start();
        // 不会停止线程t1,只会设置一个中断标志位 flag=true
        t1.interrupt();
    }
}
/**
 * i = 1
 * 检测到中断标志
 * i = 2
 * 检测到中断标志
 * i = 3
 * 检测到中断标志
 * i = 4
 * 检测到中断标志
 * i = 5
 * 检测到中断标志
 * i = 6
 * 检测到中断标志
 * i = 7
 * 检测到中断标志
 * i = 8
 * 检测到中断标志
 * i = 9
 * 检测到中断标志
 * i = 10
 * 检测到中断标志
 * 检测到 i = 10 线程t1退出循环
 */
```



## 利用中断机制优雅停止线程

```java
while (!Thread.currentThread().isInterrupted() && more work to do) {
    do more work
```

[Source Code](https://github.com/Q10Viking/learncode/tree/main/concurrency/src/main/java/org/hzz/basic/stop)

```java
package org.hzz.basic.stop;

public class StopThreadDemo implements Runnable{
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new StopThreadDemo());
        thread.start();
        Thread.sleep(5);
        thread.interrupt();
    }

    @Override
    public void run() {
        int count = 0;
        while(!Thread.currentThread().isInterrupted()
        && count <= 1000){
            System.out.println("count = " + count++);
        }
        System.out.println("线程停止：stop thread");
    }
}
/**output: 可以看到线程终止循环不是因为count >= 1000
 * count = 140
 * count = 141
 * count = 142
 * 线程停止：stop thread
 */
```



## Sleep会检检测到中断

::: tip

1. sleep可以被中断 抛出中断异常：sleep interrupted， 清除中断标志位
2. wait可以被中断 抛出中断异常：InterruptedException， 清除中断标志位

:::

```java
public class SleepInteruptDemo implements Runnable{

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new SleepInteruptDemo());
        thread.start();
        Thread.sleep(5);
        thread.interrupt();
    }
    @Override
    public void run() {
        int count = 0;

        while(!Thread.currentThread().isInterrupted()
            && count < 1000){
            System.out.println("count = " + count++);
            try{
                // 线程执行任务期间有休眠需求
                Thread.sleep(1);
            } catch (InterruptedException e) {
                System.out.println("检测到中断异常");
            }
        }
        System.out.println("线程停止：stop thread");
    }
}
/** 验证Thread.sleep期间会检测到中断并清除中断标志
 * count = 997
 * count = 998
 * count = 999
 * 线程停止：stop thread
 */
```



处于休眠中的线程被中断，**线程是可以感受到中断信号的，并且会抛出一个 InterruptedException 异常，同时清除中断信号，将中断标记位设置成 false**。这样就会导致while条件Thread.currentThread().isInterrupted()为false，程序会在不满足count < 1000这个条件时退出。如果不在catch中重新手动添加中断信号，不做任何处理，就会屏蔽中断请求，有可能导致线程无法正确停止。

```java

```

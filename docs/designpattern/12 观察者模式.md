---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /designpattern/
typora-root-url: ..\.vuepress\public
---



## 模式定义



> 定义了对象之间的**一对多依赖**，让**多个观察者对象同时监听某一个主题对象**，**当主题对象发生变化**时，它的**所有依赖者都会收到通知并更新**



### 对象的联动

![image-20240327153550482](/images/designpattern/image-20240327153550482.png)

----------



## 开发优点

1. 符合开闭原则
2. 可以在**运行时建立对象之间的关系**



## 基本模型

### 基本模型2

![image-20240327154307815](/images/designpattern/image-20240327154307815.png)

- Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时定义了通知方法notify（）。目标类可以是接口，也可以是抽象类或具体类。(有点类似注册中心的意思)
- ConcreteSubject（具体目标）：具体目标是目标类的子类，通常包含有经常发生改变的数据。当它的状态发生改变时，向其各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有）。如果无须扩展目标类，则具体目标类可以省略
- ConcreteSubject（具体目标）：具体目标是目标类的子类，通常包含有经常发生改变的数据。当它的状态发生改变时，向其各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有）。如果无须扩展目标类，则具体目标类可以省略
- ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。它实现了在抽象观察者Observer中声明的update（）方法。通常在实现时，可以调用具体目标类的attach（）方法将自己添加到目标类的集合中或通过detach（）方法将自己从目标类的集合中删除。



### 基本模型2

![image-20210330234215870](/images/designpattern/image-20210330234215870.png)

[Source Code](https://github.com/Q10Viking/learncode/tree/main/designpattern/src/org/hzz/observer)

```java
// 观察者
public interface ObServer {
    void update(Object event);
}
```

```java
// 主题
public interface Subject {
    void attach(ObServer obServer);
    void remove(ObServer obServer);
    void notifyAllObServer(Object obj);
}
```

```java
// 订阅者实现
public class Task implements ObServer {
    private String name = "Task1";

    public Task(String name){
        this.name = name;
    }
    @Override
    public void update(Object event) {
        System.out.format("%s receive %s\n",name,event);
    }
}
```

```java
// 主题实现
public class SubjectImp implements Subject {
    private List<ObServer> container = new ArrayList<>();

    @Override
    public void attach(ObServer obServer) {
        container.add(obServer);
    }

    @Override
    public void remove(ObServer obServer) {
        container.remove(obServer);
    }

    @Override
    public void notifyAllObServer(Object obj) {
        for (ObServer observer:
             container) {
            observer.update(obj);
        }
    }
}
```

#### 测试

```java
public class TestMain {
    public static void main(String[] args) {
        Subject subject = new SubjectImp();
        ObServer task1 = new Task("Task1");
        ObServer task2 = new Task("Task2");

        subject.attach(task1);
        subject.attach(task2);
        subject.notifyAllObServer("A happed");
        System.out.println("--------------------------------------------");
        subject.remove(task2);
        subject.notifyAllObServer("A happed");
    }
}
/**
 * Task1 receive A happed
 * Task2 receive A happed
 * --------------------------------------------
 * Task1 receive A happed
 */
```

---------



## 应用场景

当**更改一个对象的状态可能需要更改其他对象**，并且实际的**对象集事先未知或动态更改**时，请使用观察者模式



## 5. 源码应用

```java
Spring:
org.springframework.context.ApplicationListener
```


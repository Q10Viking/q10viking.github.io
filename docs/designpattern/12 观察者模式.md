---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /designpattern/
typora-root-url: ..\.vuepress\public
---



## 模式定义



> 定义了对象之间的**一对多依赖**，让**多个观察者对象同时监听某一个主题对象**，**当主题对象发生变化**时，它的**所有依赖者都会收到通知并更新**



### 对象的联动

![image-20240327153550482](/images/designpattern/image-20240327153550482.png)

----------



## 开发优点

1. 符合开闭原则
2. 可以在**运行时建立对象之间的关系**



## 基本模型

### 基本模型1

[Source Code](https://gitee.com/q10viking/design-patterns/tree/master/springboot-design-patterns/src/main/java/org/hzz/%E8%A1%8C%E4%B8%BA%E6%80%A7%E6%A8%A1%E5%BC%8F/BP1_%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B)

![image-20240327154307815](/images/designpattern/image-20240327154307815.png)

- Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时定义了通知方法notify（）。目标类可以是接口，也可以是抽象类或具体类。(有点类似注册中心的意思)
- ConcreteSubject（具体目标）：具体目标是目标类的子类，通常包含有经常发生改变的数据。当它的状态发生改变时，向其各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有）。如果无须扩展目标类，则具体目标类可以省略
- ConcreteSubject（具体目标）：具体目标是目标类的子类，通常包含有经常发生改变的数据。当它的状态发生改变时，向其各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有）。如果无须扩展目标类，则具体目标类可以省略
- ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。它实现了在抽象观察者Observer中声明的update（）方法。通常在实现时，可以调用具体目标类的attach（）方法将自己添加到目标类的集合中或通过detach（）方法将自己从目标类的集合中删除。

#### subject

```java
/**
 * 目标主题抽象类
 */
public abstract class Subject {
    // 定义一个观察者集合用于存储所有观察者对象
    protected List<Observer> observers = new ArrayList();

    // 注册方法，用于向观察者集合中添加一个观察者
    public void attach(Observer observer){
        observers.add(observer);
    }

    // 注销方法,用于在观察者集合中删除指定的观察者
    public void detach(Observer observer){
        observers.remove(observer);
    }

    // 声明抽象通知方法
    public abstract void notifyAllObserver();
}
```

```java
package org.hzz.行为性模式.BP1_观察者模式.基本模型.impl;

import org.hzz.行为性模式.BP1_观察者模式.基本模型.Observer;
import org.hzz.行为性模式.BP1_观察者模式.基本模型.Subject;


import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

public class ConcreteSubject extends Subject {
    ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();
    // 实现通知方法
    @Override
    public void notifyAllObserver() {
        // 遍历观察者集合，调用每一个观察者的像一个响应方法
        for (Observer observer: this.observers){
            executor.submit(()-> observer.update());
        }
    }

    public void doSomething(){
        System.out.println("业务变动，通知各个观察者");
        this.notifyAllObserver();
    }
}

```



#### observer

```java
public interface Observer {
    // 响应声明方法
    public void update();
}

```

```java
public class ConcreteObserver implements Observer {
    private String name;
    public ConcreteObserver(String name){
        this.name = name;
    }
    // 实现响应方法
    @Override
    public void update() {
        // 具体响应代码
        System.out.println(this.name+"收到通知");
    }
}
```



#### 测试

```java
public class Test {
    public static void main(String[] args) {
        Subject subject = new ConcreteSubject();
        subject.attach(new ConcreteObserver("broker-1"));
        subject.attach(new ConcreteObserver("broker-2"));
        subject.attach(new ConcreteObserver("broker-3"));

        ((ConcreteSubject)subject).doSomething();
    }
}
/**
 * 业务变动，通知各个观察者
 * broker-2收到通知
 * broker-3收到通知
 * broker-1收到通知
 */
```



### 基本模型2

![image-20210330234215870](/images/designpattern/image-20210330234215870.png)

[Source Code](https://github.com/Q10Viking/learncode/tree/main/designpattern/src/org/hzz/observer)

```java
// 观察者
public interface ObServer {
    void update(Object event);
}
```

```java
// 主题
public interface Subject {
    void attach(ObServer obServer);
    void remove(ObServer obServer);
    void notifyAllObServer(Object obj);
}
```

```java
// 订阅者实现
public class Task implements ObServer {
    private String name = "Task1";

    public Task(String name){
        this.name = name;
    }
    @Override
    public void update(Object event) {
        System.out.format("%s receive %s\n",name,event);
    }
}
```

```java
// 主题实现
public class SubjectImp implements Subject {
    private List<ObServer> container = new ArrayList<>();

    @Override
    public void attach(ObServer obServer) {
        container.add(obServer);
    }

    @Override
    public void remove(ObServer obServer) {
        container.remove(obServer);
    }

    @Override
    public void notifyAllObServer(Object obj) {
        for (ObServer observer:
             container) {
            observer.update(obj);
        }
    }
}
```

#### 测试

```java
public class TestMain {
    public static void main(String[] args) {
        Subject subject = new SubjectImp();
        ObServer task1 = new Task("Task1");
        ObServer task2 = new Task("Task2");

        subject.attach(task1);
        subject.attach(task2);
        subject.notifyAllObServer("A happed");
        System.out.println("--------------------------------------------");
        subject.remove(task2);
        subject.notifyAllObServer("A happed");
    }
}
/**
 * Task1 receive A happed
 * Task2 receive A happed
 * --------------------------------------------
 * Task1 receive A happed
 */
```

---------



## 应用场景

当**更改一个对象的状态可能需要更改其他对象**，并且实际的**对象集事先未知或动态更改**时，请使用观察者模式



## 源码应用

```java
Spring:
org.springframework.context.ApplicationListener
```



## 案例

### 多人联机对战游戏

[Source Code](https://gitee.com/q10viking/design-patterns/tree/master/springboot-design-patterns/src/main/java/org/hzz/%E8%A1%8C%E4%B8%BA%E6%80%A7%E6%A8%A1%E5%BC%8F/BP1_%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E6%A1%88%E4%BE%8B/%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BA%E5%AF%B9%E6%88%98%E6%B8%B8%E6%88%8F)

联盟成员受到攻击→发送通知给盟友→盟友做出响应。

![image-20240327153550482](/images/designpattern/image-20240327153550482.png)

![image-20240327170525513](/images/designpattern/image-20240327170525513.png)

AllyControlCenter充当目标类，ConcreteAllyControlCenter充当具体目标类，Observer充当抽象观察者，Player充当具体观察者

#### 控制中心（主题）

```java
//战队控制中心类：目标类
public abstract class AllyControlCenter {
    //战队名称
    protected String allyName;
    //定义一个集合用于存储战队成员
    protected ArrayList<Observer> players = new ArrayList<Observer>();

    public void setAllyName(String allyName) {
        this.allyName = allyName;
    }

    public String getAllyName() {
        return this.allyName;
    }

    //注册方法
    public void join(Observer obs) {
        System.out.println(obs.getName() + "加入" + this.allyName + "战队！");
        players.add(obs);
    }

    //注销方法
    public void quit(Observer obs) {
        System.out.println(obs.getName() + "退出" + this.allyName + "战队！");
        players.remove(obs);
    }

    //声明抽象通知方法
    public abstract void notifyObserver(String name);
}
```

具体实现

```java
package org.hzz.行为性模式.BP1_观察者模式.案例.多人联机对战游戏.impl;

import org.hzz.行为性模式.BP1_观察者模式.案例.多人联机对战游戏.AllyControlCenter;
import org.hzz.行为性模式.BP1_观察者模式.案例.多人联机对战游戏.Observer;

import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

public class ConcreteAllyControlCenter extends AllyControlCenter {
    ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();
    public ConcreteAllyControlCenter(String allyName) {
        System.out.println(allyName + "战队组建成功！");
        System.out.println("----------------------------");
        this.allyName = allyName;
    }

    @Override
    public void notifyObserver(String name) {
        System.out.println(this.allyName + "战队紧急通知，盟友" + name + "遭受敌人攻击！");
        //遍历观察者集合，调用每一个盟友（自己除外）的支援方法
        for(Observer obs : players) {
            if (!obs.getName().equalsIgnoreCase(name)) {
                // 使用多线程提高并发
               executor.submit(()-> obs.help());
            }
        }
    }
}

```

#### 玩家（观察者）

```java
//抽象观察类
public interface Observer {
    public String getName();
    public void setName(String name);
    public void help(); //声明支援盟友方法
    public void beAttacked(AllyControlCenter acc); //声明遭受攻击方法
}
```

具体实现

```java
package org.hzz.行为性模式.BP1_观察者模式.案例.多人联机对战游戏.impl;

import org.hzz.行为性模式.BP1_观察者模式.案例.多人联机对战游戏.AllyControlCenter;
import org.hzz.行为性模式.BP1_观察者模式.案例.多人联机对战游戏.Observer;

//战队成员类：具体观察者类
public class Player implements Observer {
    private String name;

    public Player(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }

    //支援盟友方法的实现
    public void help() {
        System.out.println("坚持住，" + this.name + "来救你！");
    }

    //遭受攻击方法的实现，当遭受攻击时将调用战队控制中心类的通知方法notifyObserver()来通知盟友
    public void beAttacked(AllyControlCenter acc) {
        System.out.println(this.name + "被攻击！");
        acc.notifyObserver(name);
    }
}

```

#### 测试

```java
package org.hzz.行为性模式.BP1_观察者模式.案例.多人联机对战游戏;

import org.hzz.行为性模式.BP1_观察者模式.案例.多人联机对战游戏.impl.ConcreteAllyControlCenter;
import org.hzz.行为性模式.BP1_观察者模式.案例.多人联机对战游戏.impl.Player;

public class TestDemo {
    public static void main(String[] args) {
        //定义观察目标对象
        AllyControlCenter acc = new ConcreteAllyControlCenter("王者荣耀红方");

        //定义四个观察者对象
        Observer player1 = new Player("对抗路-狂铁");
        Observer player2 = new Player("辅助-蔡文姬");
        Observer player3 = new Player("中路-女娲");
        Observer player4 = new Player("打野-云中君");
        Observer player5 = new Player("射手-伽罗");

        acc.join(player1);
        acc.join(player2);
        acc.join(player3);
        acc.join(player4);
        acc.join(player5);

        //某成员遭受攻击
        player1.beAttacked(acc);

    }
}
/**
 * 王者荣耀红方战队组建成功！
 * ----------------------------
 * 对抗路-狂铁加入王者荣耀红方战队！
 * 辅助-蔡文姬加入王者荣耀红方战队！
 * 中路-女娲加入王者荣耀红方战队！
 * 打野-云中君加入王者荣耀红方战队！
 * 射手-伽罗加入王者荣耀红方战队！
 * 对抗路-狂铁被攻击！
 * 王者荣耀红方战队紧急通知，盟友对抗路-狂铁遭受敌人攻击！
 * 坚持住，辅助-蔡文姬来救你！
 * 坚持住，打野-云中君来救你！
 * 坚持住，中路-女娲来救你！
 * 坚持住，射手-伽罗来救你！
 */
```


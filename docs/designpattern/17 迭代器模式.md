---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /designpattern/
typora-root-url: ..\.vuepress\public
---



## 背景

设计了一个抽象的**数据聚合类**AbstractObjectList，而将存储商品和客户等数据的类作为其子类

![image-20240327213038934](/images/designpattern/image-20240327213038934.png)

List类型的对象objects用于存储数据，AbstractObjectList类的方法说明如表下图所示。

![image-20240327213112127](/images/designpattern/image-20240327213112127.png)

### 缺点分析

1. **违背单一职责**：addObject（）、removeObject（）等方法用于管理数据，而next（）、isLast（）、previous（）、isFirst（）等方法用于遍历数据。这将导致聚合类的职责过重，**它既负责存储和管理数据，又负责遍历数据，违反了单一职责原则**。由于**聚合类非常庞大，实现代码过长，还将给测试和维护增加难度**。
2. **违反了接口隔离原则**: 如果将抽象聚合类声明为一个接口，则在这个接口中充斥着大量方法，不利于子类实现，违反了接口隔离原则。
3. **破坏封装性**：如果将所有的遍历操作都交给子类来实现，将导致子类代码庞大。而且，还必须暴露AbstractObjectList的内部存储细节，向子类公开自己的私有属性，否则子类无法实施对数据的遍历，这将破坏AbstractObjectList类的封装性

> 如何解决上述问题？解决方案之一就是将聚合类中负责遍历数据的方法提取出来，封装到专门的类中，**实现数据存储和数据遍历分离**，无须暴露聚合类的内部属性即可对其进行操作，而这正是迭代器模式的意图所在。

在软件开发时，经常需要使用聚合对象来存储一系列数据。聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中。由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合单一职责原则的要求。



## 迭代器模式定义

迭代器模式（Iterator Pattern）：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标（Cursor）。迭代器模式是一种对象行为型模式。

![image-20240327213500174](/images/designpattern/image-20240327213500174.png)

1. Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法。例如，用于获取第一个元素的first（）方法，用于访问下一个元素的next（）方法，用于判断是否还有下一个元素的hasNext（）方法，用于获取当前元素的currentItem（）方法等。在具体迭代器中将实现这些方法。
2. ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置。在具体实现时，游标通常是一个表示位置的非负整数。
3. Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator（）方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。
4. ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的createIterator（）方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。



## 案例

### 销售管理系统数据遍历

[Source Code](https://gitee.com/q10viking/design-patterns/tree/master/springboot-design-patterns/src/main/java/org/hzz/%E8%A1%8C%E4%B8%BA%E6%80%A7%E6%A8%A1%E5%BC%8F/BP2_%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/%E6%A1%88%E4%BE%8B/%E9%94%80%E5%94%AE%E7%B3%BB%E7%BB%9F)

![image-20240327213809691](/images/designpattern/image-20240327213809691.png)

#### 聚合类

抽象聚合类

```java
package org.hzz.行为性模式.BP2_迭代器模式.案例.销售系统;

import java.util.ArrayList;
import java.util.List;

//抽象聚合类
public abstract class AbstractObjectList {
    protected List<Object> objects = new ArrayList<Object>();

    public AbstractObjectList(List<Object> objects) {
        this.objects = objects;
    }

    public void addObject(Object obj) {
        this.objects.add(obj);
    }

    public void removeObject(Object obj) {
        this.objects.remove(obj);
    }

    public List<Object> getObjects() {
        return this.objects;
    }

    //声明创建迭代器对象的抽象工厂方法
    public abstract AbstractIterator createIterator();
}
```

具体实现

```java
package org.hzz.行为性模式.BP2_迭代器模式.案例.销售系统.impl;

import org.hzz.行为性模式.BP2_迭代器模式.案例.销售系统.AbstractIterator;
import org.hzz.行为性模式.BP2_迭代器模式.案例.销售系统.AbstractObjectList;

import java.util.List;

public class ProductList extends AbstractObjectList {
    public ProductList(List<Object> products) {
        super(products);
    }

    //实现创建迭代器对象的具体工厂方法
    public AbstractIterator createIterator() {
        return new ProductIterator(this);
    }
}

```



#### 迭代器

抽象迭代器，定义行为

```java
package org.hzz.行为性模式.BP2_迭代器模式.案例.销售系统;

//抽象迭代器
public interface AbstractIterator {
    void next(); //移至下一个元素

    boolean isLast(); //判断是否为最后一个元素

    void previous(); //移至上一个元素

    boolean isFirst(); //判断是否为第一个元素

    Object getNextItem(); //获取下一个元素

    Object getPreviousItem(); //获取上一个元素
}
```

具体实现

```java
package org.hzz.行为性模式.BP2_迭代器模式.案例.销售系统.impl;

import org.hzz.行为性模式.BP2_迭代器模式.案例.销售系统.AbstractIterator;

import java.util.List;

//商品迭代器：具体迭代器
public class ProductIterator implements AbstractIterator {
    private List<Object> products;
    private int cursor1; //定义一个游标，用于记录正向遍历的位置
    private int cursor2; //定义一个游标，用于记录逆向遍历的位置

    public ProductIterator(ProductList list) {
        this.products = list.getObjects(); //获取集合对象
        cursor1 = 0; //设置正向遍历游标的初始值
        cursor2 = products.size() -1; //设置逆向遍历游标的初始值
    }

    public void next() {
        if(cursor1 < products.size()) {
            cursor1++;
        }
    }

    public boolean isLast() {
        return (cursor1 == products.size());
    }

    public void previous() {
        if (cursor2 > -1) {
            cursor2--;
        }
    }

    public boolean isFirst() {
        return (cursor2 == -1);
    }

    public Object getNextItem() {
        return products.get(cursor1);
    }

    public Object getPreviousItem() {
        return products.get(cursor2);
    }
}
```



#### 测试

```java
public class TestDemo {
    public static void main(String[] args) {
        List<Object> mobiles = Stream.of("华为", "OPPO", "小米（Mi）", "荣耀（Honor）")
                .collect(Collectors.toList());

        ProductList productList = new ProductList(mobiles);
        AbstractIterator iterator = productList.createIterator();

        // 正向遍历
        System.out.println("----------------正向遍历----------------------");
        while(!iterator.isLast()){
            System.out.print(iterator.getNextItem()+",");
            iterator.next();
        }

        System.out.println("\n----------------反向遍历----------------------");
        while(!iterator.isFirst()){
            System.out.print(iterator.getPreviousItem()+",");
            iterator.previous();
        }

    }
}
/**
 * ----------------正向遍历----------------------
 * 华为,OPPO,小米（Mi）,荣耀（Honor）,
 * ----------------反向遍历----------------------
 * 荣耀（Honor）,小米（Mi）,OPPO,华为,
 */
```


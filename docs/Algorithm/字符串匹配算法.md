---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /Algorithm/
typora-root-url: ..\.vuepress\public
---



## 

## BF(Brute Force)算法

在一个字符串中寻找另一字符串，最容易想到的，也是最简单的办法是：取主串和模式串/搜索串中的每一位依次比较，如果匹配则同时后移一位继续比较，直至匹配到模式串的最后一位；如果出现不匹配的字符，则模式串向后移动一位，继续比较。这种解决问题的思路简单暴力，也是这个算法被叫做BF（Brute Force）的原因。

> 假设主串为“abdea”，搜索串为“dea”：

![image-20220815000535395](/images/algorithm/image-20220815000535395.png)

![image-20220815000320586](/images/algorithm/image-20220815000320586.png)



这个算法的复杂度还是比较好分析的，我们假设主串的长度是 m，模式串的长度是 n，在最好的情况下，在第一个字符处的匹配就能够成功，例如主串是 a b c d ，模式串是a b c，这时只遍历了模式串的长度，因为时间复杂度是 O(n)；

在最坏的情况下，每次都需要遍历整个模式串，但是又未能匹配成功，例如主串是 a a a a a ...a，模式串是 a a a a b，所以需要遍历 m - n + 1 次，时间复杂度是 O(m * n) 。

### 

### Java的indexOf方法❤️

::: tip

String 类中的 indexOf() 方法就是 BF 算法的实现

:::

```java
for (int i = sourceOffset + fromIndex; i <= max; i++) {
    /* Look for first character. */
    if (source[i] != first) {
        while (++i <= max && source[i] != first);
    }

    /* Found first character, now look at the rest of v2 */
    if (i <= max) {
        int j = i + 1;
        int end = j + targetCount - 1;
        for (int k = targetOffset + 1; j < end && source[j]
             == target[k]; j++, k++);

        if (j == end) {
            /* Found whole string. */
            return i - sourceOffset;
        }
    }
}
```



## 
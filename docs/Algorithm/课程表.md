---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /Algorithm/
typora-root-url: ..\.vuepress\public
---

::: tip

[207. 课程表](https://leetcode.cn/problems/course-schedule/)

:::



## 构建邻接图广度搜索

> 其中有指向用入度来表示[a,b] `b->a`,a的度为1，b的度为0.
>
> 通过维护一个队列来建立广度搜索

```java
public class Solution {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.canFinish(
                2,
                new int[][]{
                        {1,0}
                }
        ));
    }

    // 广度搜索，用一个队列维持
    public boolean canFinish(int numCourses, int[][] prerequisites) {

        // 图的邻接表
        List<List<Integer>> adjacencyList = new ArrayList<>();
        for (int i = 0; i < numCourses; i++){
            adjacencyList.add(new ArrayList<>());
        }

        /*入度表*/
        int[] indegrees = new int[numCourses];
        // 初始化
        /*根据先修数组 prerequisites，初始化入度表和邻接表
         *  prerequisites[i] = [ai, bi]，表示要学习课程 ai则必须先学习课程 bi*/
        for (int[] courses: prerequisites){
            /* 要注意有[ai, bi]，也可能会有 [ai, ci]，所以入度表要累加*/
            indegrees[courses[0]]++;
            /* 填充邻接表，表示顶点ai有一条由顶点bi指向顶点ai的边*/
            adjacencyList.get(courses[1]).add(courses[0]);
        }

        // 队列用于存放入度为0的课程
        Queue<Integer> queue = new LinkedList<>();

        for (int i  = 0; i < indegrees.length ; i++) {
            if(indegrees[i] == 0){
                queue.add(i);
            }
        }

        while(!queue.isEmpty()){
            Integer preCourse = queue.poll();
            numCourses--;
            for (int c :
                    adjacencyList.get(preCourse)) {
                /*从邻接表中获得当前顶点vertex所指向的顶点 indication，
                 * 并将indication的值减一，如果indegrees[indication]为0，
                 * 说明 indication 所有的前驱节点已经被处理过 ，则将indication也放入队列*/
                if(--indegrees[c] == 0){
                    queue.add(c);
                }
            }
        }
        /*整个课程可以安排成功，则图是有向无环图，则所有节点都入队并出队后，就完成了拓扑排序，
         * 若课程安排图中存在环，一定有节点的入度始终不为0，会被重复处理
         * 所以成功拓扑排序，出队次数等于课程个数，检查 numCourses == 0 即可判断课程是否可以成功安排*/
        return numCourses == 0;
    }
}
// true
```


---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /Algorithm/
typora-root-url: ..\.vuepress\public
---



::: tip

排序算法

:::

![image-20220814201347117](/images/algorithm/image-20220814201347117.png)



## 冒泡排序

::: tip

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为相关的元素会经由交换慢慢“浮”到数列的顶端

:::

基本思路：

1. 比较相邻的元素。如果第一个比第二个大(小)，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大(小)的数；
3. 针对所有的元素重复以上的步骤，除了最后一个；

重复步骤1~2，直到排序完成。

### 示例

指示器不断移动，比较交换相邻元素

![image-20220815170902651](/images/algorithm/image-20220815170902651.png)

![image-20220815170912293](/images/algorithm/image-20220815170912293.png)

![image-20220815170931900](/images/algorithm/image-20220815170931900.png)

![image-20220815170947227](/images/algorithm/image-20220815170947227.png)

![image-20220815170959854](/images/algorithm/image-20220815170959854.png)

![image-20220815171019626](/images/algorithm/image-20220815171019626.png)

![image-20220815171035451](/images/algorithm/image-20220815171035451.png)

![image-20220815171048465](/images/algorithm/image-20220815171048465.png)

![image-20220815171101732](/images/algorithm/image-20220815171101732.png)

后面继续从头开始循环，直到所有的元素都排好位置为止。

### Coding

::: tip

[Source Code BubbleSort.java](https://github.com/Q10Viking/learncode/blob/main/algorithm/src/main/java/org/hzz/sort/BubbleSort.java)

:::

```java
public class BubbleSort {
    public int[] sortArray(int[] nums){
        if (nums.length == 0) return nums;
        for (int i = 0;i < nums.length - 1;i++){ // 控制轮询次数
            /*从第0个元素开始，依次和后面的元素进行比较
             * j < array.length - 1 - i表示第[array.length - 1 - i]
             * 个元素已经冒泡到了合适的位置，无需进行比较，可以减少比较次数*/
            for (int j = 0; j < nums.length - 1 - i; j++) { // j是指示器
                if(nums[j] > nums[j+1]){
                    int temp = nums[j];
                    nums[j] = nums[j+1];
                    nums[j+1] = temp;
                }
                PrintArray.print(nums);
            }
            System.out.println("---------------");
        }
        return nums;
    }

    public static void main(String[] args) {
        PrintArray.print(PrintArray.SRC);
        System.out.println("============================================");
        int[] dest = new BubbleSort().sortArray(PrintArray.SRC);
        PrintArray.print(dest);
    }
}
```

处理的过程

```sh
86  39  77  23  32  45  58  63  93  4  37  22  
============================================
39  86  77  23  32  45  58  63  93  4  37  22  
39  77  86  23  32  45  58  63  93  4  37  22  
39  77  23  86  32  45  58  63  93  4  37  22  
39  77  23  32  86  45  58  63  93  4  37  22  
39  77  23  32  45  86  58  63  93  4  37  22  
39  77  23  32  45  58  86  63  93  4  37  22  
39  77  23  32  45  58  63  86  93  4  37  22  
39  77  23  32  45  58  63  86  93  4  37  22  
39  77  23  32  45  58  63  86  4  93  37  22  
39  77  23  32  45  58  63  86  4  37  93  22  
39  77  23  32  45  58  63  86  4  37  22  93  
---------------
39  77  23  32  45  58  63  86  4  37  22  93  
39  23  77  32  45  58  63  86  4  37  22  93  
39  23  32  77  45  58  63  86  4  37  22  93  
39  23  32  45  77  58  63  86  4  37  22  93  
39  23  32  45  58  77  63  86  4  37  22  93  
39  23  32  45  58  63  77  86  4  37  22  93  
39  23  32  45  58  63  77  86  4  37  22  93  
39  23  32  45  58  63  77  4  86  37  22  93  
39  23  32  45  58  63  77  4  37  86  22  93  
39  23  32  45  58  63  77  4  37  22  86  93  
---------------
23  39  32  45  58  63  77  4  37  22  86  93  
23  32  39  45  58  63  77  4  37  22  86  93  
23  32  39  45  58  63  77  4  37  22  86  93  
23  32  39  45  58  63  77  4  37  22  86  93  
23  32  39  45  58  63  77  4  37  22  86  93  
23  32  39  45  58  63  77  4  37  22  86  93  
23  32  39  45  58  63  4  77  37  22  86  93  
23  32  39  45  58  63  4  37  77  22  86  93  
23  32  39  45  58  63  4  37  22  77  86  93  
---------------
23  32  39  45  58  63  4  37  22  77  86  93  
23  32  39  45  58  63  4  37  22  77  86  93  
23  32  39  45  58  63  4  37  22  77  86  93  
23  32  39  45  58  63  4  37  22  77  86  93  
23  32  39  45  58  63  4  37  22  77  86  93  
23  32  39  45  58  4  63  37  22  77  86  93  
23  32  39  45  58  4  37  63  22  77  86  93  
23  32  39  45  58  4  37  22  63  77  86  93  
---------------
23  32  39  45  58  4  37  22  63  77  86  93  
23  32  39  45  58  4  37  22  63  77  86  93  
23  32  39  45  58  4  37  22  63  77  86  93  
23  32  39  45  58  4  37  22  63  77  86  93  
23  32  39  45  4  58  37  22  63  77  86  93  
23  32  39  45  4  37  58  22  63  77  86  93  
23  32  39  45  4  37  22  58  63  77  86  93  
---------------
23  32  39  45  4  37  22  58  63  77  86  93  
23  32  39  45  4  37  22  58  63  77  86  93  
23  32  39  45  4  37  22  58  63  77  86  93  
23  32  39  4  45  37  22  58  63  77  86  93  
23  32  39  4  37  45  22  58  63  77  86  93  
23  32  39  4  37  22  45  58  63  77  86  93  
---------------
23  32  39  4  37  22  45  58  63  77  86  93  
23  32  39  4  37  22  45  58  63  77  86  93  
23  32  4  39  37  22  45  58  63  77  86  93  
23  32  4  37  39  22  45  58  63  77  86  93  
23  32  4  37  22  39  45  58  63  77  86  93  
---------------
23  32  4  37  22  39  45  58  63  77  86  93  
23  4  32  37  22  39  45  58  63  77  86  93  
23  4  32  37  22  39  45  58  63  77  86  93  
23  4  32  22  37  39  45  58  63  77  86  93  
---------------
4  23  32  22  37  39  45  58  63  77  86  93  
4  23  32  22  37  39  45  58  63  77  86  93  
4  23  22  32  37  39  45  58  63  77  86  93  
---------------
4  23  22  32  37  39  45  58  63  77  86  93  
4  22  23  32  37  39  45  58  63  77  86  93  
---------------
4  22  23  32  37  39  45  58  63  77  86  93  
---------------
4  22  23  32  37  39  45  58  63  77  86  93  
```







## 快速排序❤️







## 插入排序❤️

::: tip

插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都看过打麻将，在摸牌的时候，拿到一张牌，找到一个合适的位置插入。举个例子，我们手里有3万,4万,6万,8万这几张牌，我们收到5万这张牌，把6万,8万往后移，然后把5万放到原理6万的位置

:::

基本思路：

1. 对于未排序数据，**在已排序序列中从后向前扫描，找到相应位置并插入**。
2. 为了给要插入的元素腾出空间，我们需要将插入位置之后的已排序元素在都向右移动一位

> 总的来说，插入排序对于部分有序的数组十分高效，也很适合小规模数组

### 示例

1. 我们总是认为原始数组的第一个元素已经是有序的了，于是从第二个元素开始进行排序。

![image-20220815174655724](/images/algorithm/image-20220815174655724.png)

2. 第二个元素是L，比T小，所以将T后移一位，L插入T原来的位置

![image-20220815174737126](/images/algorithm/image-20220815174737126.png)

3. 第三个元素是M，在已经排序的序列L、T中，L比M小，L不动，继续比较，T比M大，所以将T后移一位，M插入T原来的位置

![image-20220815174829892](/images/algorithm/image-20220815174829892.png)

4. 第四个元素是A，在已经排序的序列LMT中，A比它们都下，应该排在最前面，所以将LMT全部后移一位，A插入L原来的位置

![image-20220815174903306](/images/algorithm/image-20220815174903306.png)

![image-20220815174917731](/images/algorithm/image-20220815174917731.png)

5. 如此重复，最后形成结果数组

![image-20220815174949844](/images/algorithm/image-20220815174949844.png)

### Coding

::: tip

[Source Code]()

:::

> 在排好序的数组中从后比较元素，方便数组元素的移动

```java
public class InsertionSort {
    public int[] sortArray(int[] nums){

        for (int i = 1; i < nums.length; i++) {
            int preIndex = i-1; // 已排序的数据索引
            int currentValue = nums[i];
            /*在已被排序过数据中倒序寻找合适的位置，如果当前待排序数据比比较的元素要小，
            将比较的元素元素后移一位*/
            while (preIndex>=0 && currentValue<nums[preIndex]){
                //将当前元素后移一位
                nums[preIndex+1] = nums[preIndex];
                preIndex--;
                PrintArray.print(nums);
            }
            /*while循环结束时，说明已经找到了当前待排序数据的合适位置，插入*/
            nums[preIndex+1] = currentValue;
            System.out.println("本轮被插入排序后的数组");
            PrintArray.print(nums);
            System.out.println("--------------------");
        }
        return nums;
    }

    public static void main(String[] args) {
        PrintArray.print(PrintArray.SRC);
        System.out.println("============================================");
        int[] dest = new InsertionSort().sortArray(PrintArray.SRC);
        PrintArray.print(dest);
    }
}
```

处理的过程

```sh
86  39  77  23  32  45  58  63  93  4  37  22  
============================================
86  86  77  23  32  45  58  63  93  4  37  22  
本轮被插入排序后的数组
39  86  77  23  32  45  58  63  93  4  37  22  
--------------------
39  86  86  23  32  45  58  63  93  4  37  22  
本轮被插入排序后的数组
39  77  86  23  32  45  58  63  93  4  37  22  
--------------------
39  77  86  86  32  45  58  63  93  4  37  22  
39  77  77  86  32  45  58  63  93  4  37  22  
39  39  77  86  32  45  58  63  93  4  37  22  
本轮被插入排序后的数组
23  39  77  86  32  45  58  63  93  4  37  22  
--------------------
23  39  77  86  86  45  58  63  93  4  37  22  
23  39  77  77  86  45  58  63  93  4  37  22  
23  39  39  77  86  45  58  63  93  4  37  22  
本轮被插入排序后的数组
23  32  39  77  86  45  58  63  93  4  37  22  
--------------------
23  32  39  77  86  86  58  63  93  4  37  22  
23  32  39  77  77  86  58  63  93  4  37  22  
本轮被插入排序后的数组
23  32  39  45  77  86  58  63  93  4  37  22  
--------------------
23  32  39  45  77  86  86  63  93  4  37  22  
23  32  39  45  77  77  86  63  93  4  37  22  
本轮被插入排序后的数组
23  32  39  45  58  77  86  63  93  4  37  22  
--------------------
23  32  39  45  58  77  86  86  93  4  37  22  
23  32  39  45  58  77  77  86  93  4  37  22  
本轮被插入排序后的数组
23  32  39  45  58  63  77  86  93  4  37  22  
--------------------
本轮被插入排序后的数组
23  32  39  45  58  63  77  86  93  4  37  22  
--------------------
23  32  39  45  58  63  77  86  93  93  37  22  
23  32  39  45  58  63  77  86  86  93  37  22  
23  32  39  45  58  63  77  77  86  93  37  22  
23  32  39  45  58  63  63  77  86  93  37  22  
23  32  39  45  58  58  63  77  86  93  37  22  
23  32  39  45  45  58  63  77  86  93  37  22  
23  32  39  39  45  58  63  77  86  93  37  22  
23  32  32  39  45  58  63  77  86  93  37  22  
23  23  32  39  45  58  63  77  86  93  37  22  
本轮被插入排序后的数组
4  23  32  39  45  58  63  77  86  93  37  22  
--------------------
4  23  32  39  45  58  63  77  86  93  93  22  
4  23  32  39  45  58  63  77  86  86  93  22  
4  23  32  39  45  58  63  77  77  86  93  22  
4  23  32  39  45  58  63  63  77  86  93  22  
4  23  32  39  45  58  58  63  77  86  93  22  
4  23  32  39  45  45  58  63  77  86  93  22  
4  23  32  39  39  45  58  63  77  86  93  22  
本轮被插入排序后的数组
4  23  32  37  39  45  58  63  77  86  93  22  
--------------------
4  23  32  37  39  45  58  63  77  86  93  93  
4  23  32  37  39  45  58  63  77  86  86  93  
4  23  32  37  39  45  58  63  77  77  86  93  
4  23  32  37  39  45  58  63  63  77  86  93  
4  23  32  37  39  45  58  58  63  77  86  93  
4  23  32  37  39  45  45  58  63  77  86  93  
4  23  32  37  39  39  45  58  63  77  86  93  
4  23  32  37  37  39  45  58  63  77  86  93  
4  23  32  32  37  39  45  58  63  77  86  93  
4  23  23  32  37  39  45  58  63  77  86  93  
本轮被插入排序后的数组
4  22  23  32  37  39  45  58  63  77  86  93  
--------------------
4  22  23  32  37  39  45  58  63  77  86  93  
```



## 堆排序❤️


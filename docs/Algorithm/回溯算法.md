---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /Algorithm/
typora-root-url: ..\.vuepress\public
---

回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。在探路的过程中一般使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。

从我们前面对回溯算法的说明可以看到，回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，只是在穷举的过程中可以根据一些条件避免无效的遍历，这个避免的过程也叫剪枝。

所以回溯法并不是什么很高效的算法，那么既然回溯法并不高效为什么还要用它呢？因为一些问题只能靠暴力搜索，没有更高效的解法。这些问题一般是什么样的问题呢？

组合问题：N个数里面按一定规则找出k个数的集合；

切割问题：一个字符串按一定规则有几种切割方式；

子集问题：一个N个数的集合里有多少符合条件的；

子集排列问题：N个数按一定规则全排列有几种排列方式；

棋盘问题：N皇后，解数独等等。

而回溯算法的题目一般有通用的解题步骤：

1. 定义一个解空间，它包含问题的解；

2. 利用适于搜索的方法组织解空间，一般是个树；

3. 利用深度优先法搜索解空间；

4. 利用剪枝函数避免移动到不可能产生解的子空间。

上面所说的解空间，一般会转化成树（即解空间树），也就是说回溯法解决的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，所以回溯法是在一颗高度有限的N叉树上进行遍历。

代码模板

```java
void backtrack(参数列表) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素(树中节点孩子的数量就是集合的大小)) {
        处理节点;
        backtrack(新参数列表);  //递归处理当前节点下的子节点
        回溯，撤销处理结果
    }
}
```



## 案例

[全排序](https://q10viking.github.io/Algorithm/46%20%E5%85%A8%E6%8E%92%E5%88%97%E4%B8%8E47%20%E5%85%A8%E6%8E%92%E5%88%972.html)

[括号生成](https://q10viking.github.io/Algorithm/22%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.html#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95)

[电话号码组合](https://q10viking.github.io/Algorithm/17%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html)

[子集](https://q10viking.github.io/Algorithm/78%20%E5%AD%90%E9%9B%86%E5%90%88.html)

[搜素单词](https://q10viking.github.io/Algorithm/79%20%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D.html)

[组合总和](https://q10viking.github.io/Algorithm/39%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)



```java
/**
 * 时间短可见性证明
 */
public class ShareV7 {
    private static Logger logger = LoggerFactory.getLogger(ShareV7.class);
    //  共享变量
    private static boolean initFlag = false;

    public static void main(String[] args){
        Thread threadA = new Thread(()->{
            logger.info("线程A启动，此时 initFlag = "+initFlag);
            int counter=0;
            while (!initFlag){
                counter++;
            }
            logger.info("线程A循环"+counter+"次后，退出，此时initFlag = "+initFlag);
        },"threadA");
        threadA.start();

        waitofMillis(5); // 5mills之内可见
        //waitofMillis(6); // 6mills之后不可见

        Thread threadB = new Thread(()->{
            logger.info("线程B启动，此时 initFlag = "+initFlag);
            initFlag = true;
            logger.info("线程B修改 此时 initFlag = "+initFlag);
        },"threadB");
        threadB.start();
    }

    public static void waitofMillis(long millis){
        try{
            Thread.sleep(millis);
        }catch (Exception e){}
    }

}
```



可见性并不是加了volatile的情况下才有，还有很多情况下都会出现这些奇怪的可见性，各大虚拟机也没有权威的解释，只能猜猜它的处理方式了，对于你这种情况，我是这样觉得的：我自己跑了一下你这个程序，用log方式打印了它触发可见性的时间，这个程序跑到很快，间隔时间非常短2mills。我的猜想：**虚拟机在一定时间间隔范围内会触发可见性**。验证我的猜想：于是我把你程序中注释的sleep打开，在sleep 5 mills之内包括5mills，都会触发可见性。而从sleep 6 mills 就看不见了。这个临界值的时间节点在我的机器上jdk 1.8.0_301是5mills。这个临界值不一定就一定就是5mills，下次运行成立8mills


---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /rabbitmq/
typora-root-url: ..\.vuepress\public
---



## 什么情况会导致消息被重复消费呢

1. 生产者：生产者可能会重复推送一条数据到 MQ 中，比如 Controller 接口被重复调用了 2 次，没有做接口幂等性导致的；
2. MQ：在消费者消费完准备响应 ack 消息消费成功时，MQ 突然挂了，导致 MQ 以为消费者还未消费该条数据，MQ 恢复后再次推送了该条消息，导致了重复消费。
3. 消费者：消费者已经消费完消息，正准备但是还未响应给ack消息到时，此时消费者挂了，服务重启后 MQ 以为消费者还没有消费该消息，再次推送了该条消息

![image-20240325174015077](/images/RabbitMQ/image-20240325174015077.png)





## 解决方案

### 使用数据库唯一键约束

缺点：局限性很大，**仅仅只能用在我们数据新增场景**，并且性能也比较低

## 

## 使用乐观锁

### 什么是消息幂等性

幂等性指一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。

**在MQ中指，消费多条相同的消息，得到与消费该消息一次相同的结果。**



### 消息幂等性保障--乐观锁机制

**在发送的消息的时候带上修改字段的版本号**

![image-20211031092623945](/images/RabbitMQ/image-20211031092623945.png)



### 简单的消息去重，插入消费记录，增加数据库判断

![image-20240325174404685](/images/RabbitMQ/image-20240325174404685.png)

优点：很多场景下的确能起到不错的效果

缺点：

1. 这个消费者的代码执行需要1秒，重复消息在执行期间（假设100毫秒）内到达（例如生产者快速重发，Broker重启等），增加校验的地方是不是还是没数据（因为上一条消息还没消费完，没有记录）
2. 那么就会穿透掉检查的挡板，最后导致重复的消息消费逻辑进入到非幂等安全的业务代码中，从而引发重复消费的问题

## 并发消息去重基于消息幂等表

![image-20240325175121395](/images/RabbitMQ/image-20240325175121395.png)

- 缺点：如果说第一次消息投递异常没有消费成功，并且没有将消息状态给置为成功或者没有删除消息表记录，此时延时消费每次执行下列都是一直处于消费中，最后消费就会被视为消费失败而被投递到死信Topic中
- 方案：插入的消息表必须要带一个最长消费过期时间，例如10分钟

![image-20240325175201292](/images/RabbitMQ/image-20240325175201292.png)

- 上述方案**只需要一个存储的中心媒介，那我们可以选择更灵活的存储中心媒介，比如Redis**。使用Redis有两个好处：

- - 性能上损耗更低
  - 上面我们讲到的超时时间可以直接利用Redis本身的ttl实现
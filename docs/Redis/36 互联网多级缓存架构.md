---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /Redis/
typora-root-url: ..\.vuepress\public
---





> 互联网多级缓存架构

1. nginx缓存
2. web中的java本地缓存
3. Redis缓存



![](/images/Redis/80946.png)



## 简单缓存架构

redis-->DB

```java
public Product getProductV1(Integer id){
        String productKey = RedisKeyPrefixConst.PRODUCT_CACHE+id;
        Product product = null;
        // 从redis中获取
        product = JSON.parseObject(redisUtil.get(productKey), Product.class);
        if(product!=null){
            logger.info("从缓存中获取");
            return product;
        }
        logger.info("从DB获取");
        product = productMapper.selectById(id);

        // 加入缓存 并且有过期时间
        redisUtil.set(productKey,JSON.toJSONString(product),PRODUCT_CACHE_TIMEOUT, TimeUnit.SECONDS);
        return product;
    }
```

![image-20220810204631876](/images/MySQL/image-20220810204631876.png)

### 数据冷热分离

热门的数据才缓冲，如果冷门商品也放入缓存，会导致redis数据量过大，压力过大。

在用户访问时，将商品添加到缓存，并设置过期时间。再次访问时延长过期时间。

```java

```







## 缓存击穿（失效）

::: tip

如批量上架商品的时候，设置过期时间都是24小时。24小时过了，都失效了

请求的压力直接打到了数据库DB

:::

```sh
// 设置过期时间
```



## 缓存穿透

::: tip

大量请求访问一个不存在的商品，缓存中没有，数据库中也没有。

:::

解决方案，当从数据库查询出数据后，发现是空的，存一个空对象到redis中。





## 突发性热点数据重建缓存

让一个线程去重建缓存。Double Check双重检测锁，相比使用synchronized,使用分布式锁，粒度更加细。如果使用synchronized 查询id=101和102的都会产生竞争。但是使用分布式锁，分别锁101,和102那么就会粒度降低下来。

tryLock的优化lock,串行转并发





## 缓存与数据库双写不一致

![image-20220810170213476](/images/Redis/image-20220810170213476.png)

![image-20220810170422683](/images/Redis/image-20220810170422683.png)

### 解决方案

可以考虑使用分布式锁在操作数据库和缓存中，确保原子性。

针对上面这种情况可以读写锁进行优化

读锁是可以并行执行的。读锁Redisson实现是+1，所以相当于不断重入。





## 缓存雪崩

Redis压力太多，扛不住了。导致web应用系统一直hang住redis,而tomcat是有线程数量限制的，当请求还是不断的增加，会导致web应用系统宕机。

加一个JVM级别的缓存。

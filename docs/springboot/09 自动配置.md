---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /springboot/
typora-root-url: ..\.vuepress\public
---





## 自动配置类

[Source Code](https://github.com/Q10Viking/learncode/tree/main/springboot/_02-springboot-start-analysis)

1. ServletWebServerFactoryAutoConfiguration：配置了Servlet Web场景中所需要的一些Bean
2. TransactionAutoConfiguration：配置了事务场景中所需要的一些Bean
3. AopAutoConfiguration：配置了AOP场景中所需要的一些Bean
4. RabbitAutoConfiguration：配置了Rabbitmq场景中所需要的一些Bean



使用这种结构后，SpringBoot就能让程序员更为方便的来控制**某个Bean或某些Bean要不要生效**，如果某个自动配置类不生效，那该配置类中所定义的Bean则都不会生效

![image-20230407191749448](/images/springboot/image-20230407191749448.png)

## 条件注解

> SpringBoot控制某个自动配置类或某个Bean生不生效



1. ConditionalOnBean：是否存在某个某类或某个名字的Bean
2. ConditionalOnMissingBean：是否缺失某个某类或某个名字的Bean
3. ConditionalOnSingleCandidate：是否符合指定类型的Bean只有一个
4. ConditionalOnClass：是否存在某个类
5. ConditionalOnMissingClass：是否缺失某个类
6. ConditionalOnExpression：指定的表达式返回的是true还是false
7. ConditionalOnJava：判断Java版本
8. ConditionalOnJndi：JNDI指定的资源是否存在
9. ConditionalOnWebApplication：当前应用是一个Web应用
10. ConditionalOnNotWebApplication：当前应用不是一个Web应用
11. ConditionalOnProperty：Environment中是否存在某个属性
12. ConditionalOnResource：指定的资源是否存在
13. ConditionalOnWarDeployment：当前项目是不是以War包部署的方式运行
14. ConditionalOnCloudPlatform：是不是在某个云平台上



当然我们也可以利用@Conditional来自定义条件注解。

条件注解是可以写在类上和方法上的，如果某个条件注解写在了自动配置类上，那该自动配置类会不会生效就要看当前条件能不能符合，或者条件注解写在某个@Bean修饰的方法上，那这个Bean生不生效就看当前条件符不符合。



### 具体原理



1. Spring在解析某个自动配置类时，会先检查该自动配置类上是否有条件注解，如果有，则进一步判断该条件注解所指定的条件当前能不能满足，如果满足了则继续解析该配置类，如果不满足则不进行解析了，也就是配置类所定义的Bean都得不到解析，也就是相当于没有这些Bean了。
2. 同理，Spring在解析某个@Bean的方法时，也会先判断方法上是否有条件注解，然后进行解析，如果不满足条件，则该Bean不会生效



> 我们可以发现，SpringBoot的自动配置，实际上就是SpringBoot的源码中预先写好了一些配置类，预先定义好了一些Bean，我们在用SpringBoot时，这些配置类就已经在我们项目的依赖中了，而这些自动配置类或自动配置Bean到底生不生效，就看具体所指定的条件了。



## starter机制

> SpringBoot中的Starter和自动配置又有什么关系呢？



其实首先要明白一个Starter，就是一个Maven依赖，当我们在项目的pom.xml文件中添加某个Starter依赖时，其实就是简单的添加了很多其他的依赖，比如：

1. spring-boot-starter-web：引入了spring-boot-starter、spring-boot-starter-json、spring-boot-starter-tomcat等和Web开发相关的依赖包
2. spring-boot-starter-tomcat：引入了tomcat-embed-core、tomcat-embed-el、tomcat-embed-websocket等和Tomcat相关的依赖包



![image-20230407192558680](/images/springboot/image-20230407192558680.png)



如果硬要把Starter机制和自动配置联系起来，那就是通过@ConditionalOnClass这个条件注解，因为这个条件注解的作用就是用来判断当前应用的依赖中是否存在某个类或某些类，比如：

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ Servlet.class, Tomcat.class, UpgradeProtocol.class })
@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
static class EmbeddedTomcat {

    @Bean
    TomcatServletWebServerFactory tomcatServletWebServerFactory(
        ObjectProvider<TomcatConnectorCustomizer> connectorCustomizers,
        ObjectProvider<TomcatContextCustomizer> contextCustomizers,
        ObjectProvider<TomcatProtocolHandlerCustomizer<?>> protocolHandlerCustomizers) {
        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
        factory.getTomcatConnectorCustomizers()
            .addAll(connectorCustomizers.orderedStream().collect(Collectors.toList()));
        factory.getTomcatContextCustomizers()
            .addAll(contextCustomizers.orderedStream().collect(Collectors.toList()));
        factory.getTomcatProtocolHandlerCustomizers()
            .addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));
        return factory;
    }

}
```

上面代码中就用到了@ConditionalOnClass，用来判断项目中是否存在Servlet.class、Tomcat.class、UpgradeProtocol.class这三个类，如果存在就满足当前条件，如果项目中引入了spring-boot-starter-tomcat，那就有这三个类，如果没有spring-boot-starter-tomcat那就可能没有这三个类（除非你自己单独引入了Tomcat相关的依赖）。



而如果不想用Tomcat，那就得这么写：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
```



得把spring-boot-starter-tomcat给排除掉，再添加上spring-boot-starter-jetty的依赖，这样Tomcat的Bean就不会生效，Jetty的Bean就能生效，从而项目中用的就是Jetty。

![image-20230407194901783](/images/springboot/image-20230407194901783.png)



## 加载配置类

[Link](https://www.processon.com/view/link/642fcfc5242fb51ae706088b)

<common-progresson-snippet src="https://www.processon.com/view/link/642fcfc5242fb51ae706088b"/>

## 读取SpringBoot的imports和spring.factories文件

> 存放的都是自动配置类

```
org.springframework.boot.autoconfigure.AutoConfiguration.imports
```

![image-20230407142412446](/images/springboot/image-20230407142412446.png)

```sh
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration
org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration
org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration
org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration
```

### 解析

参考：[读文件-Q10Viking](https://q10viking.github.io/FileSystem/06%20%E8%AF%BB%E6%96%87%E4%BB%B6.html)





## 

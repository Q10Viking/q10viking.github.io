---
typora-root-url: images
---

Socket与http请求

## 长连接

::: tip

connect:keep-alive分析，多个http请求可以公用一个socket进行收发数据

和close

:::



**http协议的解析**，编写一个客户端的socket来请求tomcat  "主要是请求行和请求头"

通过01010的字节数据传输到机器上。tomcat中从Socket缓冲区中，取一部分数据到JVM的缓冲区。byte 可以对应起来一个character，这样就转换成字符，根据http协议，将http解析出来，设置到具体类的属性当中。



## 请求体的处理

方式1： **content-length**:   可以ByteChunk长度标记**请求体的结束** tomcat对应的处理IdentityInputFilter

方式二：**分块传输** ChunkedInputFilter 每次read就只读取到一块数据

这两个过滤器根据请求头是什么上面两种方式来分别设置

```
Transfer-Encoding: chunked


数据
2\r\n   header   这是一个分块，表示要传输的数据长度是2   
aa\r\n

1\r\n      这也是一个分块，表示要传输的数据长度是1
a\r\n

0\r\n      标记请求体的结束
\r\n
```

**在长连接的过程请求的处理是串行的: ** 处理了一个请求，然后再处理另外一个请求。请求处理完成，**缓存的字节数组的复用**。

区分好：长连接与请求的关系。长连接过程中会发送多个请求。短链接过程中只会发送一个请求。

```java
// 这个InputStream并不是Socket.getInputStream
// ServletInputStream它自己维护了一个缓存，由它从socket中读取数据先放入到ServletInputStream中维护的缓冲区中
ServletInputStream in = request.getInputStream()
```

-----------

## 响应体的处理

先写入缓存ByteChunk中有数组byte[] buf,当缓冲区的数据

```java
// respones 相应头content-length,和chunk
CoyoteOutputStream outputStream = resp.getOutputStream();
outputstream.write("Q10Viking".getBytes());
// flush() // 会发送响应头 chunk
```

buf缓冲区-->ByteOutBuff.realWrite到第二个socketBuf缓冲区--->

chunk 使用ChunkedOuputFilter,将数据真正的写入到socket中

![image-20220507012552584](/image-20220507012552584.png)

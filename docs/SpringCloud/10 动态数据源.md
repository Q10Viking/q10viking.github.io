---
sidebarDepth: 3
sidebar: auto
prev:
  text: Back To 目录
  link: /SpringCloud/
typora-root-url: ..\.vuepress\public
---



## 应用场景

### 读写分离



为了解决数据库的读性能瓶颈（读比写性能更高， 写锁会影响读阻塞，从而影响读的性能）。 

很多数据库拥主从架构。也就是，一台主数据库服务器，是对外提供增删改业务的生产服务器；另一（多）台从数据库服务器，主要进行 读的操作。ꞏ 

可以通过中间件(ShardingSphere、mycat、mysql-proxy 、TDDL ....)， 但是有一些规模较小的公司，没有专门的中间件团队搭建读写分 离基础设施，因此需要业务开发人员自行实现读写分离。



![image-20230318111106738](/images/springcloud/image-20230318111106738.png)

### 业务上的分库

数据分布在不同的数据库中，数据库拆了， 应用没拆。 一个公司多个子项目，各用各的数据库，涉及数据共享.....

![image-20230318111147658](/images/springcloud/image-20230318111147658.png)



## AbstractRoutingDataSource

1. 当执行数据库持久化操作，只要集成了Spring就一定会通过**DataSourceUtils**获取Connection 
2. 通过Spring注入的DataSource获取Connection 即可执行数据库操作 所以思路就是：只需配置一个实现了DataSource的Bean, 然后根据业务动态提供Connection即可 
3. 其实Spring已经提供一个DataSource实现类用于动态切换数据源——AbstractRoutingDataSource

![image-20230318110530196](/images/springcloud/image-20230318110530196.png)



```java

import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;

@Component
@Primary
public class DynamicDataSource extends AbstractRoutingDataSource {

    // 当前使用的数据源标识
    public static ThreadLocal<String> name = new ThreadLocal<>();

    @Autowired
    private DataSource dataSource1;
    @Autowired
    private DataSource dataSource2;

    @Override
    protected Object determineCurrentLookupKey() {
        return name.get();
    }

    @Override
    public void afterPropertiesSet() {
        Map<Object, Object> targetDataSource = new HashMap<>();
        targetDataSource.put("W",dataSource1);
        targetDataSource.put("R",dataSource2);

        super.setTargetDataSources(targetDataSource);
        super.setDefaultTargetDataSource(dataSource1);
        super.afterPropertiesSet();
    }
}
```

### 使用

> 通过自定义注解，通过切面的方式增强业务方法，设置ThreadLocal

```java
@WR("R")
public List<Friend> list(){
    return friendMapper.list();
}

@WR("W")
public void save(Friend friend){
    friendMapper.save(friend);
}
```

```java
@Aspect
@Component
public class DynamicDataSourceAspect implements Ordered {
    // 前置
    @Before("within(org.hzz.service.*) && @annotation(wr)")
    public void before(JoinPoint point, WR wr){
        String name = wr.value();
        DynamicDataSource.name.set(name);
        System.out.println(name);
    }

    @Override
    public int getOrder() {
        return 0;
    }
}
```

正常来所应该设置环绕通知，方便threadLocal.remove,防止内存泄漏
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.27">
    <link rel="icon" href="/images/favicon-32x32.png"><title>静默のBlog</title><meta name="description" content="静默的Vuepress Blog">
    <link rel="preload" href="/assets/js/runtime~app.2c87fbe0.js" as="script"><link rel="preload" href="/assets/css/styles.b779b927.css" as="style"><link rel="preload" href="/assets/js/95615.aba5921d.js" as="script"><link rel="preload" href="/assets/js/app.4aafd1f6.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.b779b927.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name can-hide">静默のBlog</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/topicNav/" class="nav-link" aria-label="📗Menu"><!--[--><!--]--> 📗Menu <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/aboutme/" class="nav-link" aria-label="AboutMe"><!--[--><!--]--> AboutMe <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/Q10Viking/q10viking.github.io" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><div id="docsearch-container"></div></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/topicNav/" class="nav-link" aria-label="📗Menu"><!--[--><!--]--> 📗Menu <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/aboutme/" class="nav-link" aria-label="AboutMe"><!--[--><!--]--> AboutMe <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/Q10Viking/q10viking.github.io" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item"></p><ul class=""><li><!--[--><a aria-current="page" href="/Algorithm/%E6%A0%91.html#树的度" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="树的度"><!--[--><!--]--> 树的度 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/Algorithm/%E6%A0%91.html#树的深度" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="树的深度"><!--[--><!--]--> 树的深度 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/Algorithm/%E6%A0%91.html#树的表示" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="树的表示"><!--[--><!--]--> 树的表示 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/Algorithm/%E6%A0%91.html#常用的孩子表示法" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="常用的孩子表示法"><!--[--><!--]--> 常用的孩子表示法 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/Algorithm/%E6%A0%91.html#二叉树" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="二叉树"><!--[--><!--]--> 二叉树 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/Algorithm/%E6%A0%91.html#斜树" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="斜树"><!--[--><!--]--> 斜树 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/Algorithm/%E6%A0%91.html#满二叉树" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="满二叉树"><!--[--><!--]--> 满二叉树 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/Algorithm/%E6%A0%91.html#完全二叉树❤️" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="完全二叉树❤️"><!--[--><!--]--> 完全二叉树❤️ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/Algorithm/%E6%A0%91.html#二叉树的表示" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="二叉树的表示"><!--[--><!--]--> 二叉树的表示 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/Algorithm/%E6%A0%91.html#二叉树的遍历" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="二叉树的遍历"><!--[--><!--]--> 二叉树的遍历 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h2 id="树的度" tabindex="-1"><a class="header-anchor" href="#树的度" aria-hidden="true">#</a> 树的度</h2><p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度(Degree)。度为0的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。我们例子中的数结点的度的最大值是结点D的度，为3，所以树的度也为3</p><p><img src="/images/algorithm/image-20230924004052097.png" alt="image-20230924004052097"></p><h2 id="树的深度" tabindex="-1"><a class="header-anchor" href="#树的深度" aria-hidden="true">#</a> 树的深度</h2><p>当前树的深度为4</p><p><img src="/images/algorithm/image-20230924005010206.png" alt="image-20230924005010206"></p><h2 id="树的表示" tabindex="-1"><a class="header-anchor" href="#树的表示" aria-hidden="true">#</a> 树的表示</h2><p>树中某个结点的孩子可以有多个，这就意味着，我们在代码实现时要能体现结点之间的逻辑关系，比如谁是谁的双亲，谁是谁的孩子呢？所以简单的顺序存储结构是不能满足树的实现要求的。</p><p>一般情况下对树的存储有三种不同的表示法:双亲表示法、孩子表示法、孩子兄弟表示法</p><h4 id="双亲表示法" tabindex="-1"><a class="header-anchor" href="#双亲表示法" aria-hidden="true">#</a> 双亲表示法</h4><p>树这种结构，除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。</p><p>我们可以在每个结点中，附设一个指示器指示其双亲结点的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。</p><p>其中data是数据域，存储结点的数据信息。而parent是指针域,存储该结点的双亲的位置。</p><p><img src="/images/algorithm/image-20230924003245115.png" alt="image-20230924003245115"></p><p>有了这样的结构定义，我们就可以来实现双亲表示法了。由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这也就意味着，我们所有的结点都存有它双亲的位置</p><p>这样的存储结构，我们可以根据结点的 parent 指针很容易找到它的双亲结点，所用的时间复杂度为0[1)，直到 parent为-1时，表示找到了树结点的根。但如果我们要知道结点的孩子是什么，就需要请遍历整个结构才行</p><p><img src="/images/algorithm/image-20230924003342319.png" alt="image-20230924003342319"></p><h4 id="孩子表示法" tabindex="-1"><a class="header-anchor" href="#孩子表示法" aria-hidden="true">#</a> 孩子表示法</h4><p>双亲表示法我们知道，是由孩子指向双亲，孩子表示法则是由双亲结点指向孩子结点。但是，树中每个结点可能有多棵子树，怎么办呢？可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过,树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。</p><h5 id="方案一" tabindex="-1"><a class="header-anchor" href="#方案一" aria-hidden="true">#</a> 方案一</h5><p>一种是指针域的个数就等于树的度</p><p><img src="/images/algorithm/image-20230924004117303.png" alt="image-20230924004117303"></p><p>其中data是数据域。chid1到chidn是指针域，用来指向该结点的孩子结点。对于我们的例子来说，树的度是3，所以我们的指针域的个数是3</p><p><img src="/images/algorithm/image-20230924004148054.png" alt="image-20230924004148054"></p><p>这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。</p><p>既然很多指针域都可能为空，为什么不按需分配空间呢。于是我们有了第二种方案。</p><h5 id="方案二" tabindex="-1"><a class="header-anchor" href="#方案二" aria-hidden="true">#</a> 方案二</h5><p>第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数</p><p><img src="/images/algorithm/image-20230924004241408.png" alt="image-20230924004241408"></p><p>中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1 到 childn为指针域,指向该结点的各个孩子的结点</p><p><img src="/images/algorithm/image-20230924004259938.png" alt="image-20230924004259938"></p><p>这种方法克服了浪费空间的缺点,对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。</p><p>能否有更好的方法,既可以减少空指针的浪费又能使结点结构相同</p><h2 id="常用的孩子表示法" tabindex="-1"><a class="header-anchor" href="#常用的孩子表示法" aria-hidden="true">#</a> 常用的孩子表示法</h2><p>所以常用的孩子表示法是这样的，把每个结点放到一个顺序存储结构的数组中，再对每个结点的孩子建立把每个结点的孩子结点排列起来,以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表,采用顺序存储结构，存放进一个一维数组中</p><p><img src="/images/algorithm/image-20230924004547282.png" alt="image-20230924004547282"></p><p>这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。</p><p>但是，这也存在着问题，如何知道某个结点的双亲是谁呢?比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗?当然是可以。在存储时增加一个表示双亲结点的域就可以了。</p><h2 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h2><p>二叉树的特点有:</p><p>每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。</p><p>.左子树和右子树是有顺序的，次序不能任意颠倒。就像人是双手、双脚，但显然左手、左脚和右手、右脚是不一样的，右手戴左手套、右脚穿左鞋都会极其别扭和难受。</p><p>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。如下图，都是二叉树，但它们却是不同的二叉树。</p><p>​ <img src="/images/algorithm/image-20230924004834964.png" alt="image-20230924004834964"></p><p>二叉树具有五种基本形态:</p><p>1．空二叉树。</p><p>2．只有一个根结点。</p><p>3．根结点只有左子树。</p><p>4．根结点只有右子树。</p><p>5．根结点既有左子树又有右子树。</p><h3 id="斜树" tabindex="-1"><a class="header-anchor" href="#斜树" aria-hidden="true">#</a> 斜树</h3><p>顾名思义，斜树一定要是斜的，但是往哪斜还是有讲究。所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。斜树有很明显的特点，就是每一层都只有一个结点，<strong>结点的个数与二叉树的深度相同</strong>。</p><h3 id="满二叉树" tabindex="-1"><a class="header-anchor" href="#满二叉树" aria-hidden="true">#</a> 满二叉树</h3><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上,这样的二叉树称为满二叉树。</p><p>单是每个结点都存在左右子树，不能算是满二叉树，还必须要所有的叶子都在同一层上，这就做到了整棵树的平衡</p><p><img src="/images/algorithm/image-20230924005117206.png" alt="image-20230924005117206"></p><p>因此,满二叉树的特点有:</p><p>(1)叶子只能出现在最下一层。出现在其他层就不可能达成平衡。</p><p>(2）非叶子结点的度一定是2。否则就是“缺胳膊少腿”了。</p><p>(3)在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多</p><h3 id="完全二叉树❤️" tabindex="-1"><a class="header-anchor" href="#完全二叉树❤️" aria-hidden="true">#</a> 完全二叉树❤️</h3><p>对一棵具有n个结点的二叉树按层序编号，如果编号为i (1&lt;i&lt;n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</p><p><img src="/images/algorithm/image-20230924005254934.png" alt="image-20230924005254934"></p><p>首先从字面上要区分，“完全”和“满”的差异，满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。</p><p>其次，完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的。这里有个关键词是按层序编号。</p><p><strong>完全二叉树的数组表示法</strong></p><p><img src="/images/algorithm/image-20230924005339587.png" alt="image-20230924005339587"></p><blockquote><p><strong>推论1</strong>：对于位置为K的结点 <strong>左子结点=2<em>k+1 右子结点=2</em>(k+1)</strong></p><p>验证：C:2 2<em>2+1=5 2</em>(k+1)=6</p><p><strong>推论2</strong>：最后一个非叶节点的位置为 (N/2)-1，N为数组长度。</p></blockquote><h3 id="二叉树的表示" tabindex="-1"><a class="header-anchor" href="#二叉树的表示" aria-hidden="true">#</a> 二叉树的表示</h3><p>上面所说的数组存储结构一般只用于完全二叉树。二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法。</p><p>其中data是数据域，leftchild和rightchild都是指针域，分别存放指向左孩子和右孩子的指针。当然根据需要，增加双亲结点的指针和兄弟结点的指针都没什么问题。</p><h3 id="二叉树的遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的遍历" aria-hidden="true">#</a> 二叉树的遍历</h3><p>二叉树的遍历（traversing binary tree)是指从根结点出发,按照某种次序依次访问二叉树中所有结点，,使得每个结点被访问一次且仅被访问一次。</p><p>访问其实是要根据实际的需要来确定具体做什么，比如对每个结点进行相关计算，输出打印等。在这里我们可以简单地假定就是输出结点的数据信息。通过结点的指针域到达其他结点不能称为访问，我们可以把这种操作称之为<strong>经过</strong>结点</p><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"> ← <a href="/Algorithm/" class="nav-link router-link-active" aria-label="Back To 目录"><!--[--><!--]--> Back To 目录 <!--[--><!--]--></a></span><!----></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script src="/assets/js/runtime~app.2c87fbe0.js" defer></script><script src="/assets/js/95615.aba5921d.js" defer></script><script src="/assets/js/app.4aafd1f6.js" defer></script>
  </body>
</html>
